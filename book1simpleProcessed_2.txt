computer graphics c version donald hearn pauline baker contents preface xvii survey computer graphics computer aided design presentation graphics computer art entertainment education training visualization image processing graphical user interfaces overview graphics systems video display devices refresh cathode ray tubes raster scan displays random scan displays color crt monitors direct view storage tubes flat panel displays three dimensional viewing devices stereoscopic virtual reality systems raster scan systems video controller raster scan display processor random scan systems graphics monitors workstations input devices keyboards mouse trackball spaceball joysticks data glove digitizers image scanners touch panels light pens voice systems hard copy devices graphics software coordinate representations graphics functions software standards phigs workstations summary references exercises contents output primitives points lines line drawing algorithms 8b dda algorithm bresenham line algorithm parallel line algorithms loading frame buffer line function circle generating algorithms properties circles midpoint circle algorithm ellipse generating algorithms properties ellipses midpoint ellipse algorithm curves conic sections polynomials spline curves parallel curve algorithms curve functions pixel addressing object geometry screen grid coordinates maintaining geometric properties displayed objects filled area primitives scan line polygon fill algorithm inside outside tests scan line fill curved boundary areas boundary fill algorithm flood fill algorithm fill area functions cell array character generation summary applications references exercises attributes output primitives line attributes line type line width pen brush options line color curve attributes color grayscale levels color tables grayscale area fill attributes fill styles pattern fill soft fill character attributes text attributes marker attributes bundled attributes bundled line attributes bundled area fill attributes bundled text attributes bundled marker attributes inquiry functions antialiasing supersampling straight line segments pixel weighting masks area sampling straight line segments filtering techniques pixel phasing compensating line intensity differences antialiasing area boundaries summary references exercises two dimensional geometric transformations basic transformations translation rotation scaling matrix representations homogeneous coordinates composite transformations translations rotations scalings general pivot point rotation general fixed point scaling general scaling directions concatenation properties general composite transformations computational efficiency transformations reflection shear transformations coordinate systems contents affine transformations transformation functions raster methods transformations summary references exercises two dimensional viewing viewing pipeline viewing coordinate reference frame window viewport coordinate transformation two dimensional viewing functions clipping operations point clipping line clipping cohen sutherland line clipping liang barsky line clipping nicholl lee nicholl line clipping line clipping using nonrectangular clip windows splitting concave polygons polygon clipping sutherland hodgeman polygon clipping weiler atherton polygon clipping polygon clipping algorithms curve clipping text clipping exterior clipping summary references exercises contents structures hierarchical modeling structure concepts basic structure functions setting structure attributes editing structures structure lists element pointer setting edit mode inserting structure elements replacing structure elements deleting structure elements labeling structure elements copying elements one structure another basic modeling concepts model representations symbol hierarchies modeling packages hierarchical modeling structures local coordinates modeling transformations modeling transformations structure hierarchies summary references exercises graphical user interfaces interactive input methods user dialogue windows icons accommodating multiple skill levels consistency minimizing memorization backup error handling feedback input graphical data logical classification input devices locator devices stroke devices string devices valuator devices choice devices pick devices input functions input modes request mode locator stroke input request mode string input request mode valuator input request mode choice input request mode pick input request mode sample mode event mode concurrent use input modes initial values input device parameters interactive picture construction techniques basic positioning methods constraints grids gravity field rubber band methods dragging painting drawing virtual reality environments summary references exercises three dimensional concepts three dimensional display methods parallel projection perspective projection depth cueing visible line surface identification surface rendering exploded cutaway views three dimensional stereoscopic views three dimensional graphics packages three dimensional object representations 10 polygon surfaces polygon tables plane equations polygon meshes 10 curved lines surfaces 10 quadric surfaces sphere s11 ellipsoid 3u torus contents superquadrics superellipse superellipsoid blobby objects spline representations interpolation approximation splines parametric continuity conditions geometric continuity conditions spline specifications cubic spline interpolation methods natural cubic splines hermite interpolation cardinal splines kochanek bartels splines b zier curves surfaces b zier curves properties b zier curves design techniques using b zier curves cubic b zier curves b zier surfaces b spline curves surfaces b spline curves uniform periodic b splines cubic periodic b splines open uniform b splines nonuniform b splines b spline surfaces 10 beta splines beta spline continuity conditions cubic periodic beta spline matrix representation 11 rational splines contents conversion spline representations displaying spline curves surfaces horner rule forward difference calculations subdivision methods sweep representations constructive solid geometry methods octrees bsp trees fractal geometry methods fractal generation procedures classification fractals fractal dimension geometric construction deterministic self similar fractals geometric construction statistically self similar fractals affine fractal construction methods random midpoint displacement methods controlling terrain topography self squaring fractals self inverse fractals shape grammars procedural methods particle systems physically based modeling visualization data sets visual representations scalar fields visual representations vector fields visual representations tensor fields visual representations multivariate data fields summary references exercises three dimensional geometric modeling transformations w1 translation 11 rotation coordinate axes rotations general three dimensional rotations rotations quaternions 11 scaling 11 transformations reflections shears 11 composite transformations 11 three dimensional transformation functions w1e7 modeling cocrdinate transformations summary references exercises 12 three dimensional viewing viewing pipeline 12 viewing coordinates specifying view plane transformation world viewing coordinates projections parallel projections perspective projections view volumes general projection transformations general parallel projection transformations general perspective projection transformations clipping normalized view volumes viewport clipping clipping homogeneous coordinates hardware implementations three dimensional viewing functions summary references exercises visible surface detection methods 13 classification visible surface detection algorithms 13 back face detection 13 depth buffer method 13 buffer methad 13 scan line method 13 depth sorting method 13 bsp tree method 13 area subdivision method 13 octree methods 13 ray casting method 13 curved surfaces curved surface representations surface contour plots contents wireframe methods visibitity detection functions summary references exercises methods 14 light sources 14 basic illumination models ambient light diffuse reflection specular reflection phong model combined diffuse specular reflections multiple light sources warn model intensity attenuation color considerations transparency shadows 14 displaying light intensities assigning intensity levels gamma correction video lookup tables displaying continuous tone images 14 halftone patterns dithering techniques halftone approximations dithering techniques 14 polygon rendering methods constant intensity shading gouraud shading phong shading contents fast phong shading ray tracing methods basic ray tracing algorithm ray surface intersection calculations reducing object intersection calculations space subdivision methods antialiased ray tracing distributed ray tracing radiosity lighting model basic radiosity model progressive refinement radiosity method environment mapping adding surface detail modeling surface detail polygons texture mapping procedural texturing methods bump mapping frame mapping summary references exercises color models color applications 15 properties light 15 standard primaries chromaticity diagram xyz color model cif chromaticity diagram 15 intuitive color concepts 15 rgb color model 15 yiq color model 15 cmy color model 15 hsv color model 15 conversion hsv rgb models 15 hls color model 15 color selection applications summary references exercises computer animation 16 design animation sequences 16 general computer animation functions 16 raster animations 16 computer animation languages 16 key frame systems morphing simulating accelerations 16 motion specifications direct motion specification goal directed systems kinematics dynamics summary references exercises mathematics computer graphics coordinate reference frames two dimensional cartesian reference frames polar coordinates xy plane three dimensional cartesian reference frames three dimensional curvilinear coordinate systems solid angle points vectors vector addition scalar multiplication scalar product two vectors vector product two vectors basis vectors metric tensor orthonormal basis metric tensor matrices scalar multiplication matrix addition matrix multiplication contents matrix transpose determinant matrix matrix inverse complex numbers quaternions nonparametric representations parametric representations numerical methods solving sets linear equations finding roots nonlinear equations evaluating integrals fitting curves data sets computer graphics c version chapter survey computer graphics omputers become powerful tool rapid economical pro duction pictures virtually area graphical displays used advantage surprising find use computer graphics widespread although early applications engineering science rely expensive cumbersome equipment advances computer technology made interactive computer graphics practical tool today find computer graphics used routinely diverse areas science engineering medicine business industry government art entertainment ad vertising education training summarizes many applications graphics simulations education graph presentations get details computer graphics first take short tour gallery graphics applications frgtere examples computer graphics applications courtesy dicomed corporation major use computer graphics design processes particularly engi neering architectural systems almost products computer de signed generally referred cad computer aided design methods routinely used design buildings automobiles aircraft watercraft space craft computers textiles many many products design applications objects first displayed wireframe line form shows overall shape internal features objects wireframe displays also allow designers quickly see effects interactive adjustments design shapes figures give examples wireframe displays de sign applications software packages cad applications typically provide designer multi window environment figs various displayed windows show enlarged sections different views objects circuits one shown networks communica tions water supply utilities constructed repeated placement graphical shapes shapes used design represent different net work circuit components standard shapes electrical electronic logic circuits often supplied design package applications de signer create personalized symbols used construct net work circuit system designed successively placing components layout graphics package automatically providing connec tions components allows designer quickly try alternate circuit schematics minimizing number components space quired system color coded wireframe display automobile wheel assembly courtesy eoans sutherland color coded wireframe displays body designs aircraft automobile courtesy evans sutherland b megatek corporation animations often used cad applications real time animations using wireframe displays video monitor useful testing performance hicle system demonstrated display objects rendered surfaces calculations segment animation per formed quickly produce smooth real time motion screen also wire frame displays allow designer see interior vehicle watch behavior inner components motion animations virtual reality environments used determine vehicle operators affected multiple window color coded cad workstation displays courtesy intergraph corporation circuit design application using multiple windows color coded logic components displayed sun workstation attached speaker microphone courtesy sun microsystems simulation vehicle performance lane changes courtesy evans sutherland mechanical dynamics inc certain motions tractor operator manipulates controls headset presents stereoscopic view front loader bucket backhoe operator tractor seat allows designer explore various positions bucket backhoe might obstruct op erator view taken account overall tractor design shows composite wide angle view tractor seat displayed standard video monitor instead virtual three dimensional scene shows view tractor displayed separate window another monitor operating tractor virtual reality environment controls moved operator views front loader backhoe surroundings headset courtesy national center supercomputing applications university illinois urbana champaign caterpillar ine headset view backhoe presented tractor operator courtesy national center supercomputing applications university illinois urbana champaign caterpillar inc operator view tractor bucket composited several sections form wide angle view standard monitor courtesy national center supercomputing applications university mlinois urbana champaign caterpillar inc chapter survey computer graphics view tractor displayed standard monitor courtesy national center supercomputing applications university illinois urbana champaign caterpillar inc object designs complete nearly complete realistic lighting models surface rendering applied produce displays show appearance final product examples given realistic displays also generated advertising automobiles vehicles using special lighting effects background scenes manufacturing process also tied computer description de signed objects automate construction product circuit board lay example transformed description individual processes needed construct layout mechanical parts manufac tured describing surfaces formed machine tools figure 13 shows path taken machine tools surfaces object construction numerically controlled machine tools set manufacture part according construction layouts realistic renderings design products courtesy intergraph corporation b evans sutherland studio lighting effects realistic acad layout describing surface rendering techniques numerically controlled machining applied produce advertising part part surface pieces finished products displayed one color tool data rendering chrysler path another color courtesy laser supplied chrysler los alamos national laboratory corporation courtesy eric haines 3d eye inc michen e ime tt ee rr rid fl ig li fl uz eof r ep ig faby adio ii ltd renee att ht architectural cad layout building design courtesy precision visuals inc boulder colorado architects use interactive graphics methods lay floor plans show positioning rooms doors windows stairs shelves counters building features working display building layout video monitor electrical designer try arrangements wiring electrical outlets fire warning systems also facility layout packages applied layout determine space utilization office manufacturing floor realistic displays architectural designs permit archi tects clients study appearance single building group buildings campus industrial complex virtual reality systems designers even go simulated walk rooms around outsides buildings better appreciate overall effect particular design addition realistic exterior building displays architectural cad packages also provide facilities experimenting three dimensional interior layouts lighting many kinds systems products designed using either gen eral cad packages specially developed cad software exam ple shows rug pattern designed cad system eageguater realistic three dimensional renderings building designs street level perspective world trade center project courtesy skidmore owings merrill b architectural visualization atrium created comptter animation marialine prieur lyon france courtesy thomson digital image inc hotel corridor providing sense fixtures along undulating path creating sense entry using light towers hotel room courtesy skidmore owings merrill another major application area presentation graphics used produce illus trations reports generate mm slides transparencies use projectors presentation graphics commonly used summarize financial sta tistical mathematical scientific economic data research reports manage rial reports consumer information bulletins types reports worksta tion devices service bureaus exist converting screen displays mm slides overhead transparencies use presentations typical examples presentation graphics bar charts line graphs surface graphs pie charts displays showing relationships multiple parameters gives examples two dimensional graphics combined ge ographical information illustration shows three color coded bar charts com bined onto one graph pie chart three sections similar graphs charts displayed three dimensions provide additional information three dimensional graphs sometimes used simply effect provide dramatic attractive presentation data relationships charts include three dimensional bar graph exploded pie chart additional examples three dimensional graphs shown figs 20 21 shows one kind surface plot shows two dimensional contour plot height surface oriental rug pattern created movement placing light computer graphics design methods courtesy lexidata corporation w chapter survey computer graphics two dimensional bar chart pie chart linked geographical chart courtesy computer associates copyright rights reserved showing relationships surface chart courtesy computer associates copyright rights reserved three dimensional bar chart exploded pie chart line graph courtesy computer associates copyright rights reserved plotting two dimensional contours ground plane height field plotted surface ground plane courtesy computer associates copyright rights reserved time chart displaying relevant information project tasks courtesy computer associates copyright rights reserved illustrates time chart used task planning time charts task network layouts used project management schedule monitor progress projects computer graphics methods widely used fine art commercial art applications artists use variety computer methods including special pur pose hardware artist paintbrush programs lumena paint pack ages pixelpaint superpaint specially developed software symbolic mathematics packages mathematica cad packages desktop publish ing software animation packages provide facilities designing object shapes specifiying object motions illustrates basic idea behind paintbrush program al lows artists paint pictures screen video monitor actually pic ture usually painted electronically graphics tablet digitizer using sty lus simulate different brush strokes brush widths colors paintbrush program used create characters seem busy creation paintbrush system wacom cordless pressure sensitive stylus used produce electronic painting simulates brush strokes van gogh stylus translates changing hand pressure variable line widths brush sizes color gradations shows watercolor painting produced stylus software allows artist cre ate watercolor pastel oil brush effects simulate different drying times wetness footprint gives example paintbrush methods combined scanned images fine artists use variety computer technologies produce images create pictures one shown artist uses combina tion three dimensional modeling packages texture mapping drawing pro grams cad software painting produced pen section computer art p cartoon drawing produced paintbrush program symbolically illustrating artist work video monitor courtesy gould inc imaging graphics division aurora imaging plotter specially designed software create automatic art without intervention artist shows example mathematical art artist uses com bination mathematical functions fractal procedures mathematica software ink jet printers systems create variety three dimensional two dimensional shapes stereoscopic image pairs another example elec cartoon demonstrations artist creating picture paintbrush system picture drawn ona graphics tablet displayed video monitor elves look b cartoon superimposed famous thomas nast drawing saint nicholas input system video camera scaled positioned courtesy gould inc imaging graphics division aurora imaging igh van gogh look alike created graphics artist elizabeth rourke cordless pressure sensitive stylus courtesy wacorn technology corporation electronic watercolor painted john derry time arts inc using cordless pressure sensitive stylus lumena gouache brush software courtesy wacom technology corporation artist picture called electronic avalanche makes statement entanglement technology using personal computer graphics tablet lumena software combine renderings leaves flower petals electronics components scanned images courtesy williams gallery copyright joan truckenbrod school art institute chicago series called spheres influence electronic painting entitled whigmalaree created combination methods using graphics tablet three dimensional modeling texture mapping series transformations courtesy williams gallery copyright wynne ragland r electronic art output pen plotter software specially designed artist emulate style pen plotter includes multiple pens painting instruments including chinese brushes courtesy williams gallery copyright roman verostko minneapolis college art design creation based visualization fermat last theorem x n andrew hanson department computer science indiana university image rendered using mathematica wavefront software courtesy williams gallery copyright stewart dickson using mathematical functions fractal procedures supercomputers artist composer experiments various designs synthesize form color musical composition courtesy brian evans vanderbilt university tronic art created aid mathematical relationships shown section artwork composer often designed relation frequency varia computer tions parameters musical composition produce video inte grates visual aural patterns although spent time discussing current techniques gen erating electronic images fine arts methods also applied com mercial art logos designs page layouts combining text graph ics tv advertising spots areas workstation producing page layouts combine text graphics illustrated many applications commercial art motion pictures applications photorealistic techniques used render images product shows example logo design gives three computer graphics images product advertising animations also used frequently advertising television commercials produced frame frame page layout workstation courtesy three dimensional rendering visual technology logo courtesy vertigo technology inc aj b product advertising courtesy audrey fleisher b c softimage inc v7 frame motion rendered saved image file succes sive frame motion simulated moving object positions slightly positions previous frame frames animation sequence rendered frames transferred film stored video buffer playback film animations require frames second animation se quence animation played back video monitor frames per second required common graphics method employed many commercials morphing one object transformed metamorphosed another method used tv commercials turn oil automobile engine au tomobile tiger puddle water tire one person face face example morphing given computer graphics methods commonly used making motion pic tures music videos television shows sometimes graphics scenes dis played sometimes graphics objects combined ac tors live scenes graphics scene generated movie siar trek wrath khan shown planet spaceship drawn wireframe form shaded rendering methods produce solid surfaces shows scenes generated advanced modeling surface rendering meth ods two award winning short films many tv series regularly employ computer graphics methods shows scene produced series deep space nine shows wireframe person combined actors live scene series stay tuned graphics developed paramount pictures movie star trek wrath khan courtesy evans sutherland highly realistic image taken reconstruction thir section teenth century dadu beijing japanese broadcast entertainment music videos use graphics several ways graphics objects com bined live action fig 38 graphics image processing tech niques used produce transformation one person object morphing example morphing shown sequence scenes produced david byrne video mad b computer generated scene film red dream copyright pixar b computer generated scene film knickknack copyright pixar courtesy pixar graphics scene tv series deep space nine courtesy rhythm hues studios chapter survey computer graphics graphics combined live scene tv series stay tuned courtesy rhythm hues studios image reconstruction thirteenth century dadu beijing today created taisei corporation tokyo rendered tdi software courtesy thompson digital image inc section education training examples morphing david byrne video mad courtesy david byrne index video pacific data images computer generated models physical financial economic systems often used educational aids models physical systems physiological sys tems population trends equipment color coded diagram fig help trainees understand operation system training applications special systems designed examples specialized systems simulators practice sessions training ship captains aircraft pilots heavy equipment operators air traffic control personnel simulators video screens example flight simula tor control panel instrument flying simulators provide graphics screens visual operation two examples large simulators ternal viewing systems shown figs 42 43 another type viewing system shown viewing screen multiple panels mounted front simulator color projectors display flight scene screen panels similar viewing systems used simulators training air craft control tower personnel gives example instructor area flight simulator keyboard used input parameters affecting airplane performance environment pen plotter used chart path aircraft training session scenes generated various simulators shown figs 46 output automobile driving simulator given simulator used investigate behavior drivers critical situations drivers reactions used basis optimizing vehicle design maxi mize traffic safety rae te color coded diagram used ta large enclosed flight simulator explain operation nuclear full color visual system reactor courtesy los alamos six degrees freedom national laboratory motion courtesy frasca international military tank simulator visual imagery system courtesy mediatech ge aerospace section education training flight simulator external full color viewing system courtesy frasca international instructor area flight simulator equipment allows instructor monitor flight conditions set airplane environment parameters courtesy frasca international flight simulator imagery courtesy evans sutherland imagery generated naval simulator courtesy eoans sutherland space shuttle imagery courtesy mediatech ge aerospace imagery automobile simulator used test driver reaction courtesy evans sutherland scientists engineers medical personnel business analysts others often need analyze large amounts information study behavior certain processes numerical simulations carried supercomputers frequently pro duce data files containing thousands even millions data values similarly satellite cameras sources amassing large data files faster interpreted scanning large sets numbers tu determine trends relationships tedious ineffective process data converted visual form trends patterns often immediately apparent figure shows example large data set converted color coded display relative heights ground plane plotted den sity values way see easily overall pattern data produc ing graphical representations scientific engineering medical data sets processes generally referred scientific visualization term busi ness visualization used connection data sets related commerce indus try nonscientific areas many different kinds data sets effective visualization schemes depend characteristics data collection data con tain scalar values vectors higher order tensors combination data types data sets two dimensional three dimensional color coding one way visualize data set additional techniques include contour plots graphs charts surface renderings visualizations volume interi ors addition image processing techniques combined computer graphics produce many data visualizations mathematicians physical scientists others use visual techniques alyze mathematical functions processes simply produce interesting graphical representations color plot mathematical curve functions shown surface plot function shown fractal proce section visualization chapter survey computer graphics color coded plot million density points relative brightness observed whirlpool nebula reveals two distinct galaxies courtesy los alamos national laboratory tw mathematical curve functions plotted various color combinations courtesy melvin l prueitt los alamos national laboratory lighting effects surface rendering techniques applied produce surface tepresentation three dimensional function courtesy wolfram research inc maker mathematica dures using quaternions generated object shown topologi section cal structure displayed scientists also developing methods _ visualization visualizing general classes data shows general technique graphing modeling data distributed spherical surface many visualization applications shown figs 56 69 figures show airflow surface space shuttle nu merical modeling thunderstorms study crack propagation metals color coded plot fluid density airfoil cross sectional slicer data sets protein modeling stereoscopic viewing molecular structure model ocean floor kuwaiti oil fire simulation air pollution study corn grow ing study reconstruction arizona chaco canyon ruins graph auto mobile accident statistics four dimensional object projected three dimensional space projected video monitor color coded object generated using quaternions fractal squaring procedures octant subtracted show complex julia set courtesy john c hart school electrical engineering computer science washington state university four views real time interactive computer animation study minimal surfaces snails sphere projected three dimensional euclidean space courtesy george francis department mathematics national center supercomputing applications university minois urbana champaign copyright method graphing modeling data distributed spherical surface courtesy greg nielson computer sctence department arizona state university visualization stream surfaces flowing past space shuttle jeff hultquist eric raible nasa ames courtesy sam uselton nasa ames research center numerical model surface thunderstorm courtesy bob wilkelmson department atmospheric sciences national center supercomputing applications university mlinois urbana champaign numerical model airflow inside thunderstorm courtesy bob wilhelmson department atmospheric sciences national center supercomputing applications university minois urbana champaign color coded visualization stress energy density crack propagation study metal plates modeled bob haber courtesy national center supercomputing applications university ilinois urbana champaign commercial slicer dicer software showing color coded data values cross sectional slices data set courtesy spyglass inc section visualization fluid dynamic simulation showing color coded plot fluid density span grid planes around aircraft wing developed lee hian quek john eickemeyer jeffery tan courtesy information technology institute republic singapore visualization protein structure jay siegel kim baldridge sdsc courtesy stephanie sides san diego supercomputer center stereoscopic viewing molecular structure using boom device courtesy national center supercomputing applications university illinois urbana champaign one image stereogcopic pair showing visualization ocean floor obtained satellite data david sandwell chris small scripps institution ocean ography jim mcleod sdsc courtesy stephanie sides san diego supercomputer center simulation effects kuwaiti oil fire gary glatzmeier chuck hanson paul hinker courtesy mike krogh advanced computing laboratory los alamos national laboratory section visualization visualization pollution earth surface tom palmer cray research inc ncsc chris landreth ncsc dave bock ncsc pollutant plotted blue surface acid rain deposition color plane map surface rain concentration shown clear cylinders courtesy north carolina supercomputing center mcnc visualization reconstruction ruins chaco canyon arizona courtesy melvin l prueitt los alamos national laboratory data supplied stephen h lekson one frame animation sequence showing development corn ear courtesy national center supercomputing applications university mlinois urbana champaign ls eg ont regen tec pti tel pee os rere ie eae ahr analysis prototype technique called win viz visualizing tabular multidimensional data used correlate statistical information pedestrians involved automobile accidents developed visualization team itt courtesy lee hian quek information technology institute republic singapore although methods used computer graphics image processing overlap two areas concerned fundamentally different operations computer graphics computer used create picture image processing hand applies techniques modify interpret existing pictures pho tographs tv scans wo principal applications image processing improving picture quality machine perception visual information used robotics apply image processing methods first digitize photograph picture image file digital methods applied rearrange pic ture parts enhance color separations improve quality shading example application image processing methods enhance quality picture shown techniques used extensively com mercial art applications involve retouching rearranging sections photographs artwork similar methods used analyze satellite photos earth photos galaxies medical applications also make extensive use image processing tech niques picture enhancements tomography simulations opera tions tomography technique x ray photography allows cross sec tional views physiological systems displayed computed x ray tomography ct position emission tomography pet use projection methods reconstruct cross sections digital data techniques also used blurred photograph license plate becomes legible application image processing techniques courtesy los alamos national laboratory monitor internal functions show cross sections surgery med ical imaging techniques include ultrasonics nuclear medicine scanners ultrasonics high frequency sound waves instead x rays used generate digital data nuclear medicine scanners collect digital data radiation emit ted ingested radionuclides plot color coded images image processing computer graphics typically combined many applications medicine example uses techniques model study physical functions design artificial limbs plan practice surgery last application generally referred computer aided surgery two dimensional cross sections body obtained using imaging tech niques slices viewed manipulated using graphics methods simulate actual surgical procedures try different surgical cuts exam ples medical applications shown figs 71 72 one frame computer animation visualizing cardiac activation levels within regions semitramsparent volume rendered dog heart medical data provided william smith ed simpson g allan johnson duke university image rendering software tom palmer cray research inc ncsc courtesy dave bock north carolina supercomputing center mcnc one image stereoscopic pair showing bones human hand images rendered inmo yoon e thompson w n waggenspack jr lsu data set obtained ct scans rehabilitation research gwlnhdc images show possible tendon path reconstructive surgery courtesy imrlab mechanical engineering louisiana state university section image processing chapter survey computer graphics graphical user interfaces common software packages provide graphical interface major component graphical interface window manager allows user display multiple window areas window contain different process contain graphical nongraphical displays make particular win dow active simply click window using interactive pointing device interfaces also display menus icons fast selection processing op tions parameter values icon graphical symbol designed look like processing option represents advantages icons take less screen space corresponding textual descriptions understood quickly well designed menus contain lists textual descrip tions icons illustrates typical graphical interface containing window manager menu displays icons example menus allow selection processing options color values graphics parameters icons represent options painting drawing zooming typing text strings operations connected picture construction graphical user interface showing multiple window areas menus icons courtesy image corporation chapter overview graphics systems ue widespread recognition power utility computer graphics virtually fields broad range graphics hardware software systems available graphics capabilities two dimen sional three dimensional applications common general purpose computers including many hand held calculators personal computers use wide variety interactive input devices graphics software pack ages higher quality applications choose number sophisti cated special purpose graphics hardware systems technologies chap ter explore basic features graphics hardware components graphics software packages typically primary output device graphics system video monitor fig operation video monitors based standard cathode ray tube crt design several technologies exist solid state monitors may eventually predominate computer graphics workstation courtesy tektronix inc refresh cathode ray tubes illustrates basic operation crt beam electrons cathode rays emitted electron gun passes focusing deflection systems direct beam toward specified positions phosphor coated screen phosphor emits small spot light position contacted electron beam light emitted phosphor fades rapidly method needed maintaining screen picture one way keep phosphor glowing redraw picture repeatedly quickly directing electron beam back points type display called refresh crt primary components electron gun crt heated metal cathode control grid heat supplied cathode directing current coil wire called filament inside cylindrical cathode structure causes electrons boiled hot cathode surface vacuum inside crt envelope free negatively charged electrons accelerated toward phosphor coating high positive voltage acceler magnetic deflection coils phosphor focusing coated system screen electron connector electron beam pins gun basic design magnetic deflection crt electron focusing beam cathode anode path heating filament control accelerating grid anode operation electron gun accelerating anode section video display devices chapter overview graphics systems ating voltage generated positively charged metal coating side crt envelope near phosphor screen accelerating anode used sometimes electron gun built contain acceler ating anode focusing system within unit intensity electron beam controlled setting voltage levels control grid metal cylinder fits cathode high negative voltage applied control grid shut beam repelling electrons stopping passing small hole end control grid structure smailer negative voltage control grid simply decreases number electrons passing since amount light emitted phosphor coating depends number electrons striking screen control brightness display varying voltage control grid specify intensity level individual screen positions graphics software commands discussed chapter focusing system crt needed force electron beam con verge small spot strikes phosphor otherwise electrons would repel beam would spread approaches screen fo cusing accomplished either electric magnetic fields electrostatic focus ing commonly used television computer graphics monitors elec trostatic focusing electron beam passes positively charged metal cylinder forms electrostatic lens shown action electrostatic lens focuses electron beam center screen exactly way optical lens focuses beam light particular focal dis tance similar lens focusing effects accomplished magnetic field set coil mounted around outside crt envelope magnetic lens fo cusing produces smallest spot size screen used special purpose devices additional focusing hardware used high precision systems keep beam focus screen positions distance electron beam must travel different points screen varies radius curvature crts greater distance focusing system screen center therefore electron beam focused properly center screen beam moves outer edges ihe screen displayed images become blurred compensate system adjust focusing ac cording screen position beam focusing deflection electron beam controlled either electric fields magnetic fields cathode ray tubes commenly constructed magnetic deflection coils mounted outside crt envelope illustrated two pairs coils used coils pair mounted opposite sides neck crt envelope one pair mounted top bottom neck pair mounted opposite sides neck magnetic field produced pair coils sults transverse deflection force perpendicular direction magnetic field direction travel electron beam horizontal deflection accomplished one pair coils vertical deflection pair proper deflection amounts attained adjusting current coils electrostatic deflection used two pairs parallel plates mounted inside crt envelope one pair plates mounted hori zontally control vertical deflection pair mounted vertically control horizontal deflection spots light produced screen transfer crt beam energy phosphor electrons beam collide phos vertical phospher focusing deflection costed system plates screen electron connector electron horizontal beam pins gun deflection plates electrostatic deflection electron beam crt phor coating stopped kinetic energy absorbed phos phor part beam energy converted friction heat energy remainder causes electrons phosphor atoms move higher quan tum energy levels short time excited phosphor electrons begin dropping back stable ground state giving extra energy small quantums light energy see screen combined effect electron light emissions glowing spot quickly fades excited phosphor electrons returned ground energy level frequency color light emitted phosphor proportional energy differ ence excited quantum state ground state different kinds phosphors available use crt besides color major difference phosphors persistence long continue emit light excited electrons returning ground state crt beam removed persistence defined time takes emitted light screen decay one tenth original intensity lower persistence phosphors require higher refresh rates maintain picture screen without flicker phosphor low persistence useful animation high persistence phosphor useful displaying highly complex static pic tures although phosphors persistence greater second graph ics monitors usually constructed persistence range microseconds shows intensity distribution spot screen tensity greatest center spot decreases gaussian distrib ution edges spot distribution corresponds cross sectional electron density distribution crt beam maximum number points displayed without overlap crt referred resolution precise definition resolution number points per centimeter plotted horizontally vertically although often simply stated total number points direction spot intensity gaussian distribution two adjacent spots appear distinct long separation greater diameter spot intensity percent center spot overlap position illustrated spot size also depends intensity electrons accelerated toward phospher per second crt beam diameter illuminated spot increase addition increased exci tation energy tends spread neighboring phosphor atoms directly intensity distribution illuminated phosphor spot crt screen chapter overview graphics systems two illuminated phosphor spots distinguishable separation greater diameter spot intensity fallen percent maximum path beam increases spot diameter thus resolution crt dependent type phosphor intensity displayed focusing deflection systems typical resolution high quality systems higher resolutions available many systems high resolution systems often referred high definition systems physical size graphics monitor given length screen diagonal sizes varying inches inches crt monitor tached variety computer systems number screen points actually plotted depends capabilities system tached another property video monitors aspect ratio number gives ratio vertical points horizontal points necessary produce equal length lines directions screen sometimes aspect ratio stated terms ratio horizontal vertical points aspect ratio means ver tical line plotted three points length horizontal line plot ted four points raster scan displays common type graphics monitor employing crt raster scan display based television technology raster scan system electron beam swept across screen one row time top bottom electron beam moves across row beam intensity turned create pattern illuminated spots picture definition stored memory area called refresh buffer frame buffer memory area holds set intensity values screen points stored intensity values trieved refresh buffer painted screen one row scan line time screen point referred pixel pel shortened forms picture element capability raster scan system store inten sity information screen point makes well suited realistic displav scenes containing subtle shading color patterns home television sets printers examples systems using raster scan methcds intensity range pixel positions depends capability raster system simple black white system screen point either oft one bit per pixel needed control intensity screen positions bilevel system bit value indicates electron beam turned position value indicates beam intensity additional bits needed color intensity variations displayed bits per pixel included high quality systems require several megabytes storage frame buffer depending resolution system system bits per pixel screen resolution bv requires megabytes storage frame buffer black white system one bit per pixel frame buffer commonly called bitmap systems multiple bits per pixel frame buffer often referred pixmap refreshing raster scan displays carried rate frames per second although systems designed higher refresh rates sometimes refresh rates described units cycles per second hertz hz cycle corresponds one frame using units would de scribe refresh rate frames per second simply hz end scan line electron beam returns left side screen begin displav ing next scan line return left screen refreshing raster scan system displays object set discrete points across scan line scan line called horizontal retrace electron beam end frame displayed 80th 60th second electron beam returns vertical retrace top left corner screen begin next frame raster scan systems tv sets frame displayed two passes using interlaced refresh procedure first pass beam sweeps across every scan line top bottom vertical trace beam sweeps remaining scan lines interlacing scan lines way allows us see entire screen displayed one half time would taken sweep across lines top bottom interlacing primarily used slower refreshing rates older frame per second noninterlaced display instance flicker noticeable interlacing two passes accomplished 60th sec ond brings refresh rate nearer frames per second effec tive technique avoiding flicker providing adjacent scan lines contain sim ilar display information random scan displays operated random scan display unit crt electron beam di rected parts screen picture drawn random scan monitors draw picture one line time reason also ferred vector displays stroke writing calligraphic displays component lines picture drawn refreshed random scan sys chapter overview graphics systems interlacing scan lines raster scan display first points even numbered solid scan lines displayed points along odd numbered dashed lines displayed tem specified order pen plotter operates similar way example random scan hard copy device refresh rate random scan system depends number lines displayed picture definition stored set line drawing commands area memory referred refresh display file sometimes refresh display file called display list display program simply refresh buffer display specified picture system cycles set com mands display file drawing component line turn line drawing commands processed system cycles back first line command list random scan displays designed draw compo nent lines picture times second high quality vector systems capable handling approximately 000 short lines refresh rate small set lines displayed refresh cycle delayed avoid refresh rates greater frames per second otherwise faster refreshing set lines could burn phosphor random scan systems designed line drawing applications display realistic shaded scenes since picture definition stored set line drawing instructions set intensity values screen points vector displays generally higher resolution raster systems also vector displays produce smooth line drawings crt beam directly follows line path raster system contrast produces jagged lines plotted discrete point sets color crt monitors crt monitor displays color pictures using combination phosphors emit different colored light combining emitted light different phosphors range colors generated two basic techniques pro ducing color displays crt beam penetration method shadow mask method beam penetration method displaying color pictures used random scan monitors two layers phosphor usually red green random scan system draws component lines object order specified coated onto inside crt screen displayed color depends far electron beam penetrates phosphor layers beam slow electrons excites outer red layer beam fast electrons penetrates red layer excites inner green layer intermediate beam speeds combinations red green light emitted show two additional colors orange yellow speed electrons hence screen color point controlled beam acceleration voltage beam penetration inexpensive way produce color random scan monitors four colors possible quality pictures good methods shadow mask methods commonly used raster scan systems includ ing color tv produce much wider range colors beam penetration method shadow mask crt three phosphor color dots pixel position one phosphor dot emits red light another emits green light third emits blue light type crt three electron guns one color dot shadow mask grid behind phosphor coated screen illustrates delia delta shadow mask method commonly used color crt systems three electron beams deflected focused group onto shadow mask contains series holes aligned phosphor dot patterns three beams pass hole shadow mask activate dot triangle appears small color spot screen phosphor dots triangles arranged electron beam activate corresponding color dot passes electron guns cc _ x selectian g shadow mask magnified phosphor dot blue triangle _ screen operation delta delta shadow mask crt three electron guns aligned triangular color dot patterns screen directed dot triangle shadow mask shadow mask another configuration three electron guns line arrangement three electron guns corresponding red green blue color dots screen aligned along one scan line instead triangular pattern line arrangement electron guns easier keep alignment commonly used high resolution color crts obtain color variations shadow mask crt varying intensity levels three electron beams turning red green guns get color coming blue phosphor combinations beam tensities produce small light spot pixel position since eyes tend merge three colors one composite color see depends amount excitation red green blue phosphors white gray area result activating three dots equal intensity yellow pro duced green red dots magenta produced blue red dots cyan shows blue green activated equally low cost systems electron beam set limiting displavs eight colors sophisticated systems set intermediate intensity levels electron beams allowing several million different colors generated color graphics systems designed used several types crt display devices inexpensive home computer systems video games designed use color tv set rf radio frequency mod ulator purpose rf dulator simulate signal broad cast tv station means color intensity information picture must combined superimposed broadcast frequency carrier signal tv needs input circuitry tv takes signal rf modulator extracts picture information paints screen might expect extra handling picture information rf modulator tv circuitry decreases quality displayed images composite monitors adaptations tv sets allow bypass broadcast circuitry display devices still require picture informa tion combined carrier signal needed picture information com bined composite signal separated monitor resulting picture quality still best attainable color crts graphics systems designed rgb monitors mon itors use shadow mask methods take intensity level electron gun red green blue directly computer system without intermedi ate processing high quality raster graphics systems bits per pixel frame buffer allowing voltage settings electron gun nearly million color choices pixel rgb color system bits storage per pixel generally referred full color system true color system direct view storage tubes alternative method maintaining screen image store picture formation inside crt instead refreshing screen direct view storage tube dvst stores picture information charge distribution behind phosphor coated screen two electron guns used dvst one pri mary gun used store picture pattern second flood gun main tains picture display dvst monitor disadvantages advantages compared refresh crt refreshing needed complex pictures dis played high resolutions without flicker disadvantages dvst systems ordinarily display color selected parts picture erased eliminate picture section entire screen must erased modified picture redrawn erasing redrawing process take several seconds complex picture reasons storage displays largely replaced raster systems flat panel displays although graphics monitors still constructed crts technolo gies emerging may soon replace crt monitors term flat panel dis play refers class video devices reduced volume weight power requirements compared crt significant feature flat panel dis plays thinner crts hang walls wear wrists since even write flat panel displays soon available pocket notepads current uses flat panel displays clude small tv monitors calculators pocket video games laptop computers armrest viewing movies airlines advertisement boards elevators graphics displays applications requiring rugged portable monitors separate flat panel displays two categories emissive displays nonemissive displays emissive displays emitters devices convert electrical energy light plasma panels thin film electroluminescent displays light emitting diodes examples emissive displays flat crts also devised electron beams accelerated parallel screen deflected screen flat crts proved successful emissive devices nonemmissive displays nonemitters use optical effects convert sunlight light source graph ics patterns important example nonemissive flat panel display liquid crystal device plasma panels also called gas discharge displays constructed fill ing region two glass plates mixture gases usually section video display devices glass plate cludes neon series vertical conducting ribbons placed one glass panel sect horizontal ribbons built glass panel firing voltages applied pair horizontal vertical conductors cause gas intersection two conductors break glowing plasma electrons ions picture definition stored refresh buffer firing voltages applied refresh pixel positions intersections con ductors times per second alternating current methods used provide faster application firing voltages thus brighter displays separation pixels provided electric field conductors shows high definition plasma panel one disadvantage plasma panels strictly monochromatic devices systems de veloped capable displaying color grayscale thin film electroluminescent displays similar construction plasma panel difference region glass plates filled phosphor zinc sulfide doped manganese instead gas sufficiently high voltage applied pair crossing elec trodes phosphor becomes conductor area intersection two electrodes electrical energy absorbed manganese atoms release energy spot light similar glowing plasma ef fect plasma panel electroluminescent displays require power plasma panels good color gray scale displays hard achieve third type emissive device light emitting diode led matrix diodes arranged form pixel positions display picture defin ition stored refresh buffer scan line refreshing crt information basic design plasma panel plasma panel display display device resolution screen diagonal meters courtesy photonics systems conductors glass plate glass plate phosphor basic design thin film electroluminescent display device read refresh buffer converted voltage levels applied diodes produce light patterns display liquid crystal displays lcds commonly used small systems calculators portable laptop computers non emissive devices produce picture passing polarized light surround ings internal light source liquid crystal material aligned either block transmit light term liquid crystal refers fact compounds crys talline arrangement molecules yet flow like liquid flat panel displays commonly use nematic threadlike liquid crystal compounds tend keep long axes rod shaped molecules aligned flat panel display constructed nematic liquid crystal demonstrated two glass plates containing light polarizer right angles plate sandwich liquid crystal material rows horizontal transparent conductors built one glass plate columns vertical conductors put plate intersection uf two conductors defines pixel position mally molecules aligned shown state polarized light passing material twisted pass op posite polarizer light reflected back viewer tum pixel apply voltage two intersecting conductors align mole cules light twisted type flat panel device referred passive matrix lcd picture definitions stored refresh buffer screen refreshed rate frames per second emissive devices back lighting also commonly applied using solid state electronic devices system completely dependent outside light sources colors displayed using different materials dyes placing triad color pixels screen location another method constructing lcds place transistor pixel location using thin film transistor technology tran sistors used control voltage pixel locations prevent charge gradually leaking liquid crystal cells devices called active matrix displays section video display devices hand calculator lcd screen courtesy texas instruments backlit passive matrix liquid crystal display laptop computer featuring colors screen resolution screen diagonal inches courtesy apple computer inc polarizer state aon light twisting shutter effect used design liquid crystal display devices three dimensianal viewing devices section video display devices graphics monitors display three dimensional scenes devised using technique reflects crt image vibrating flexible mirror operation system demonstrated varifocal mirror vibrates changes focal length vibrations synchronized dis play object crt point object reflected mirror spatial position corresponding distance point specified viewing position allows us walk around object scene view different sides shows genisco spacegraph system uses vibrating mirror project three dimensional objects cm cm cm vol ume system also capable displaying two dimensional cross sectional slices objects selected different depths systems used medical applications analyze data ultrasonography cat scan de vices geological applications analyze topological seismic data de sign applications involving solid objects three dimensional simulations systems molecules terrain projected e image timing control system z vibrating flexible mirror f f f f f viewer peration three dimensional display system using vibrating mirror changes focal length match depth points scene spacegraph interactive graphics system displays objects three dimensions using vibrating flexible mirror courtesy genisco computers corporation chapter2 stereoscopic virtual reality systems overvi f ics erview graphics systems another technique representing three dimensional objects displaying stereoscopic views method produce true three dimensional im ages provide three dimensional effect presenting different view eye observer scenes appear depth obtain stereoscopic projection first need obtain two views scene generated viewing direction corresponding eye left tight constrict two views computer generated scenes differ ent viewing positions use stereo camera pair photograph object scene simultaneous look left view left eye right view right eye two views merge single image perceive scene depth shows two views computer generated scene stereographic projection increase viewing comfort areas left right edges scene visible one eye eliminated viewing stereoscopic projection courtesy stereog raphics corporation eve co right stereoscopic viewing pair courtesy jerry farm one way produce stereoscopic effect display two views raster system alternate refresh cycles screen viewed glasses lens designed act rapidly alternating shutter syn chronized block one views shows pair stereoscopic glasses constructed liquid crystal shutters infrared emitter syn chronizes glasses views screen stereoscopic viewing also component virtual reality systems users step scene interact environment headset containing optical system generate stereoscopic views commonly used conjuction interactive input devices locate manip ulate objects scene sensing system headset keeps track viewer position front back objects seen viewer glasses viewing stereoscopic scene infrared synchronizing emitter courtesy stereographics corporation headset used virtual reality systems courtesy virtual research section video display devices interacting virtual reality environment courtesy national center supercomputing applications university mlinois urbana champaign walks interacts display illustrates interaction virtua scene using headset data glove worn right hand section interactive virtual reality environment also viewed stereo scopic glasses video monitor instead headset provides means obtaining lower cost virtual reality system example shows ultrasound tracking device six degrees freedom tracking device placed top video display used monitor head movements viewing position scene changed head position changes ultrasound tracking device used stereoscopic glasses track head position courtesy stereographics corporation interactive raster graphics systems typically employ several processing units addition central processing unit cpu special purpose processor called video controller display controller used control operation display device organization simple raster system shown frame buffer anywhere system memory video controller accesses frame buffer refresh screen addition video controller sophisticated raster systems employ processors co processors accelerators implement various graphics operations video controller shows commonly used organization raster systems fixed area system memory reserved frame buffer video controller given direct access frame buffer memory frame buffer locations corresponding screen positions refer enced cartesian coordinates many graphics monitors coordinate ori vo devices architecture simple raster graphics system architecture raster system fixed portion system memory reserved frame buffer section raster scan systems origin coordinate system identifying screen positions usually specified lower left corner gin defined lower left screen corner screen surface represented first quadrant two dimensional system positive x values increasing right positive values increasing bottom top personal computers coordinate origin referenced upper left corner screen values inverted scan lines labeled ym top screen bottom along scan line screen pixel positions labeled x ux basic refresh operations video controller dia grammed two registers used store coordinates screen pixels ini tially x register set register set yq value stored frame buffer pixel position retrieved used set inten sity crt beam x register incremented process peated next pixel top scan line procedure repeated pixel along scan line last pixel top scam line processed x register reset register decremented pixels along scan line processed turn procedure repeated successive scan line cycling pixels along bottom scan line video controller resets registers first pixel position top scan line refresh process starts since screen must refreshed rate frames per second simple procedure illustrated accommodated typical ram chips cycle time slow speed pixel processing video con trollers retrieve multiple pixel values refresh buffer pass multiple pixel intensities stored separate register used control crt beam intensity group adjacent pixels group pixels processed next block pixel values retrieved frarne buffer number operations performed video controller sides basic refreshing operations various applications video con honzontal ana de variical deflection voltages basic video controller refresh operations processor memory system bus devices architecture raster graphics system display processor troller retrieve pixel intensities different memory areas different fresh cycles high quality systems example two frame buffers often provided one buffer used refreshing filled intensity values two buffers switch roles provides fast mechanism generating real time animations since different views moving objects successively loaded refresh buffers also transformations accomplished video controller areas screen enlarged reduced moved one location another fresh cycles addition video controller often contains lookup table pixel values frame buffer used access lookup table instead controlling crt beam intensity directly provides fast method changing screen intensity values discuss lookup tables detail ir chapter finally systems designed allow video controller mix frame buffer image input image television camera input device raster scan display processor shows one way set organization raster system contain ing separate display processor sometimes referred graphics controller display coprocessor purpose display processor free cpu graphics chores addition system memory separate display processor memory area also provided major task display processor digitizing picture definition given application program set pixel intensity values storage frame buffer digitization process called scan conversion graphics com mands specifying straight lines geometric objects scan converted set discrete intensity points scan converting straight line segment example means locate pixel positions closest line path store intensity position frame buffer similar methods used scan converting curved lines polygon outlines characters defined rectangular grids defined curved character defined rectangular grid pixel positions c character defined curve outline outlines array size character grids vary higher quality displays character grid displayed superimposing rectangular grid pattern frame buffer specified coordinate position characters defined curve outlines character shapes scan converted frame buffer display processors also designed perform number additional op erations functions include generating various line styles dashed dotted solid displaying color areas performing certain transformations nipulations displayed objects also display processors typically designed interface interactive input devices mouse effort reduce memory requirements raster systems methods devised organizing frame buffer linked list encoding intensity information one way store scan line set integer pairs one number pair indicates intensity value sec ond number specifies number adjacent pixels scan line intensity technique called min length encoding result considerable saving storage space picture constructed mostly long runs single color similar approach taken pixel tensities change linearly another approach encode raster set rec tangular areas cell encoding disadvantages encoding runs tensity changes difficult make storage requirements actually increase length runs decreases addition difficult display con troller process raster many short runs involved organization simple random scan vector systern shown application program input stored system memory along graphics package graphics commands application program translated graphics package display file stored system memory dis play file accessed display processor refresh screen dis play processor cycles command display file program every refresh cycle sometimes display processor random scan system referred display processing unit graphics controller vo devices architecture simple random scan system graphics patterns drawn random scan system directing electron beam along component lines picture lines defined values coordinate endpoints input coordinate values con verted x deflection voltages scene drawn one line time positioning beam fill line specified endpoints graphics monitors today operate raster scan displays sur vey many graphics hardware configurations available graphics sys tems range small general purpose computer systems graphics capabil ities sophisticated full color systems designed specifically graphics applications typical screen resolution personal com desktop general purpose computer system used graphics applications courtesy apple computer inc section graphics monilors workstations computer graphics workstations keyboard mouse input devices iris indigo courtesy siticon graphics corporation b sparcstation courtesy sun microsystems puter systems apple quadra shown al though screen resolution system capabilities vary depending size cost system diagonal screen dimensions general purpose per sonal computer systems range inches allowable color se lections range 000 workstations specifically designed graphics applications systems shown typical screen reso lution screen diagonal inches graphics workstations configured bits per pixel full color sys tems higher screen resolutions faster processors options avail able high end systems shows high definition graphics monitor used applications air traffic control simulation medical imaging cad system diagonal screen size inches resolutions ranging refresh rates hz hz noninterlaced multiscreen system called mediawall shown provides large wall sized display area system designed applications quire large area displays brightly lighted environments trade shows conventions retail stores museums passenger terminals mediawall operates splitting images number sections distributing sec tions array monitors projectors using graphics adapter satel lite control units array monitors resolution used mediawall provide overall resolution either static scenes animations scenes displayed behind mul lions mullions eliminated display continuous picture breaks various sections many graphics workstations shown configured two monitors one monitor used show features object scene second monitor displays detail part picture another use dual monitor systems view picture one monitor display graphics options menus manipulating picture com ponents monitor high resolution color monitor courtesy barco chromatics mediawall multiscreen display system image displayed array monitors created deneba software courtesy rgb spectrum single dual monitor graphics workstations courtesy intergraph corporation figures 38 39 illustrate examples interactive graphics worksta tions containing multiple input devices typical setup cad appli cations shown various keyboards button boxes tablets mice attached video monitors use design process shows features types artist workstations multiple workstations cad group courtesy hewlett packard company artisl workstation featuring color raster monitor keyboard graphics tablet hand cursor light table addition data storage telecommunications devices courtesy dicomed corporation various devices available data input graphics workstations sys tems keyboard one additional devices specially designed interactive input include mouse trackball spaceball joystick digitizers dials button boxes input devices usea particular applications data gloves touch panels image scanners voice systems keyboards alphanumeric keyboard graphics system used primarily device entering text strings keyboard efficient device inputting nongraphic data picture labels associated graphics display keyboards also provided features facilitate entry screen coordinates menu selections graphics functions cursor contro keys function keys common features general purpose keyboards function keys allow users enter frequently used opera tions single keystroke cursor control keys used select dis played objects coordinate positions positioning screen cursor types cursor positioning devices trackball joystick included keyboards additionally numeric keypad often included key board fast entry numeric data typical examples general purpose key boards given figs 33 34 shows ergonomic keyboard design specialized applications input graphics application may come set buttons dials switches select data values customized graphics operations gives example button box set input dials buttons switches often used input predefined functions dials common devices entering scalar values real numbers within defined range selected input dial rotations potentiometers used mea sure dial rotations converted deflection voltages cursor movement mouse mouse small hand held box used position screen cursor wheels rollers bottom mouse used record amount direc ergonomically designed keyboard removable palm rests slope half keyboard adjusted separately courtesy apple computer inc section input devices tion movement another method detecting mouse motion opti cal sensor systems mouse moved special mouse pad grid horizontal vertical lines optical sensor detects movement across lines grid since mouse picked put another position without change cursor movement used making relative changes position screen cursor one two three buttons usually included top mouse signaling execution operation recording cur sor position invoking function general purpose graphics systems include mouse keyboard major input devices figs 33 34 additional devices included basic mouse design increase number allowable input parameters z mouse includes button box set input dials b courtesy vector general z mouse features three buttons mouse ball underneath thumbwheel side trackball top courtesy multipoint technology corporation three buttons thumbwheel side trackball top standard mouse ball underneath design provides six degrees freedom select spatial positions rotations parameters z mouse pick object rotate move direction navigate view ing position orientation three dimensional scene applications z mouse include virtual reality cad animation trackball spacebail name implies trackball ball rotated fingers palm hand produce screen cursor movement poten tiometers attached ball measure amount direction rotation trackballs often mounted keyboards devices z mouse trackball two dimensional positioning device spaceball fig 45 provides six degrees freedom unlike trackball spaceball actually move strain gauges measure amount pressure applied spaceball provide input spatial positioning orientation ball pushed pulled various directions spaceballs used three dimensional positioning selection operations virtual reality systems modeling anima tion cad applications joysticks joystick consists small vertical lever called stick mounted base used steer screen cursor around joysticks select screen posi tions actual stick movement others respond pressure stick figure 44 shows movable joystick joysticks mounted keyboard oth ers function stand alone units distance stick moved direction center position corresponds screen cursor movement direction potentiometers mounted base joystick measure amount movement springs return stick center position released one buttons programmed act input switches signal certain actions screen position selected three button track ball courtesy measurement systems inc norwalk connecticut section input devices chapter overview graphics systems moveable joystick courtesy calcomp group sanders associates inc another type movable joystick stick used activate switches cause screen cursor move constant rate direction selected eight switches arranged circle sometimes provided stick select one eight directions cursor movement pressurg sensitive joy sticks also called isometric joysticks nonmovable stick pressure stick measured strain gauges converted movement cursor direction specified data glove shows data glove used grasp virtual object glove constructed series sensors detect hand finger motions electromagnetic coupling transmitting antennas receiving antennas used provide information position orientation hand transmitting receiving antennas structured set three mutually perpendicular coils forming three dimensional cartesian coordinate system input glove used position manipulate objects virtual scene two dimensional projection scene viewed video monitor three dimensional projection viewed headset digitizers common device drawing painting interactively selecting coordinate po sitions object digitizer devices used input coordinate values either two dimensional three dimensional space typically dig itizer used scan drawing object input set discrete coor dinate positions joined straight line segments approximate curve surface shapes one type digitizer graphics tablet also referred data tablet used input two dimensional coordinates activating hand cursor stylus selected positions flat surface hand cursor contains cross hairs sighting positions stylus pencil shaped device pointed virtual reality scene displayed two dimensional video monitor input data glove spaceball courtesy computer graphics center darmstadt germany positions tablet figures 46 47 show examples desktop floor model tablets using hand cursors available buttons examples stylus input tablet shown figs 48 49 artist digitizing system uses electromagnetic resonance detect three dimensional position stylus allows artist produce different brush strokes different pressures tablet surface tablet size varies inches desktop models inches larger floor models graphics tablets provide highly accurate method selecting coordi nate positions accuracy varies mm desktop mod els 05 mm less larger models many graphics tablets constructed rectangular grid wires em bedded tablet surface electromagnetic pulses generated sequence ae summasketch iii desktop tablet button hand cursor courtesy summagraphics corporation section input devices notepad desktop tablet stylus courtesy calcomp digitizer division part calcomp inc microgrid tablet button hand cursor designed digitizing larger drawings courtesy summagraphics corporation along wires electric signal induced wire coil activated sty lus hand cursor record tablet position depending technology ei ther signal strength coded pulses phase shifts used determine position tablet acoustic sonic tablets use sound waves detect stylus position ei ther strip microphones point microphones used detect sound emitted electrical spark stylus tip position stylus calcu artist digitizer system pressure sensitive cordless stylus courtesy wacom technology corporation lated timing arrival generated sound different microphone positions advantage two dimensional accoustic tablets micro phones placed surface form tablet work area convenient various applications digitizing drawings book three dimensional digitizers use sonic electromagnetic transmissions record positions one electromagnetic transmission method similar used data glove coupling transmitter receiver used compute location stylus moves surface object fig ure 50 shows three dimensional digitizer designed apple macintosh com puters points selected nonmetallic object wireframe outline surface displayed computer screen surface outline con structed shaded lighting effects produce realistic display object resolution system mm 08 mm depending model image scanners drawings graphs color black white photos text stored computer processing image scanner passing optical scanning mechanism information stored gradations gray scale color recorded stored array internal repre sentation picture apply transformations rotate scale crop picture particular screen area also apply various image processing methods modify array representation picture scanned text input various editing operations performed stored documents scanners able scan either graphical representations text come variety sizes capabilities small hand model scanner shown 53 show larger models three dimensional digitizing system use apple macintosh computers courtesy mira imaging section input devices hand held scanner used input either text graphics images courtesy thunderware inc desktop full color scanners flatbed scanner resolution dots per inch courtesy sharp electronics corporation b drum scanner selectable resolution dots per inch courtesy howtek inc touch panels name implies touch panels allow displayed objects screen positions selected touch finger typical application touch panels selection processing options represented graphical icons systems plasma panels shown designed touch screens systems adapted touch input fitting transpar ent device touch sensing mechanism video monitor screen touch input recorded using optical electrical acoustical methods optical touch panels employ line infrared light emitting diodes leds along one vertical edge along one horizontal edge frame opposite vertical horizontal edges contain light detectors detectors used record beams interrupted panel touched two crossing large floor model scanner used scan architectural engineering drawings inches wide feet long courtesy summagraphics corporation beams interrupted identify horizontal vertical coordinates screen position selected positions selected accuracy inch closely spaced leds possible break two horizontal two ver tical beams simultaneously case average position two terrupted beams recorded leds operate infrared frequencies light visible user illustrates arrangement leds optical touch panel designed match color contours system fitted electrical touch panel constructed two transparent plates sepa rated smal distance one plates coated conducting material plate coated resistive material outer plate touched forced contact inner plate contact creates volt age drop across resistive plate converted coordinate values selected screen position acoustical touch panels high frequency sound waves generated horizontal vertical directions across glass plate touching screen causes part wave reflected finger emitters screen position point contact calculated measurement time terval transmission wave reflection emitter plasma panels touch screens courtesy photonics systems section input devices chapter overview graphics systems optical touch panel showing arrangement infrared led units detectors around edges frame courtesy carroll touch inc light pens shows design one type light pen pencil shaped de vices used select screen positions detecting light coming points crt screen sensitive short burst light emitted phosphor coating instant electron beam strikes particular point light sources background light room usually detected light pen activated light pen pointed spot screen elec tron beam lights spot generates electrical pulse causes coordi nate position electron beam recorded cursor positioning de vices recorded light pen coordinates used position object select processing option although light pens still us popular since several disadvantages compared input devices developed one light pen pointed screen part screen image obscured hand pen prolonged use light pen cause arm fatigue also light pens require special implementations applications detect positions within black areas able select positions screen area light pen must nonzero intensity assigned screen pixel addition light pens sometimes give false readings due background lighting room voice systems speech recognizers used graphics workstations input devices accept voice commands voice system input used initiate graphics light pen activated button switch courtesy interactive computer products operations enter data systems operate matching input predefined dictionary words phrases dictionary set particular operator operator speak command words used system word spoken several times system analyzes word establishes frequency pattern word dictionary along corresponding function per formed later voice command given system searches dictio nary frequency pattern match voice input typically spoken micro phone mounted headset microphone designed minimize input background sounds different operator use system dictionary must reestablished operator voice patterns voice systems advantage input devices since attention operator switched one device another enter command speech recognition system courtesy threshold technology inc section input devices chapter overview graphics systems hard copy devices obtain hard copy output images several formats presenta tions archiving send image files devices service bureaus produce mm slides overhead transparencies put images film simply photograph scene displayed video monitor put pictures paper directing graphics output printer plotter quality pictures obtained device depends dot size number dots per inch lines per inch displayed produce smooth characters printed text strings higher quality printers shift dot posi tions adjacent dots overlap printers produce output either impact nonimpact methods impact printers press formed character faces inked ribbon onto paper line printer example impact device typefaces mounted bands chains drums wheels nonimpact printers plotters use laser tech niques ink jet sprays xerographic processes used photocopying chines electrostatic methods electrothermal methods get images onto paper character impact printers often dot matrix print head containing rectangular array protruding wire pins number pins depending quality printer individual characters graphics patterns obtained retracting certain pins remaining pins form pattern printed shows picture printed dot matrix printer laser device laser beam creates charge distribution rotating drum coated photoelectric material selenium toner applied drum transferred ta paper shows examples desktop laser printers resolution dots per inch ink jet methods produce output squirting ink horizontal rows across roll paper wrapped drum electrically charged ink stream deflected electric field produce dot matrix patterns desktop ink jet plotter picture generated dot matrix printer showing density dot patterns varied produce light dark areas courtesy apple computer inc small footprint laser printers courtesy texas instruments resolution dots per inch shown examples larger high resolution ink jet printer plotters shown electrostatic device places negative charge paper one complete tow time along length paper paper exposed toner toner positively charged attracted negatively charged areas adheres produce specified output color electrostatic printer plotter shown electrothermal methods use heat dot matrix print head output patterns heat sensitive paper get limited color output impact printer using different colored ribbons nonimpact devices use various techniques combine three color pigments cyan magenta yellow produce range color patterns laser xerographic devices deposit three pigments separate passes ink jet methods shoot three colors simultaneously single pass along print line paper dot per inch desktop ink jet plotter courtesy summagraphics corporation section hard copy devices lal ib floor model ink jet color printers use variable dot size achieve equivalent resolution dots per inch courtesy iris graphics inc bedford massachusetts electrostatic printer display dots per inch courtesy calcomp digitizer division part calcomp inc drafting layouts drawings typically generated ink jet pen plotters pen plotter one pens mounted carriage cross bar spans sheet paper pens varying colors widths used produce variety shadings line styles wet ink ball point felt tip pens possible choices use pen plotter plotter paper lie flat rolled onto drum belt crossbars either moveable stationary pen moves back forth along bar either clamps vacuum electrostatic charge hold paper position example table top flatbed pen plotter given larger rollfeed pen plotter shown desktop pen plotter resolution 025 mum courtesy summagraphies corporation large rollfeed pen plotter automatic multicolor pen changer resolution 0127 mm courtesy summagraphics corporation two general classifications graphics software general programming packages special purpose applications packages general graphics pro gramming package provides extensive set graphics functions section graphics software used high level programming language c fortran exam ple general graphics programming package gl graphics library sys tem silicon graphics equipment basic functions general package include generating picture components straight lines polygons circles figures setting color intensity values selecting views applying transformations contrast application graphics packages designed nonprogrammers users generate displays without worrying graphics operations work interface graphics routines packages allows users communicate programs terms ex amples applications packages artist painting programs vari ous business medical cad systems coordinate representations exceptions general graphics packages designed used cartesian coordinate specifications coordinate values picture speci fied reference frame spherical hyberbolic etc must con verted cartesian coordinates input graphics package special purpose packages may allow use coordinate frames ap propriate application general several different cartesian reference frames used construct display scene construct shape individual objects trees furniture scene within separate coordi nate reference frames called modeling coordinates sometimes local coordi nates master coordinates individual object shapes specified place objects appropriate positions within scene using refer ence frame called world coordinates finally world coordinate description scene transferred one output device reference frames dis play display coordinate systems referred device coordinates screen coordinates case video monitor modeling world coordinate definitions allow us set convenient floating point integer di mensions without hampered constraints particular output de vice scenes might want specify object dimensions fractions foot applications might want use millimeters kilometers light years generally graphics system first converts world coordinate positions normalized device coordinates range final conversion specific device coordinates makes system independent various devices might used particular workstation illustrates sequence coordinate transformations modeling coordinates device co ordinates two dimensional application initial modeling coordinate po sition nc ya illustration transferred device coordinate position xtc yac sequence mer yc laver yrs pcr yc aatcr ye modeling world coordinate positions transformation anv floating point values normalized coordinates satisfy inequalities x device coordinates x integers within range xmaxr youx particular output device accommodate differences scales aspect ratios normalized coordinates mapped square area output device proper proportions maintained graphics functions section graphics software general purpose graphics package provides users variety functions creating manipulating pictures routines categorized accord ing whether deal output input attributes transformations viewing general control basic building blocks pictures referred output primitives include character strings geometric entities points straight lines curved lines filled areas polygons circles etc shapes defined arrays color points routines generating output primitives provide basic tools constructing pictures attributes properties output primitives attribute describes particular primitive displayed include intensity color specifications line styles text styles area filling patterns func tions within category used set attributes individual primitive class groups output primitives change size position orientation object within scene using geometric transformations similar modeling transformations used construct scene using object descriptions given modeling coordinates given primitive attribute definition picture world coordi nates graphics package projects selected view picture output de vice viewing transformations used specify view pre sented portion output display area used pictures subdivided component parts called structures seg ments objects depending software package use structure de fines one logical unit picture scene several objects could reference individual object separate named structure routines processing pose sl video monitor sy modeling jhe rs ransformations ae ed world nort coordinates coordinates output device coordinates transformation sequence modeling coordinates device coordinates two dimensional scene object shapes defined local modeling coordipate systems positioned within overall world coordinate scene world coordinate specifications transformed normalized coordinates final step individual device drivers wansier normalized coordinate representation scene output devices isplay chapter overview graphics systems structures carry operations creation modification transfor mation structures interactive graphics applications use various kinds input devices mouse tablet joystick input functions used tu control process data flow interactive devices finally graphics package contains number housekeeping tasks clearing display screen initializing parameters jump func tions carrving hese chores heading control operations sottware standards primary goal standardized graphics software portability pack ages designed tandard graphics functions software moved cas ily one hardware system another used different implementations applications without standards programs designed one hardware sys tem often transferred another system without extensive rewnting programs international national standards planning organizations many coun tries cooperated effort develop generally accepted standard computer graphics considerable effort work standards led development graphical kernel system gks system adupted first graphics software standard international standards organiza tion various national standards organizations including ameri national standards institute ansi although gks originally designed two dimensional graphics package three dimensional gks extension subsequently developed second software standard developed ap proved standards orgainzations phigs programmer hierarchical interactive graphics standard extension gks increased capabil ities object modeling color specifications surface rendering picture nipulations provided phigs subsequently extension phigs called phigs developed provide three dimensional surface shading capabili ties available phics standard graphics tunctions defined set specifications dependent anv progr mming language language binding defined particular high level programming language binding gives svntax accessing various standard graphics functions language ex ample general form phigs gks function specifying se quence n connected two dimensional straight line segments pelylirein x fortran procec ure implemented subroutine name gpl graphics programmer using fortran would invoke procedure subroutine call statement call gpl n x one dimensional arrays coordinate values line endpoints c proce dure would invoked ppclyline n pts pts list co ordinate endpoint positicns language binding defined make best use corresponding language capabilities handle various syntax issues data types parameter passing errors following chapters use standard functions defined phigs framework discussing basic graphics concepts design appli cation graphics packayes example programs presented pascal illus trate algorithms implementation graphics functions illustrate also applications functions descriptive names functions based phigs definitions used whenever graphics function referenced program although phigs presents specification basic graphics functions provide standard methodology graphics interface output de vices specify methods storing transmitting pictures separate standards developed areas standardization device inter face methods given computer graphics interface cgi system computer graphics metafile cgm system specifies standards archiv ing transporting pictures phigs workstations generally term workstation refers computer system combination input output devices designed single user phigs gks however term workstation used identify various combinations graphics hardware software phigs workstation single output device single input device combination input output devices file even window displayed ona video monitor define use various workstations within applications program need specify workstation identifier workstation type following statements give general structure phigs program openphigs errorfile memorysize openworkstation ws connection type create display picture closeworkstation ws closepnigs parameter errorfile contain error messages gener ated parameter memorysize specifies size internal storage area workstation identifier integer given parameter ws parameter connection states access mechanism workstation parameter type specifies particular category workstation input device output device combination outin device input output metafile number workstations open particular application input coming various open input devices output directed open output devices discuss input output methods applications pro grams chapter explored basic procedures creating manipulating pictures summary chapter surveyed major hardware software features computer graphics systems hardware components include video monitors hard copy devices keyboards devices graphics input output graphics software includes special applications packages general program ming packages predominant graphics display device raster refresh monitor based television technology raster system uses frame buffer store inten sity information screen position pixel pictures painted summary chapters overview graphics systems screen retrieving information frame buffer electron beam crt sweeps across scan line top bottom older vector dis plays construct pictures drawing lines specified line endpoints pic ture information stored asa set line drawing instructions many video display devices available particular flat panel dis play technology developing rapid rate devices may largely place raster displays near future present flat panel displays com monly used small systems special purpose systems flat panel displays include plasma panels liquid crystal devices although vector monitors used display high quality line drawings improvements raster display technology caused vector monitors largely replaced raster sys tems display technologies include three dimensional stereoscopic viewing systems virtual reality systems include either stereoscopic head set standard video monitor graphical input range devices choose keyboards button boxes dials used input text data values programming op tions popular pointing device mouse trackballs space balls joysticks cursor control keys thumbwheels also used position screen cursor virtual reality environments data gloves commonly used input devices include image scanners digitizers touch panels light pens vaice systems hard copy devices graphics workstations include standard printers plotters addition devices producing slides transparencies film put printing methods include dot matrix laser ink jet electrostatic elec trothermal plotter methods include pen plotting combination printer plotter devices graphics software roughly classified applications packages programming packages applications graphics software include cad packages drawing painting programs graphing packages visualization pro grams common graphics programming packages include phigs phigs gks 3d gks gl software standards phigs gks cgl cgm evolving becoming widely available variety machines normally graphics packages require coordinate specifications given respect cartesian reference frames object scene defined separate modeling cartesian coordinate system mapped world coordinates construct scene world coordinates objects transferred normalized device coordinates final display device co ordinates transformations modeling coordinates normalized device coordinates independent particular devices might used appli cation device drivers used convert normalized coordinates integer device coordinates functions graphics programming packages divided fol lowing categories output primitives attributes geometric modeling trans formations viewing transformations structure operations input functions control operations graphics systems phigs gks use concept workstation specify devices software used input put particular application workstation identifier systems refer file single device raster monitor combination devices monitor keyboard mouse multiple workstations open provide input receive output graphics application references general treatment electronic displays including flat panel devices available sherr flat panel devices discussed depp howard tannas pro vides reference flat panel displays crts additional information raster graphics architecture found foley et al three dimensional terminals discussed fuchs et al johnson ikedo head mounted dis plays virtual reality environments discussed chung et al information phigs phigs see hopgood duce howard et al gaskins blake information two dimensional gks stan dard evolution graphics standards available hopgood et al additional reference gks enderle kansy pfaff exercises list operating characteristics following display technologies raster refresh systems vecter refresh systems plasma panels cds list applications appropriate display technologies exercise determine resolution pixels per centimeter x directions video monitor use system determine aspect ratio explain relative proportions objects maintained svsiem consider three different raster systems resolutrons size frame buffer bytes needed sys tems store bits per pixel much storage required system bits per pixel stored suppose rgb raster system designed using inch inch screen resolution pixels per inch direction want store bits per pixel frame buffer much storage bytes need frame buffer long would take load frame buffer bits per pixel bits transferred per second long would take load bit per pixel frame buffer resolution 24 using transfer rate suppose computer bits per word transfer rate mip one million instructions per second long would take fill frame buffer dpi dot per inch laser printer page size vf inches inches consider two raster systems resolutions many pixels could accessed per second systems display con troller refreshes screen al rate frames per second whal access time per pixel ach system nn wo suppose video monitor display area measures inches across inches high resolution aspect ratio 1s diameter screen point 10 much lime spent scanning across row pixels screen refresh raster system resolution refresh rate frames per second 11 consider noninterlaced raster monitor resolution ay scan lines n pixels per scan line refresh rate frames per secand horizontal retrace time thong vertical retrace time fraction total refresh time per frame spent retrace elect beany 12 fraction total refresh time per irame spent retrace electron beam noninterlaced raster system cesolution refresh rate hz horizontal retrace time microseconds vertical retrace time microseconds exercises b2 13 16 17 18 assuming certain full color bit per pixel rgb raster system frame buffer many distinct color choices intensity levels would available many different colors could display one time compare advantages disadvantages three dimensional monito using varifocal mirror stereoscopic system list different input output components typically used virtual teality systems also explain users interact virtual scene displayed dif ferent output devices two dimensional stereoscopic monitors explain virtual reality systems used design applications applications virtual reality systems list applications large screen displays explain differences general graphics system designed programmer one designed specific application architectural design chapter output primitives af picture described several ways assuming raster dis play picture completely specified set intensities pixel positions display extreme describe picture set complex objects trees terrain furniture walls positioned specified coordinate locations within scene shapes colors objects described internally pixel arrays sets basic geometric struc tures straight line segments polygon color areas scene displayed either loading pixel arrays frame buffer scan con verting basic geometric structure specifications pixel patterns typically graphics programming packages provide functions describe scene terms basic geometric structures referred output primitives group sets output primitives complex structures output primi tive specified input coordinate data information way abject displayed points straight line segments simplest geometric components pictures additional output primitives used construct picture include circles conic sections quadric surfaces spline curves surfaces polygon color areas character strings begin discussion picture generation procedures examining device level algo rithms displaying two dimensional output primitives particular empha sis scan conversion methods raster graphics systems chapter also consider output functions provided graphics packages take look output functions available phigs language point plotting accomplished converting single coordinate position fur nished application program appropriate operations output de vice use crt monitor example electron beam turned il luminate screen phosphor selected location electron beam positioned depends display technology random scan vector system stures point plotting instructions display list coordinate values instructions converted deflection voltages position electron beam screen locations plotted refresh cycle black white raster system hand point plotted setting bit value corresponding specified screen position within frame buffer electron beam sweeps across horizontal scan line emits burst electrons plots point whenever value encountered frame buffer rgb system frame buffer loaded color codes intensities displayed screen pixel positions line drawing accomplished calculating intermediate positions along line path two specified endpoint positions output device directed fill positions endpoints analog devices vector pen plotter random scan display straight line drawn smoothly one endpoint linearly varying horizontal verti cal deflection voltages generated proportional required changes x directions produce smooth line digital devices display straight line segment plotting discrete points two endpoints discrete coordinate positions along line path calculated equation line raster video display line color intensity loaded frame buffer corresponding pixel coordi nates reading frame buffer video controller plots screen pixels screen locations referenced integer values plotted positions may approximate actual line positions two specified endpoints computed line position 48 51 example would converted pixel position rounding coordinate values integers causes lines displayed stairstep appearance jaggies represented fig characteristic stairstep shape raster lines particularly noticeable sys tems low resolution improve appearance somewhat displaying high resolution systems effective techniques smoothing raster lines based adjusting pixel intensities along line paths raster graphics device level algorithms discussed chapter ob ject positions specified directly integer device coordinates time assume pixel positions referenced according scan line number column number pixel position across scan line addressing scheme illustrated scan lines numbered consecutively starting bottom screen pixel columns numbered left right across scan line section 10 consider alternative pixel ad dressing schemes load specified color frame buffer position corresponding column x along scan line assume available low level pro cedure form setpixel x stairstep effect jaggies produced line generated series pixel positions sectian points lines x x line path endpoint positions x x2 scan line number pixel column pixel positions referenced scan number line number column number sometimes also want able retrieve current frame buffer intensity setting specified location accomplish low level function getpixel x line drawing algorithms cartesian slope intercept equation straight line x b representing slope line b intercept given two endpoints line segment specified positions x xz shown determine values slope intercept b following calculations bo bey x algorithms displaying straight lines based line equation calculations given eqs given x interval ax along line compute corresponding interval ay eq ay max similarly obtain x interval ax corresponding specified ay ar equations form basis determining deflection voltages analog de vices lines slope magnitudes dx set proportional small horizontal deflection voltage corresponding vertical deflection set proportional ay calculated eq lines whose slopes magnitudes ay set proportional small vertical deflec tion voltage corresponding horizontal deflection voltage set propor tional ax calculated eq lines ax ay hori zontal vertical deflections voltages equal case smooth line slope generated specified endpoints raster systems lines plotted pixels step sizes hori zontal vertical directions constrained pixel separations must sample line discrete positions determine nearest pixel line sampled position scan conversion process straight lines il lustrated near horizontal line discrete sample positions along x axis dda algorithm digital differentia analyzer dda scan conversion line algorithm based calculating either sy ax using eq eq sample line unit tervals one coordinate determine corresponding integer values nearest line path coordinate consider first line positive slope shown slope less equal sample unit x intervals ax compute successive value yeo yet mm g subscript takes integer values starting first point increases final endpoint reached since real number calculated values must rounded nearest integer lines positive slope greater reverse roles x sample unit intervals ay calculate succeeding x value nye yt equations based assumption lines processed left endpoint right endpoint processing reversed starting endpoint right either ax lland yrry ye mt gb slope greater ay xpay myo equations also used calculate pixel positions along line negative slope absolute value slope less start endpoint left set ax calculate values eq section line drawing algorithms straight line segment five sampling positions along x axis x x start endpoint right slope set ax obtain positions eq similarly absolute value negative slope greater use ay eq use ay eq algorithm summarized following procedure accepts input two endpoint pixel positions horizontal vertical differences tween endpoint positions assigned parameters dx dy differ ence greater magnitude determines value parameter steps start ing pixel position x determine offset needed step generate next pixel position along line path loop process steps times magnitude dx greater magnitude dy xa less xb values increments x directions respectively greater change x direction xa greater xb decrements used generate new point line otherwise use unit increment decrement direction x crement decrement include device h define round int int dx xb xa dy yb ya steps k float xincrement yincrement xa ya abs dxi abs idy steps abs dx else steps abs dy xincrement dx float steps yincrement dy float steps void linedda int xa int ya int xb int yb f setpixel round x round k k steps k x xincrement yincrement setpixel roundix round dda algorithm faster method calculating pixel positions direct use eq eliminates multiplication eq making use raster characteristics appropriate increments applied x direction step pixel positions along line path accumulation roundoff error successive additions floating point increment however cause calculated pixel positions drift away true line path long line segments furthermore rounding operations floating point arithmetic procedure inedda still time consuming improve performance dda algorithm separating increments integer fractional parts calculations reduced integer opera tions method calculating intrements integer steps discussed section 11 following sections consider general scan line proce dures applied lines curves bresenham line algorithm accurate efficient raster line generating algorithm developed bresen ham scan converts lines using incremental integer calculations adapted display circles curves figures illustrate sections display screen straight line segments drawn vertical axes show scan line positions horizontal axes identify pixel columns sampling unit x intervals examples need decide two possible pixel positions closer line path sample step starting left endpoint shown need determine next sampie position whether plot pixel position one simi larly shows negative slope line path starting left endpoint pixel position one select next pixel position questions answered bresenham line algorithm testing sign integer parameter whose value proportional differ ence separations two pixel positions actual line path illustrate bresenham approach first consider scan conversion process lines positive slope less pixel positions along line path determined sampling unit x intervals starting left end point xp yo given line step successive column x position plot pixel whose scan line value closest line path demonstrates ith step process assuming determined pixel x displayed next need decide pixel plot column x choices pixels positions x x sampling position x label vertical pixel separations mathematical line path coordinate mathemati cal line pixel column position x calculated b 10 yy b yy ye ytl difference two separations dy 2m xy 2y 11 decision parameter p kth step line algorithm ob tained rearranging eq 11 involves integer calculations ac complish substituting ay ax ay ax vertical horizontal separations endpoint positions defining p ax 2ay x 2ax yt 12 sign p sign since ax example pa rameter c constant value 2ay ax 2b independent specified line path www 13 section display screen straight line segment 1s plotted starting pixel column scan line bo specified line path 51 53 section display screen negative slope line segment plotted starting pixel column scan line yeo yeon ye mxt ps eed mevr meas section screen grid showing pixel column x scan line plotted along path line segment slope distances pixel positions line coordinate sampling position x pixel position eliminated recursive calculations p pixel closer line path pixel de cision parameter p negative case plot lower pixel otherwise plot upper pixel coordinate changes along line occur unit steps either x di rections therefore obtain values successive decision parameters using incremental integer calculations step k decision parameter evaluated eq 12 pooy 2ay xa 2axs yay tc subtracting eq 12 preceding equation pest pr 2ayoas axl yd x x s0 presi py 2ay 2zax ys1 yd 13 term either depending sign cf parameter py recursive calculation decision parameters performed inte ger x position starting left coordinate endpoint line first para meter po evaluated eq 12 starting pixel position xj yo evaluated ay ax po 2ay ax 14 summarize bresenham line drawing line positive slope less following listed steps constants 2ay 2ay 24x cal culated line scan canverted arithmetic involves integer addition subtraction two constants bresenham line drawing algorithm input two line endpoints store left endpoint xq yo load xo yo frame buffer plot first point calculate constants ax ay 24y 2ay 2ax obtain start ing value decision parameter po 24y ax x along line starting k perform following test p next point plot x yp pro py 2ay otherwise next point plot g prot py 2ay 2ax repeat step ax times example bresenham line drawing illustrate algorithm digitize line endpoints line slope initial decision parameter value po 2ay ax increments calculating successive decision parameters 2ay 2ay 2axr plot initial point x yo determine successive pixel posi tions along line path decision parameter k px opa vers k px oga1 yea 14 14 10 10 plot pixels generated along line path shown implementation bresenham line drawing slopes range given following procedure endpoint pixel positions line passed procedure pixels plotted left endpoint right endpoint call set pixel loads preset color value frame buffer specified x pixel position include device h void linebres int xa int ya int xb int yb int dx abs xa xb dy abs ya yb int p dy dx int twody dy twodydx idy 4x int x xend determine point use start end ixa xb x xb yb xend xa else section line drawing algorithms setpixel x x xend xt4 p pp twoby else yt pp twodydx setpixel x bresenham algorithm generalized lines arbitrary slope con sidering symmetry various octants quadrants xy plane line positive slope greater interchange roles x directions step along direction unit steps cal culate successive x values nearest line path also could revise pro gram plot pixels starting either endpoint initial position line positive slope right endpoint x decrease step right left ensure pixels plotted regardless starting endpoint always choose upper lower two candidate pixels whenever two vertical separations line path equal negative slopes procedures similar except one coordinate de creases increases finally special cases handled separately horizontal lines ay vertical lines ax diagonal lines lax ay loaded directly frame buffer without processing line plotting algorithm parallel line algorithms line generating algorithms discussed far determine pixel posi tions sequentially parallel computer calculate pixel positions pixel positions along line path endpoints 21 25 plotted bresenham line algorithm along line path simultaneously partitioning computations among various processors available one approach partitioning problem adapt existing sequential algorithm take advantage multiple processors alternatively look ways set processing pixel positions calculated efficiently parallel important consideration devising parallel algorithm balance processing load among avail able processors given n processors set parallel bresenham line algorithm subdividing line path n partitions simultaneously generating line segments subintervals line slope left endpoint coordinate position xo yp partition line along positive x di rection distance beginning x positions adjacent partitions calculated ax art ny g n pp ax width line value partition width ax com puted using integer division numbering partitions processors calculate starting x coordinate kth partition x xp kax 16 example suppose ax n processors width partitions starting x values partitions xo x xo x partitioning scheme width last rightmost subinterval smaller others cases addition line endpoints integers truncation errors result variable width parti tions along length line apply bresenham algorithm partitions need initial value coordinate initial value decision parameter partition change ay direction partition calculated line slope partition width ax ay max 17 kth partition starting coordinate ye yo round kay 18 initial decision parameter bresenlym algorithm start kth subinterval obtained eq 12 py kax 2ay round kay 2ax 2ay ax 19 processor calculates pixel positions assigned subinterval using starting decision parameter value subinterval starting coordi nates x also reduce floating point calculations integer arith metic computations starting values p substituting ay ax rearranging terms extension parallel bresenham algorithm line slope greater achieved partitioning line di section line drawing algorithms bounding box line coordinate extents ax ay rection calculating beginning x values partitions negative slopes increment coordinate values one direction decrement another way set parallel algorithms raster systems assign processor particular group screen pixels sufficient number processors connection machine cm 000 processors assign processor one pixel within screen region approach adapted line display assigning one processor pixels within limits line coordinate extents bounding rectangle calculating pixel distances line path number pixels within bounding box line ax ay perpendicular distance line pixel coordinates x obtained calculation ax c 20 sy linelength p __ linelength c 2eay yoar linelength linelength vax ay constants b c evaluated line processor needs perform two multiplications two additions compute pixel distance pixel plotted less specified line thickness parameter instead partitioning screen single pixels assign processor either scan line column pixels depending line slope processor calculates intersection line horizontal row vertical column pixels assigned processor line slope iml processor simply solves line equation given x column value line slope magnitude greater line equation solved x processor given scan line value direct methods although slaw sequential machines performed efficiently using multiple proces sots straight line segments objects scan converted display raster system frame buffer positions must calculated sumed accomplished set pixel procedure stores tensity values pixels corresponding addresses within frame buffer array scan conversion algorithms generate pixel positions successive unit ymnx pere e tx yh gna ere addr addr x xrax screen frame buffer pixel screen positions stored linearly row major order within frame buffer tervals allows us use incremental methods calculate frame buffer ad dresses specific example suppose frame butfer array addressed row major order pixel positions vary lower left screen cor ner max ymax top right corner bilevel system bit per pixel frame buffer bit address pixel position x calculated addr x addr x x 21 moving across scan line calculate frame buffer address pixel x following offset address position x addr x addr x 22 stepping diagonally next scan line x get frame buffer address x calculation addr x addr x x 23 constant x precomputed line segments similar cremental calculations obtained eq 21 unit steps nega tive x screen directions address calculations involves single integer additian methods implementing set pixel procedure store pixel intensity values depend capabilities particular system design require ments software package systems display range intensity values pixel frame buffer address calculations would include pixel width number bits well pixel screen location procedure specifying straight line segments set number different forms phigs gks packages two dimensional line function xmons ymax polyline wepoints parameter n assigned integer value equal number coordi nate positions input wcpoints array input world coordinate values line segment endpoints function used define set n connected straight line segments series connected line segments occur often isolated line segments graphics applications polyline provides general line function display single straight line segment set n list x values two endpoint coordinates wepoints example use polyline following statements generate two connected line segments endpoints wepoints x wepoints wepoints x wepoints wepoints x wepoints polyline wepoints coordinate references polyline function stated absolute coordi nate values means values specified actual point positions coordinate system use graphics systems employ line point functions relative co ordinate specifications case coordinate values stated offsets last position referenced called current position example location last position referenced application program rel ative coordinate specification corresponds absolute position additional function also available setting current position line routine summoned packages user lists single pair offsets line command signals system display line start ing current position final position determined offsets current position updated final line position series connected lines produced packages sequence line commands one line section drawn graphics packages provide options allowing user specify line endpoints using either relative absolute coordinates implementation polyline procedure accomplished first per forming series coordinate transformations making sequence calls device level jine drawing routine phigs input line endpoints ac tually specified modeling coordinates converted world co ordinates next world coordinates converted normalized coordinates device coordinates discuss details carrving twa dimen sional coordinate transformations chapter device coordinates display polyline invoking line routine bresenham algorithm n times connect n coordinate points successive call passes co ordinate pair needed plot next line section first endpoint coordinate pair last endpoint previous section avoid setting intensity endpoints twice could modify line algorithm last endpoint segment platted discuss methods avoiding overlap displayed objects detail section 10 since circle frequently used component pictures graphs proce dure generating either full circles circular arcs included graphics packages generally single procedure provided display either circular elliptical curves ye properties circles circle defined set points given distance r cen ter position x distance relationship expressed pythagorean theorem cartesian coordinates circle center coordinates x radius r x xp y2ar 24 could use equation calculate position points circle circum ference stepping along x axis unit steps x r x r calcu lating corresponding values position ytvp fp 25 best method generating circle one problem ap proach involves considerable computation step moreover spacing plotted pixel positions uniform demonstrated fig _ 13 could adjust spacing interchanging x stepping values calculating x values whenever absolute value slope positive half circle cirele greater simply increases computation processing pw wane w required algorithm ye _ another way eliminate unequal spacing shown cal culate points along circular boundary using polar coordinates r fig 12 expressing circle equation parametric polar form yields pair equations x x rcos 26 rsind display generated equations using fixed angular step size circle plotted equally spaced points along circumference step size chosen depends application display device larger gular separations along circumference connected straight line segments approximate circular path continuous boundary ona taster display set step size r plots pixel positions approximately one unit apart computation reduced considering symmetry circles shape circle similar quadrant generate circle section second quadrant xy plane noting two circle sections symmetric respect axis circle sections third fourth quadrants obtained sections first second quadrants symmetry circle calculation circle point x one octant yields circle points shown seven octants considering symmetry x axis take one step note also symmetry octants circle sections adjacent oc tants within one quadrant symmetric respect line dividing two octants symmetry conditions illustrated fig 14 point position x one eighth circle sector mapped seven circle points octants xy plane taking advantage circle symme try way generate pixel positions around circle calculating points within sector x x determining pixel positions along circle circumference using either eq 24 eq 26 still requires good deal computation time cartesian equation 24 involves multiplications square root calculations parametric equations contain multiplications trigonometric calculations efficient circle algorithms based incremental calculation decision parameters bresenham line algorithm involves simple inte ger operations bresenham line algorithm raster displays adapted circle genera tion setting decision parameters finding closest pixel circum ference sampling step circle equation 24 however nonlinear square root evaluations would required compute pixel distances circular path bresenham circle algorithm avoids square root calculations comparing squares pixel separation distances method direct distance comparison test halfway position tween two pixels determine midpoint inside outside circle boundary method easily applied conics integer circle radius midpoint approach generates pixel positions bresenham circle algorithm also error involved locating pixel positions along conic section using midpoint test limited one half pixel separation midpoint circle algorithm raster line algorithm sample unit intervals determine closest pixel position specified circle path step given radius r screen center position x first set algorithm calculate pixel positions around circle path centered coordinate origin calculated position x moved proper screen position adding x x along circle section x tox yin first quadrant slope curve varies therefore take unit steps positive x direction octant use decision parameter deter mine two possible positions closer circle path step positions seven octants obtained symmetry apply midpoint method define circle function fort tyr 27 point x boundary circke radius r satisfies equation feirte x point interior circle circle function nega tive point outside circle circle function positive sum marize relative position point x v determined checking sign circle function x inside circle boundary ferte x x circle boundary 28 x outside circle boundary circle function tests 28 performed midpositions pix els near circle path sampling step thus circle function deci sion parameter midpoint algorithm set incremental calcu lations function line algorithm shows midpoint two candidate pixels sam pling position x assuming plotted pixel next need determine whether pixel position x one position closer circle decision parameter circle function 27 evaluated midpoint two pixels pi fae lye 29 p e p midpoit inside circle pixel scan line closer circle boundary otherwise midposition outside circle bound ary select pixel scanline successive decision parameters obtained using incremental calculations obtain recursive expression next decision parameter evaluating circle function sampling position x x pray fae a0 tl yee 1p shoe pest pe wha yer ed 30 either y_ depending sign py increments obtaining p either 2x p negative 2x evaluation terms 2x also done incremen tally 2x41 2x 2ye 2y start position r two terms values 2r respectively successive value obtained adding previous value 2x subtracting previous value 2y initial decision parameter obtained evaluating arcle function start position xq g xieyr reed yr rt mt ty midpoint candidate pixels sampling position x along circular path po fans f po r 30 radius r specified integer simply round py po zl r r integer since increments integers bresenham line algorithm midpoint method calculates pixel po sitions along circumference circle using integer additions subtrac tions assuming circle parameters specified integer screen coordi nates summarize steps midpoint circle algorithm follows midpoint circle algorithm input radius r circle center x obtain first point circumference circle centered origin xo yo r calculate initial value decision parameter pot gr x position starting k perform following test lf px next point along circle centered pri pr dys t1 otherwise next point along circle x pro pet deyo 1d 2yeos 2x 2x 2y1 2y determine symmetry points seven octants move calculated pixel position x onto circular path cen tered x plot coordinate values faxtx yrytye repeat steps x section circle generating algorithms 8b _ selected pixel positions solid circles along circle path radius r centered origin using midpoint circle algorithm open circles show symmetry oi 6 10 positions first quadrant example midpoint circle drawing given circle radius r demonstrate midpoint circle algorithm determining positions along circle octant first quadrant x x initial value decision parameter po l r circle centered coordinate origin initial point x9 yo initial increment terms calculating decision parameters 2xy yy successive decision parameter values positions along circle path cal culated using midpoint method ky xkeate mert 2xta yu 20 20 20 18 18 16 14 plot generated pixel positions first quadrant shown following procedure displays raster circle bilevel monitor using midpoint algorithm input procedure coordinates circle center radius intensities pixel positions along circle circumfer ence loaded frame buffer array calls set pixel routine px x yl x e lipse generated foci f f include device h void circlemidpoint int xcenter int ycenter int radius int x int radius int p radius void circleplotpoints int int int int plot first set points circleplotpoints xcenter ycenter x x xtt p pts x else yori pte x circleplotpoints xcenter ycenter x void circleplotpoints int xcenter int ycenter int x int setpixel xcenter setpixel xcenter x ycenter setpixel xcenter x ycenter x yoenter setpixel xcenter x ycenter ha setpixel xcenter yoenter x setpixel xcenter ycenter x setpixel xcenter yoenter x setpixel xcenter ycenter x loosely stated ellipse elongated circle therefore elliptical curves generated modifying circle drawing procedures take account dif ferent dimensions ellipse along major minor axes properties ellipses ellipse defined set points sum distances two fixed positions foci points lf distances two foci point p x ellipse labeled general equation ellipse stated constant 32 expressing distances terms focal coordinates f x f x y2 vx x yy vg ys constant 39 squaring equation isolating remaining radical squaring rewrite genera ellipse equation form ax cxy dx ey f 34 coefficients b c e f evaluated terms focal coor dinates dimensions major minor axes ellipse major axis straight line segment extending one side ellipse foci minor axis spans shorter dimension ellipse bisecting major axis halfway position ellipse center two foci interactive method specifying ellipse arbitrary orientation input two foci point ellipse boundary three coordi nate positions evaluate constant eg 33 coefficients eq 34 evaluated used generate pixels along elliptical path ellipse equations greatly simplified major minor axes ori ented align coordinate axes show ellipse stan dard position major minor axes oriented parallel x axes parameter r example labels semimajor axis parameter r labels semiminor axis equation ellipse shown written terms cf ellipse center coordinates parameters r r fu c doa 35 j wy ry using polar coordinates r also describe ellipse standard posi tion parametric equations x tr cos 36 yrytry sind symmetry considerations used reduce computations ellipse standard position symmetric quadrants unlike circle symmetric two octants quadrant thus must calculate pixel positions along elliptical arc throughout one quadrant obtain posi tions remaining three quadrants symmetry fig 19 midpoint ellipse gorithm approach similar used displaying raster circle given pa rameters determine points x ellipse standard position centered origin shift points ellipse cen tered x wish also display ellipse nonstandard position could rotate ellipse center coordinates reorient major minor axes present consider display ellipses standard position discuss general methods transforming object orientations positions chapter midpoint ellipse method applied throughout first quadrant two parts shows division first quadrant according slope ellipse r process quadrant taking unit steps v direction slope curve magnitude less tak ing unit steps direction slope magnitude greater regions processed various ways start position r step clockwise along elliptical path first quadrant ellipse centered semimajor axis r semiminor axis symmetry ellipse calculation point x one quadrant yields ellipse points shown three quadrants regam slope r ragin ellipse processing regions region magnitude ellipse slope less region magnitude slope greater shifting unit steps x unit steps slope becomes less alternatively could start r select points counterclockwise order shifting unit steps unit steps x slope becomes greater parallel processors could calculate pixel positions two regions simultaneously example sequential implementation midpoint algorithm take start position r step along el lipse path clockwise order throughout first quadrant define ellipse function eq 35 fattpae 12x r2r 37 following properties x inside ellipse boundary feripselx x ellipse boundary 38 x outside ellipse boundary thus ellipse function fetipee x serves decision parameter mid point algorithm sampling position select next pixel along el lipse path according sign ellipse function evaluated midpoint two candidate pixels starting r take unit steps x direction reach boundary region region switch unit steps direction remainder curve first quadrant step need test value slope curve ellipse slope calcu lated eq 37 39 ary dy dx boundary region region dy dx 2rx 2rdy therefore move region whenever 2rjx 2rdy 40 shows midpoint two candidate pixels sam pling position x first region assuming position se lected previous step determine next position along ellipse path evaluating decision parameter ellipse function 37 midpoint fp 1y iy rly pl midpoint inside ellipse pixel scan line closer ellipse boundary otherwise midposition outside ellipse boundary select pixel scan line next sampling position x decision parameter rex 62y region evaluated te plier fps year se midpoint nk gy ep rly xe xt midpoint candidate u x 42 pixels sampling position x along elliptical path plysy ple 2p ry e either depending sign p1 decision parameters incremented following amounts 2rexeey n pl increment rex tpf ye ifp1 circle algorithm increments ihe decision parameters calcu lated using addition subtraction since values terms x 2r also obtained incrementally initial position r two terms evaluate arix 43 arzy 2rir 44 x incremented updated values obtained adding 2r 43 subtracting 2r 44 updated values compared step move region region condition 40 satisfied region initial value decision parameter obtained evalu ating ellipse function start position xq yo r plo feng ty r2p2 ny rly ny ply r rir qn 45 region sample unit steps negative direction midpoint taken horizontal pixels step region decision parameter evaluated pay feu yu 46 ry yy chapter output primitives ly ie rox sr dy midpoint candidate pixels sampling position along elliptical path f p2 midposition outside ellipse boundary select pixel x p2 midpoint inside ellipse boundary select pixel position x determine relationship successive decision parameters region evaluate ellipse function next sampling step ym pei fouped yer 47 ila etl dip rie x set either x x depending sign p2 enter region initial position x taken last posi tion selected region initial decision parameter region j pay fata yo 49 p iv pd p rilxg ry wp ri ry te simplify calculation p2y could select pixel positions counterclock wise order starting r unit steps would taken positive di rection last pesition selected region midpoint algorithm adapted generate ellipse nonstan dard position using ellipse function eq 34 calculating pixel positions entire elliptical path alternatively could reorient ellipse axes standard position using transformation methods discussed chapter apply midpoint algorithm determine curve positions convert calculated pixel positions path positions along original ellipse orientation assuming r vy ellipse center given integer screen coordi nates need incremental integer calculations determine values decision parameters midpoint ellipse algorithm increments r r 2r 2rj evaluated beginning procedure summary midpoint ellipse algorithm listed following steps midpoint ellipse algorithm input r ry ellipse center x obtain first point ellipse centered origin xo ry calculate initial value decision parameter region x position region starting k g perform follow ing test pl next point along ellipse centered ply ply wart ry otherwise next point along circle ply plat 2a wp wx wx ay 2y bre continue 2rgx ory calculate initial value decision parameter region using last point yo calculated region po ri z0 df br position region starting k perform follow ing test p2 next point along ellipse centered tu py pa tt otherwise next point along circle x pave p2yt irie br using incremental calculations region determine symmetry points three quadrants move calculated pixel position x onto elliptical path cen tered x plot coordinate values x x xxx yoy ty repeat steps region 2r3x 2r section flipse cenerating algorithms example midpoint ellipse drawing given input ellipse parameters r r illustrate steps midpoint ellipse algorithm determining raster positions along ellipse path first quadrant initial values increments decision parameter cal culations arjx increment 2r7 arty 2riry increment 2r region j initial point ellipse centered origin xp initial decision parameter value ply ry r2r successive decision parameter values positions along ellipse path cal culated using midpoint method k ply uxtete veer xa 2b yk qd 768 224 768 44 768 208 640 640 288 512 244 384 move region since 2rfx 2rzy region initial point xp yo initial decision parameter py remaining positions along ellipse path first quadrant cal culated k pr xeers yeor xara 15t 256 233 128 745 _ plot selected positions around ellipse boundary within first quadrant shown following procedure midpoint algorithm used display el lipse input parameters rx ry xcenter ycenter positions along section ellipse generating algorithms positions along elliptical path centered origin r r using midpoint algorithm calculate pixel o0t123 67 addresses first quadrant rw oo curve first quadrant generated shifted proper screen positions intensities positions symmetry positions three quadrants loaded frame buffer using set pixel routine include device h define round int void ellipsemidpoint int xcenter int ycenter int rx int ry int rx2 rx rx int ry2 ry ry int tworx2 rx2 int twory2 ry2 int p int x int ry int px int py tworx2 void ellipseplotpoints int int int int plot first set points ellipseplotpoints xcenter ycenter x region p round ry2 rxz ry 25 rxz px py x px twory2 p p ry2 px else yyr py tworx2 p ry2 px py ellipseplotpaints xcenter ycenter x region pp round ry2 x x rx2 rx2 ry2 r g py tworx2 p p rx2 py else k e px twory2 p rx2 py px ell pseplotpoincs xcenter ycenter x void ellipsepiotpo nts int xcenter int ycenter int x int setpixel xcenter x ycenter setpixel xcenter x ycenzer setpixel xcenter x ycenter setpixel xcenter x ycenter curves various curve functions useful object modeling animation path specifica tions data function graphing graphics applications commonly encountered curves include conics trigonometric exponential functions probability distributions general polynomials spline functions displays curves generated methods similar discussed circle ellipse functions obtain positions along curve paths directly explicit representations f x parametric forms alternatively could apply incremental midpoint method plot curves described im plicit functions f x straightforward method displaying specified curve function ap proximate stra ght line segments parametric representations useful case obtaining equally spaced line endpoint positions along curve path also generate equally spaced positions explicit representa tion choosing independent variable according slupe curve slope x magnitude less choose x inde pendent variable calculate values equal x increments obtain equal spacing slope magnitude greater use inverse func tion x f calculate values x equal steps straight line curve approximations used graph data set dis crete coordinate points could join discrete points straight line seg ments could use linear regression least squares approximate data set single straight line nonlinear least squares approach used dis play data set approximating function usually polynomial circles ellipses many functions possess symmetries exploited reduce computation coordinate positions along curve paths example normal probability distribution function symmetric center position mean points along one cycle sine curve generated points interval conic sections general describe conic section conic second degree equation ax cxy dx ey f 50 values parameters b c e f determine kind curve display given set coefficients determine particular conic generated evaluating discriminant b 4ac generates ellipse circle b 4ac generates parabola 31 generates hyperbola example get circle equation 24 b c 2x f 2y f x r equation 50 also describes degenerate conics points straight lines ellipses hyperbolas parabolas particularly useful certain aninta tion applications curves describe orbital motions objects subjected gravitational electromagnetic nuclear forces planetary orbits solar system example ellipses object projected uniform gravitational field travels along parabolic trajectory shows para bolic path standard position gravitational field acting negative di rection explicit equation parabolic trajectory object shown written wy ax x9 b x x 52 constants b determined initial velocity vp cf object acceleration due uniform gravitational force also describe parabolic motions parametric equations using time parameter measured seconds initial projection point x xq byol yo yyol af v9 v initial velocity components value g near surface earth approximately 980cm sec object positions along par abolic path calculated selected time steps hyperbolic motions occur connection collision charged particles certain gravitational problems example comets meteorites moving around sun may travel along hyperbolic paths escape outer space never return particular branch left right describing motion object depends forces involved prob lem write standard equation hyperbola centered origin fy xy oo le ouf x r left branch x r right branch since equa tion differs standard ellipse equation 35 sign x terms generate points along hyperbolic path slightly modified ellipse algorithm return discussion animation applica tions methods detail chapter chapter discuss applications computer graphics scientific visualization g section curves etgnre 24 parabolic path object tossed downward gravitational field initial position x9 yo left branch left right branches hy perbola standard position symmetry axis along x axis chapter output primitives spline curve formed individual cubic polynomial sections specified coordinate points parabolas hyperbolas possess symmetry axis example parabola described eq 53 symmetric axis x xq opya methods used midpoint ellipse algorithm directly applied obtain points along one side symmetry axis hyperbolic parabolic paths two regions magnitude curve slope less magnitude slope greater first select appropriate form eq 50 use selected function set expressions decision parameters two regions polynomials spline curves polynomial function nth degree x defined ax ko 55 ay ax ay yx ar nonnegative integer constants get quadratic cubic polynomial n quartic n forth straight line polynomials useful number graphics applications including design object shapes speci fication animation paths graphing data trends discrete set data points designing object shapes motion paths typically done specifying points define general curve contour fitting selected points polynomial one way accomplish curve fitting construct cubic polynomial curve section pair specified points curve section described parametric form ay qgu tag au 56 fay ayy ayu aut 57 parameter u varies interval values coefficients u parametric equations determined boundary conditions curve sections one boundary condition two adjacent curve sections coordinate position boundary second condition match two curve slopes boundary obtain one continuous smooth curve continuous curves formed polynomial pieces called spline curves simply splines ways set spline curves various spline generating methods explored chapter methods exploiting parallelism curve generation similar used displaying straight line segments either adapt sequential algorithm allocating processors according curve partitions could devise methods assign processors screen partitions parallel midpoint method displaying citcles divide circular arc equal subarcs assign separate processor subarc parallel bresenham line algorithm need set com putations determine beginning value decisicn parameter p value processor pixel positions calculated throughout subarc positions circle octants obtained symmetry similarly parallel ellipse midpoint method divides elliptical arc first quadrant equal subarcs parcels separate processors pixel positions quadrants determined symmetry screen partitioning scheme circles ellipses assign scan line crossing curve separate processor case processor uses circle ellipse equation calcu late curve intersection coordinates display elliptical arcs curves simply use scan line partitioning method processor uses curve equation locate tersection positions along assigned scan line processors assigned indi vidual pixels processor would calculate distance distance squared curve assigned pixel calculated distance less prede fined value pixel plotted routines circles splines commonly used curves included many graphics packages phigs standard provide explicit func tions curves include following general curve function generalizeddrawingprimitive n wcpoints id datalist wcpoints isa list n coordinate positions datalist contains noncoor dinate data values parameter id selects desired function particular installation circle might referenced id ellipse id example definition curves phigs function circle id say could specified assigning two center coordinate val ues wcpoints assigning radius value datalist generalized drawing primitive would reference appropriate algorithm midpoint method generate circle interactive input circle could defined two coordinate points center position point cir cumference similarly interactive specification ellipse done three points two foci point ellipse boundary stored wo points ellipse standard position wcpoints could assigned center coordinates daialist assigned values r r splines defined control points would generated assigning control point coordi nates towcpoints functions generate circles ellipses often include capability drawing curve sections specifying parameters line endpoints expand ing parameter list allows specification beginning ending angular values arc illustrated another method designating cir section curve functions circular arc specified beginning ending angles circle center coordinate origin chapter output primitives cular elliptical arc input beginning ending coordinate positions arc 10 lower left section screen grid referencing integer coordinate positions lt 4 line path series connected line segments screen grid coordinate positions inuminated pixel raster position pixel addressing object geometry far assumed input positions given terms scan line number pixel position number across scan line saw chapter general several coordinate references associated specifica tion generation picture object descriptions given world reference frame chosen suit particular application input world coordi nates ultimately converted screen display positions world descriptions objects given terms precise coordinate positions infinitesi mally small mathematical points pixel coordinates however reference finite screen areas want preserve specified geometry world objects need compensate mapping mathematical input points finite pixel areas one way simply adjust dimensions displayed objects account amount overlap pixel areas object boundaries another approach map world coordinates onto screen positions pixels align object boundaries pixel boundaries instead pixel centers screen grid coordinates alternative addressing display positions terms pixel centers refer ence screen coordinates respect grid horizontal vertical pixel boundary lines spaced one unit apart screen coordinate position pair integer values identifying grid intersection position two pixels example mathematical line path polyline screen endpoints shown coordinate origin lower left screen pixel area referenced integer grid coordinates lower left corner illustrates convention section raster single illumi nated pixe screen coordinate position geneial identify area occupied pixel screen coordinates x unit square diago nally opposite corners x x pixel addressing scheme several advantages avoids half integer pixel boundaries facilitates pre cise object representations simplifies processing involved many scan conversion algorithms raster procedures algorithms line drawing curve generation discussed pre ceding sections still valid applied input positions expressed screen grid coordinates decision parameters algorithms simply mea sure screen grid separation differences rather separation differences pixel centers maintaining geometric properties displayed objects convert geometric descriptions objects pixel representations transform mathematical points lines finite screen areas maintain original geometric measurerrents specified input coordinates line path corresponding pixel display input screen grid endpoint coordinates 21 23 25 27 29 object need account finite size pixels transform object definition screen display shows line plotted bresenham line algorithm example section interpreting line endpoints precise grid crossing positions see line extend past screen grid posi tion plot pixel screen coordinates example given section would display line spans horizontal units vertical units mathematical line however ax dy addressing pixels center positions adjust length displayed line omitting one endpoint pixels think screen coordinates addressing pixel boundaries shown plot line using pixels interior line path pix els line endpoints example would plot left pixel rightmost pixel displays line conversion rectangle verti es screen coordinates display b includes right top boundaries display c maintains geometric magnitudes section 10 pixel addressing object geometry chapter qutput primitives geometric magnitudes mathematical line enclosed area inpul geometric properties maintained display ing area pixels interior object boundaries rectangle defined screen coordinate vertices shown example larger display filled pixels including border pixel lines joing specified vertices defined area rectangle units displayed b area units c original rectangle measurements maintained displaying xe circle path midpoint circle algorithm plot circle radius screen coordinates yyw x x dx x ty xb f 4x modification circle plot maintain specified circle diameter interna pixels right boundary mput rectangle x maintain boundary display set rightmost pixel grid coordinate x pixels vertical column span interval x x similarly mathematical top boundary rectangle set top pixel row displayed rectangle compensations finite pixel width along object boundaries applied polygons curved figures raster display main tains input object specifications circle radius center position instance would displayed fig midpoint circle algo rithm using screen grid coordinate positions plotted circle diameter plot circle defined diameter modify circle algorithm shorten pixel scan line pixel column one way generate points clockwise along circular arc third quadrant starting screen coordinates generated point seven circle symmetry points generated decreasing x coordi nate values along scan lines decreasing coordinate values along pixel columns similar methods applied ellipse algorithms main tain specified proportions display ellipse standard output primitive general graphics packages solid color pat terned polygon area kinds area primitives sometimes available poly gons easier process since linear boundaries two basic approaches area filling raster systems one way fill area determine overlap intervals scan lines cross area another method area filling start given interior position paint outward point encounter specified boundary conditions scan line approach typically used general graphics packages fill poly gons circles ellipses simple curves fill methods starting inte rior point useful complex boundaries interactive painting systems following sections consider methods solid fill specified areas fill options cliscussed chapter scan line polygon fill algorithm illustrates scan line procedure sond tilling polygon areas scan line crossing polygon area fill algorithm locates intersec tion points scan line polygon edges intersection points sorted left right corresponding frame buffer positions tween intersection pair set specified fill color example four pixel intersection positions polygon boundaries define two stretches interior pixels x x l4and x tox scan line intersections polygon vertices require special handling scan line passing vertex intersects two polygon edges position adding two points list intersections scan line shows two scan lines positions intersect edge endpoints scan line tersects five polygon edges scan line however intersects even number edges although also passes vertex intersection points along scan line section 11 filled area primitives 1t7 chapter output primitives interior pixels along scan line passing polygon area correctly identify interior pixel spans scan line need additional processing determine correct interior points topological difference scan line scan line identified noting position intersecting edges relative scan line scan line two intersecting edges sharing vertex opposite sides scan line scan line two intersecting edges scan line thus vertices require additional processing connecting edges opposite sides scan line identify vertices tracing around polygon boundary either clockwise counterclockwise order observing relative changes vertex coordinates move one edge next endpoint values two consecutive edges mo notonically increase decrease need count middle vertex single intersection point scan line passing vertex otherwise shared vertex represents local extremum minimum maximum polv gon boundary two edge intersections scan line passing vertex added intersection list scan line sean line intersection points along scan lines intersect polygon vertices scan line generates odd number intersections scan line generates even number intersections paired identify correctly interior pixel spans one way resolve question whether count vertex one intersection two shorten polygon edges split vertices counted one intersection process nonhorizontal edges around polygon boundary order specified either clockwise counter clockwise process edge check determine whether edge next nonhorizontal edge either monotonically increasing decreasing endpoint values lower edge shortened ensure one intersection point generated scan line going common vertex joining two edges illustrates shortening edge endpoint coordinates two edges increasing value upper endpoint current edge 1s decreased fig 37 endpoint values monotonically decreasing fig 37 b decrease coordinate upper endpoint edge following current edge calculations performed scan conversion graphics algorithms typically take advantage various coherence properties scene displayed mean coherence simply properties one part scene related way parts scene relation ship used reduce processing coherence methods often involve incre mental calculations applied along single scan line successive scan lines determining edge intersections set incremental coordinate calculations along edge exploiting fact slope edge constant one scan line next shows two successive scan lines crossing left edge polygon slope polygon boundary line expressed terms scan line intersection coordinates et yi 58 xper xk since change coordinates two scan lines simply ves ye 59 p p f scan line lt scan line p scan line b adjusting endpoint values pulygon process edges order around polygon perimeter edge currently processed inuicated solid line coordinate upper endpoint current edge decreased b coordinate upper endpoint next edge decreased section 11 filled area primitives scan line scan line two successive scan lines intersecting polygon boundary x intersection value x upper scan line determined x intersection value x preceding sean line xper mhf 60 successive x intercept thus calculated adding inverse slope rounding nearest integer obvious parallel implementation fill algorithm assign scan line crossing polygon area separate processor edge intersection cal culations performed independently along edge slope tersection x value scan line k initial scan line calculated xp xt 67 mn tn sequential fill algorithm increment x values amount along edge accomplished integer operations recalling slope ratio two integers pie ke ax ay differences edge endpoint x coordi nate values thus incremental calculations x intercepts along edge suc cessive scar lines expressed ax xie mf 62 del k ay using equation perform integer evaluation x intercepts ini tializing counter incrementing counter value ax time move new scan line whenever counter value becomes equal greater ay increment current x intersection value de crease counter value ay procedure equivalent maintaining integer fractional parts x intercepts incrementing fractional part reach next integer value example integer incrementing suppose edge slope initial scan line set counter counter sean line scan line yp scan line v4 polygon sorted edge table edge dc shortened one unit direction crement move next three scan lines along edge counter successively assigned values third scan line initial scan line counter value greater crement x intersection coordinate reset counter value continue determining scan line intersections way reach upper endpoint edge similar calculations carried obtain intersections edges negative slopes round nearest pixel x intersection value instead truncating obtain integer positions modifying edge intersection algorithm increment compared ay done integer arithmetic incrementing counter value 24x step comparing crement ay increment greater equal ay increase x value decrement counter value 2ay previous ex ample counter values first scan lines ini tial scan line edge would reduced reduced reduced reduced x would incre mented scan lines etc abuve initial scan line edge extra calculations required edge 2ax ax ax 2ay ay ay efficiently perform polygon fill first store polygon bound ary sorted edge table contains information necessary process sean lines efficiently proceeding around edges either clockwise counterclockwise order use bucket surt stare edges sorted smallest value cach edge correct scan line positions nonhorizon tal edges entered sorted edge table edges processed also shorten certain edges resolve vertex intersection question entry table particular scan line contains maximum value edge x intercept value lower vertex edge inverse slope edge scan line edges sorted order left night shows polygon assuciated sorted edge table crapter qutpul primitives next process scan lines bottem polygon top producing active edge list scan line crossing polygon boundaries active edge list scan line contains edges crossed scan line iterative coherence calculations used obtain edge intersections implementation edge intersection calculations also facilitated storing ax ay values sorted edge table also ensure cor rectly fill interior specified polygons apply considerations dis cussed section 10 scan line fill pixel spans pair x intercepts starting trom leftmost x intercept value ending one po sition rightmost intercept polygon edge shortened one unit direction top endpoint measures also guarantee pixels adjacent polygons overlap following procedure performs solid fill scan conversion input set polygon vertices scan line within vertical extents poly gon active edge list set edge intersections calculated across scan line interior fill applied successive pairs edge intersections processed left right finclude device h typedef struct tedge int yupper float xintersect dxperscan struct trdge next edge inserts edge list order increasing xintersect field void insertedge edce edge p g list pp q next edge xintersect p sxintersect p null p null else q p p p next edge next g next g next edge int k l ent j else jeke pts k pts j lf j fent j else index return coordinate next nonhorizontal line int ynext int k int cnt depz pts list edge edge jee return pts j store lower coordinate inverse slepe edge adjust store upper coordinate edges lower member monotonicallw increasing decreasing pair edges void makeedgerec dcpt lower dcpt upper int ycomp edge edge edge edges edge dxperscan float upper x lower x upper lower edge xintersect lower x upper ycomp edge yupper upper else edge yupper upper insertedge edges lower edge void buildedgelist int cnt dept pts edge edges edge edge dcpt vl v2 int yprev pts ent vl x pts cnt x vl pts ent cnt v2 pts ij vl v2 nonhorizontal line edge edge malloc sizeof edge vl v2 going edge makeedgerec vl v2 ynext cnt pts edge edges else going edge inakeedgerec v2 vl yprev edge edges yprev vi vi v2 void buildactivelist int scan edge active edge edges edge p q p edges scan next p q p next insertedge active p p void fillscan int scan edge active edge pl p2 int pl active next pl p2 pl next pl xintersect p2 xintersect seupixel lint scani pl p2 next void deleteafter edge q edge p q next q rext p next tree p delete completed edges update xintersect field others void updateactivelist int scan edge active edge g active p active next p scan p yupper p p mext deleteatrer q else p xtntersect p xintersect p dxper3can q 3p p p next void rescrtactivelist edge active edge g p active next active next null p q popnext insertedge active p p void seanfill int cnt depr pts edge edges window_height active int scan wincow_height edges edge malloc sizeof edge edges ij next null buildedgelist cnt pts edges active edge malloc sizeof tedge active next null scan scan window_height scan buildactivelist scan active edges active next fillscan scan active updateactivelist scan active vesortacctivebist active free edge records malloc ed inside outside tests area filling algorithms graphics processes often need identify inte rior regions objects far discussed area filling terms stan dard polygon shapes elementary geometry polygon usually defined self intersections examples standard polygons include triangles rectangles octagons decagons component edges objects joined vertices otherwise edges common points plane identifying interior regions standard polygons generally straightforward process graphics applications specify sequence vertices fill area including sequences produce intersect ing edges shapes always clear regions xy plane call interior regions designate exterior object graphics packages normally use either odd even rule nonzero winding number rule identify interior regions object apply odd even rule also called odd parity rule even odd rule conceptually drawing line position p distant point outside coordinate extents object counting number edge crossings along line number polygon edges crossed line odd p interior point otherwise p exterior point obtain ac curate edge count must sure line path choose inter sect polygon vertices shows interior exterior regions obtained odd even rule self intersecting set edges scan line polygon fill algorithm discussed previous section example area fill ing using odd even rule another method defining interior regions nonzero winding num ber rule counts number times polygon edges wind around particular point counterclockwise direction count called wind ing number interior points two dimensional object defined extenor de extenor j tc ee eg interior menor e e ay f odd even rule nonzero winding number rule b identifying interior exterior regions self intersecting polygon chapter output primitives nonzero value winding number apply nonzero winding number rule polygons initializing winding number tu c imagining line drawn position p distant point bu yor coordinate extents object line choose must pass vertices move along line position p distant point count number edges cross line direction add winding number every time intersect polygon edge crosses line right left subtract every time intersect edge crosses left right final value winding number edge crossings counted determines relative position p winding number nonzero p defined interior point otherwise p taken exterior point b shows interior exterior regions defined nonzero winding number rule self intersecting set edges standard palygons simple shapes nonzero winding number nule odd even tule give results complicated shapes two methods may yield different interior exterior regions example one way determine directional edge crossings take vector cross product vector u along line p distant point edge vector e edge crosses line z component cross product u x e fora particular edge positive edge crosses right left add winding number otherwise edge crosses left right subtract winding number edge vector calculated sub tracting starting vertex position edge ending vertex position example edge vector first edge example ess vg va v v5 represent point vectors vertices b somewhat simpler way compute directional edge crossings use vector dot products instead cross products set vector perpendicular u points right left look along line p direction u components u u u perpendicular u compo nents u u appendix dot product perpendicular edge vector positive edge crosses line right left add winding number otherwise edge crosses line left right subtract winding number graphics packages use nonzero winding number rule imple ment area filling since versatile odd even rule general ob jects defined multiple unconnected sets vertices disjoint sets closed curves direction specified set used define interior regions objects examples include characters letters al phabet punctuation symbols nested polygons concentric circles el lipses curved lines odd even rule applied determining intersec tions curve path instead finding edge intersections similarly nonzero winding number rule need calculate tangent vectors curves crossover intersection points line position p sean line fill curved boundary areas general scan line fill regions curved boundaries requires work polygon filling since intersection calculations involve nonlinear boundaries simple curves circles ellipses performing scan line fill straightforward process need calculate two scan line inter sections un opposite sides curve generating pixel posi tions along curve boundary midpoint method simply fill horizontal pixel spans boundary points opposite sices curve symmetries quadrants octants circles used reduce boundary calculations similar methods used generate fill area curve section elliptical arc example filled interior region bounded ellipse section straight line segment closes curve joining beginning ending positions arc symmetries incre mental calculations exploited whenever possible reduce computations boundary fill algorithm another approach area filling start point inside region paint interior outward toward boundary boundary specified single color fill algorithm proceeds outward pixel pixel boundary color encountered method called boundary fill algorithm particularly useful interactive painting packages interior points easily selected using graphics tablet interactive device artist designer sketch figure outline select fill color pattern color menu pick interior point system paints figure interior display solid color region border designer choose fill color boundary color boundary fill procedure accepts input coordinates interior point x fill color boundary color starting x procedure tests neighboring positions determine whether boundary color painted fill color neighbors tested process continues pixels boundary color area tested inner outer boundaries set specify area examples defining regions boundary fill shown shows two methods proceeding neighboring pixels current test position four neighboring points tested pixel positions right left current pixel areas filled method called connected second method shown b used fill complex figures set neighboring posi tions tested includes four diagonal pixels fill methods using ap proach called connected connected boundary fill algorithm would correctly fill interior area defined connected bound ary fill algorithm produces partial fill shown example color boundaries boundary fill procedure interior fill elliptical arc fill methods applied toa connected area connected area b open circles represent pixels tested current test position shown solid color following procedure illustrates recursive method ror filling connected area intensity specified parameter fill boundary color specified parameter boundary extend procedure fill connected region including four additional statements test diagonal positions x void boundaryfill4 int x int int fill int boundary int current current getpixel x current boundary current fill setcolor fill setpixel x boundaryfill4 x l fill boundary boundaryfill4 x fill boundary boundaryfilld x l fill boundary boundaryfill4 x fill boundary __ recursive boundary fill algorithms may fill regions correctly terior pixels already displayed fill color occurs algo rithm checks next pixels boundary color fill color encountering pixel fill color cause recursive branch terminate leaving interior pixels unfilled avoid first change color interior pixels initially set fill color applying boundary fill pro cedure also since procedure requires considerable stacking neighboring points efficient methods generally employed methods fill hori zontal pixel spans across scan lines instead proceeding connected connected neighboring points need stack beginning position horizontal pixel span instead stacking unprocessed neighboring positions around current position starting initial interior point method first fill contiguous span pixels starting scan line locate stack starting positions spans adjacent scan lines spans defined contiguous horizontal string positions start pasition al bi area defined within color boundary partially filled b using connected boundary fill algorithm b c filled pixel spans stacked positions s668 e00ec0e e e0e e o86 eeee 2osogh feohsco 2eo e s06 s635 ay ee 8666 ssusossesose ari om oe sbcgs6ccc008 ge q sseeeeeesoece boundary fill across pixel spans connected area filled initial pixel span showing position initial point open circle stacked positions pixel spans adjacent scan lines b filled pixel span first scan line initial scan line current contents stack c filled pixel spans first two scan lines initial scan line current contents stack ad completed pixel spans upper right portion defined region remaining stacked positions processed area defined within multiple color boundaries bounded pixels displayed area border color subsequent step unstack next start position repeat process example pixel spans could filled using approach illus trated connected fill region example first process scan lines successively start line top boundary upper scan lines processed fill pixel spans remaining scan lines order bottom boundary leftmost pixel position hori zontal span located stacked left right order across successive scan lines shown figure initial span filled starting positions spans next scan lines stacked b position unstacked processed pro duce filled span shown starting pixel position single span next scan line stacked position processed filled spans stacked positions shown c shows filled pixels processing spans upper right specified area position next processed spans filled upper left region position picked continue processing lower scan lines flood fill algorithm sometimes want fill recolor area defined within sin gle color boundary shows area bordered several different color regions paint areas replacing specified interior color instead searching boundary color valuc approach called flood fill algo rithm start specified interior point x reassign pixel values currently set given interior color desired fill color area want paint one interior color first reassign pixel val ues interior points color using either connected connected approach step pixel positions interior points repainted following procedure flood fills connected gion recursively starting input position void floodfill4 int x int int fillcoler int oldcolor getpixel x oldcolor setcolor fillcolor setpixel x floodfill4 x fillcolor oldcolor floodfill4d x fillcolor oldcolor floodfill4d x l1 fillcolor oldcolor floodfill4 x fillcolor oldcolor modify procedure f loodfil14 reduce storage requirements stack filling horizontal pixel spans discussed boundary fill al gorithm approach stack beginning positions pixel spans value oldcolor steps modified flood fill algo rithm similar illustrated boundary fill starting first position span pixel values replaced value oldcolor encountered display filled polygon phigs gks function fillarea n wevertices displayed polygon area bounded series n straight line segments connecting set vertex positions specified wcvertices packages provide fill functions objects curved boundaries implementation 111area function depends selected type interior fill display polygon boundary surrounding hollow interior choose solid color pattern fill border display polygon solid fill i11area function implemented scan line fill algorithm display single color area various attribute options dis playing polygon fill areas phigs discussed next chapter another polygon primitive available phigs 111areaset func tion allows series polygons displayed specifying list vertices polygon also graphics packages functions often provided displaying variety commonly used fill areas besides general polygons examples fillkectangle fillcire e fillcirclearc fill ellipse fill llipsearc cell array primitive allows users display arbitrary shape de fined two dimensional grid pattern predefined matrix color values mapped function onto specified rectangular coordinate region phigs version function cellarray wwepoints n colorarray colorarray n matrix integer color values wepoints lists limits rectangular coordinate region min yaun ona ymar shows distribution elements color matrix co ordinate rectangle coordinate cell width max xgun n height umax yeun pixel color values assigned according relative positions pixel center coordinates center pixel lies within one n coordinate cells pixel assigned color corresponding element matrix colorarray letters numbers characters displaved variety sizes stvles overall design style set family characters called type section 12 fill area functions view rows ymn columns xemun ine x mapping n cell array rectangular coordinate region face today hundreds typefaces available computer applications examples common typefaces courier helvetica new york palatino zapf chancery originally term font referred set cast metal char acter forms particular size format point courier italic point palatino bold terms font typeface often used inter changeably since printing longer done cast metal forms typefaces fonts divided two broad groups serif sans serif serif type small lines accents ends main character strokes sans serif type accents example text book set serif font palatino sentence printed sans serif font optima serif type generally readable easier read longer blocks text hand individual characters sans serif type easier recognize reason sans serif type said legible since sans serif characters quickly recognized typeface good labeling short headings two different representations used storing computer fonts simple method representing character shapes particular typeface use rectangular grid patterns set characters referred bitmap font bitmapped font another flexible scheme describe character shapes using straight line curve sections postscript example case set characters called outline font illustrates two methods character representation pattern copied area frame buffer bits designate pixel positions displayed monitor display character shape b interior character outline must filled using scan line fill proce dure section 11 bitmap fonts simplest define display character grid needs mapped frame buffer position general however bitmap fonts require space variation size format must stored font cache possible generate different sizes variations bold italic one set usually produce good results contrast bitmap fonts outline fonts require less storage since vari ation require distinct font cache produce boldface italic different sizes manipulating curve definitions character outlines take time process outline fonts must scan converted frame buffer character string displayed phigs following function text woepoint string parameter string assigned character sequence displayed coordinate position wcpoint x example statement text wcpoint population distribution along coordinate specification wcpoint could used label distribution graph string positioned relative coordinates x user op tion default x sets coordinate location lower left corner first character horizontal string displayed string orienta tions vertical horizontal slanting set attribute options discussed next chapter another convenient character function phigs one places desig nated character called marker symbol one selected positions function defined parameter list line function polymarker n wepoints predefined character centered n coordinate positions list wcpoints default symbol displayed polymarker depends tp vt tyr rpayoa oy tyooy 1tija oft 1tpo t4110 oq1rryyyrpryrpojo o7tfrpoy tyraalse oo oyoj rss ti ty ypr1p aqa oysalo ola b letter b represented bilevel bitmap pattem b outline shape defined straight line curve segments section 14 character generation x sequence data values plotted 100 pol ymarker function particular implementation assume asterisk used illustrates plotting data set statement polymarker wcpoints summary output primitives discussed chapter provide basic tools con structing pictures straight lines curves filled areas cell array patterns text examples pictures generated primitives given figs 50 51 three methods used plot pixel positions along straight line path dda algorithm bresenham algorithm midpoint method straight lines bresenham algorithm midpoint method identical efficient frame buffer access methods also per formed efficiently incrementally calculating memory addresses line generating algorithms adapted parallel implementation parti tioning line segments circles ellipses efficiently accurately scan converted using midpoint methods taking curve symmetry account conic sec tions parabolas hyperbolas plotted similar methods spline curves piecewise continuous polynomials widely used design applications parallel implementation curve generation accomplished partitioning curve paths account fact displayed lines curves finite widths must adjust pixel dimensions objects coincide specified geo metric dimensions done addressing scheme references pixel positions lower left corner adjusting line lengths filled area primitives many graphics packages refer filled polygons common method providing polygon fill raster systems scan line fill algorithm determines interior pixel spans across scan lines intersect polygon scan line algorithm also used fill interior objects curved boundaries two methods filling interior regions ob jects boundary fill algorithm flood fill algorithm two fill procedures paint interior one pixel time outward specified inte rior point scan line fill algorithm example fillirg object interiors using odd even rule ta locate interior regions methods defining object teriors also useful particularly unusual self intersecting objects com mon example nonzero winding number rule rule flexible odd even rule handling objects defined multiple boundaries data plot generated straight line segments curve circles markers text couftesy wolfram research inc maker electrical diagram drawn mathematica straight line sections circles filled rectangles text courtesy wolfram research inc maker mathematica additional primitives available graphics packages include cell arrays character strings marker symbols cell arrays used define store color patterns character strings used provide picture graph labeling marker symbols useful plotting position data points table lists implementations output primitives discussed chapter table output primitive implementations typedef struct float x wept2 defines location dimensionai world coordinates ppolyline int n wept2 pts draw connected sequence n line segments specified pts pcircle wept2 center float r draw circle radius x center pfillarea int n wcpt2 pts draw filled polygon n vertices specified pts pcellarray wept2 pts int n int int colors map n array colors onto rectangular area defined pts ptext wept2 position char txt draw character string txt position ppolymarker int n wept2 pts draw collection n marker symbols pts chapter applications output primitives present example programs illustrating applications output primitives functions listed table defined header file graph ics h along routines opengraphics closegraphics setcolor setbackground first program produces line graph monthly data period one year output procedure drawn data set also used second program produce bar graph include stdio h include graphics h define window_width define window_height amount space leave side chart define margin_width 05 window_width define n_data typedef enum jan feb mar apr may jun jul aug sep oct nov dec months char monthnames n_data jan feb mar apr may jun jul bug sep oct dec int readdata char inpile float data int fileerror false file fp months month fp fopen infile r null fileerror true else month jan month dec month fscanf fp tf dataf month fclose fp return fileerror void linechart float data wept2 datapos n_data labelpos months float mwidth window_width margin_width n_data int charcbottom window_height int offset 05 window_height space data labels int labellength assuming fixed width pixel characters labelpos chartbettom jan dec calculate x positions data markers datapos x margin_width mwidth mwidth datapos chartbottom offset data shift label left one half length labelpos x datapos x labellength ptext lahelpos monthnames ppolyline n_data datapos ppolymarker n_data datapos summary jan feb mar apr may jun jul aug sep oct nov dac line plot data points output linechart procedure void main int argc char argv float data n_data int dataerror false long windeowid arge fprintf stderr usage datafilename n argv exit dataerror readdata argv data dataerror fprintf stderr error read file n argv exit windewid opengraphics argv window_width window_height setebackground white setcolor black linechart data sleep closegraphics windowid void barchart float data wept2 datapos labelpos months float x mwidth window_width margin_width n_data int chartbottom window _height int offset 05 window_height space data labels int labellength assuming fixed width b pixel characters labelpos chartbottom jan dec find center month bar margin_width mwidth mwwidth shift label left one half assumed length labelpos x x labellength jan feb mar apr may jun jul aug sep oct nov dec bar chart plot output barchart procedure ptext labelpos monthnames get coordinates month bar datafos 0i x datapos x x labellength datafos l x datapos x x laseilength datafos ql datapos chartbottom offset datafos datapos chartbottom offset datal prillarea datapos kk km pie charts used show percentage contribution individual parts whole next procedure constructs pie chart number rel ative size slices determined input sample output procedure appears rdefine two_pt 28 void piechart moat data wept2 pts center float radius window_hetght float newslice total lastslice months month center x window_width center window_height pcircle center radius month jan month dec month total datafmonth pts ii x center x pts center month jan month dec montht newslice twolpl datal month total jlastslice ptsi l x center x radius cosf newslice pts l center radius sinf newslice ppolyline pts lastslice newslice lo variations circle equations output next procedure shapes shown generated varying radius r circle depending vary r produce spiral cardioid limacon similar figure include stdio h include math include graphics h define two_pi 28 limacon equacion r ecs theta b cardioid b sor cos theta typedet enum spiral cardioid threeleat tourleaf limacon fig void drawcurlyfig fig figure wcpt2 pos int 4p float r theta dtheta float pl0l int npoints int ceilf two_pi p wept2 pe pt iwept2 malloc npeints sizeof wept2 null fprintf stderr ailocate pcints n recur set first point figure pt pos switch figure ease spiral prl x pos x break case limacon pt x pos x plo e 1l break case cardicid prlo x pos x pio break case threeleaf pt x pos x pl0 break case fourleaf pt 0j x pos x pl0 break npoints theta two_pi switch figure case spival r p theta break case limacon r p cosf theta pil break case cardioid xr p cosf treta break case threeleaf r p cosf theta break case fourleaf xr p cosf theta break pt npoints x pos x r cosf thetui pt npoints pos r sinf theta npointst theta dtheta ppolyline nkoints pt free pt void main int arge char argv output generated piechart procedure oop curved figures produced drawshape procedure long windowid opengraphics argv fig center positions figure wept2 center parameters define figure first four need one parameter fifth figure llimacon needs two int p setbackground white setcolor black f spiral f limacon f drawcurlyfig f center f plf sleep closegraphics windowid references information bresenham algorithms found bresenham mid point methods see kappel parallel methods generating lines circles discussed pang wright additional programming examples information phigs primitives found howard et al hopgood duce gaskins blake information gks output primitive functions see hopgood et al enderle kansy pfaff exercises implement poly ine function using dda algorithm given number n input points single point plotted n extend bresenham line algorithm generate lines slope taking symmetry quadrants account implement poly ine function using algorithm routine displays set straight lines connecting n input points n routine displays single point 10 11 14 15 16 17 18 19 devise consistent scheme implementing polyline function set input line endpoints using modified bresenham line algorithm geometric magnitudes maintained section 10 use midpoint method derive decision parameters generating points along straight line path slope range show midpoint decision parameters bresenham iine algorithm use midpoint method derive decision parameters used generate straight line segments slope set parallel version bresenham line algorithm slopes range set parallel version bresenham algorithm straight lines slope suppose system inch inch video monitor display pixels per inch memory organized one byte words starting frame buffer address pixel assigned one byte storage frame buffer address pixel screen coordinates yl suppose system inch inch video monitor display pixels per inch memory organized one byte words starting frame buffer address pixel assigned bits storage frame buffer address ior addresses pixel screen coordinates x implement set pixel routine bresenham ine algorithm using iterative tech niques calculating frame buffer addresses section revise midpoint circle algorithm display sv geometric magnitudes maintained section 10 set procedure parallel implementation midpoint circle algorithm derive decision parameters midpoint ellipse algorithm assuming start posi tion r points generated along curve path counterclockwise order set procedure parallel implementation midpoint ellipse algorithm devise efficient algorithm takes advantage symmetry properties display sine function devise efficient algorithm taking function symmetry account display plot damped harmonic motion ae sin wx w angular frequency phase sine function plot function x several cycles sine function maximum amplitude reduced using midpoint method taking symmetry account develop efficient algorithm scan conversion following curve interval x yeax 12 use midpoint method symmetry considerations scan convert parabola x interval x use midpoint method symmetry considerations scan convert parabola xe interval exercises 20 21 22 26 27 28 29 30 31 34 set midpoint algoritiim taking symmetry considerations account scan convert paraboia form axt b input values parameters b range x write program scan convert interior specified ellipse solid color devise algorithm determining interior regions input set vertices using nonzero winding rumber rule cross product calculations identify direc tion edge crossings devise algorithm determining interior regions input set vertices using nonzero winding number rule dot product calculatians identify direc tion edge crossings write procedure filling interior specificd set polygon vertices using nonzero winding number rule identify interior regions modify boundary fill algorithm connected region avoid excessive stack ing incorporating scan line methods write boundary fill procedure fill connected region explain ellipse displayed midpoint method could properly filled boundary fill algorithm develop implement flood fill algorithm fill interior specified area write routine implement text function write routine implement polymarker function write program display bar graph using polyline function input program include data points labeling required x axes data points scaled program graph displayed across full screen area write program display bar graph selected screen area use poly line function draw bars write grocedure display line graph input set data points se lected area screen input data set scaled fit selected screen area data points displayed asterisks joined straight line segments x axes labeled according te input specifications instead asterisks small circles symbols could used plot data points using circle function write routine display pie chart appropriate label ing input routine include data set giving distribution data set intervals name pie chart names intervals section labet displayed outside boundary pie chart near corre sponding pie section hapter attributes output primitives n general parameter affects way primitive displayed referred attribute parameter attribute parameters color size determine fundamental characteristics primitive others specify primitive displayed special conditions examples attributes class include depth information three dimensional view ing visibility detectability options interactive object selection pro grams special condition attributes considered later chapters consider attributes control basic display propertics primitives without regard special situations example lines dot ted dashed fat thin blue orange areas might filled one color multicolor pattern text appear reading left right slanted diagonally across screen vertical columns individual characters displayed different fonts colors sizes apply intensity variations edges objects smooth raster stairstep effect one way incorporate attribute options graphics package ex tend parameter list associated output primitive function include appropriate attributes line drawing function example could contain parameters set color width properties addition endpoint coor dinates another approach maintain system list current attribute values separate functions included graphics package setting cur rent values attribute list generate output primitive system checks relevant attributes invokes display routine primitive using current attribute settings packages provide users combi nation attribute functions attribute parameters output primitive commands gks phigs standards attribute settings accom plished separate functions update system attribute list basic attributes straight line segment type width color graphics packages lines also displayed using selected pen brush options following sections consider line drawing routines modified accommodate various attribute specifications line type possible selections line type attribute include solid lines dashed lines dotted lines modify line drawing algorithm generate lines setting length spacing displayed solid sections along line path dashed line could displayed generating interdash spacing equal length solid sections length dashes interdash spacing often specified user options dotted line displayed generating short dashes spacing equal greater dash section size similar methods used produce line type variations line attributes set line type attributes phigs application program user invokes function setlinetype 1t parameter assigned positive integer value generate lines respectively solid dashed dotted dash dotted values line type parameter 1t could used display variations dot dash patterns line type parameter set phigs application pro gram al subsequent line drawing commands produce lines line type following program segment illustrates use linetype command display data plots include stdio h include graphics h define margin_width 05 window_width int readdata char infile float data int filebrror false file fp int month fp fopen infile r null fileerror true else month month month fscanf fp f data month fclose fp return fileerror void chartdata float data plinetype linetype wept2 pts i2 float monthwidth window_width margin_width int pts x margin_width monthwidth monthwidth pts data ij psetlinetype linetype ppolyline pts int main int argc char argv long windowid opengraphics argv window_width window_height float data setbackground white setccolor blue readdata data datal960 data chartdata data solid readdata data datal970 data chartdata data dashed readdata data datal980 data chartdata data dotted sleep closegraphics windowid ees80e b unequal length dashes displayed number pixels plotting three data sets three differen line types output chart data procedure raster line algorithms display line type attributes plotting pixel spans various dashed dotted dot dashed patterns line drawing proce dure outputs sections cuntiguous pixels along line path skipping number intervening pixels solid spans pixel counts span length interspan spacing specified pixel mask string containing digits indicate positions plot along line path mask instance could used display dashed line dash length four pixels interdash spacing uf three pixels bilevel system mask gives bit values loaded frame buffer along line path display selected line type plotting dashes fixed number pixels results unequal length dashes different line orientations illustrated ir dashes shown plotted four pixels diagonal dash 1s longer factor v2 precision drawings dash lengths remain approximately constant line orientation accomplish adjust pixel counts solid spans interspan spacing according line slope dis play approximately equal length dashes reducing diagonal dash three pixels another method maintaining dash length treat dashes individ ual line segments endpoint coordinates dash located passed line routine calculates pixel positions along dash path line width implementation line width options depends capabilities output device heavy line video monitor could displaved adjacent parallel lines pen plotter nught require pen changes phigs attrib utes line width command used set current line width value tribute list value used line drawing algorithms control thickness lines generated subsequent output primitive commands set line width attribute command setlinew inscalefactor lw line width parameter assigned positive number indicate relahve width line displayed value specifies standard width line pen plotter instance user could set lw value plot line whose width half standard line values greater produce lines thicker standard raster implementation standard width line generated single pixels sample position bresenham algorithm width lines displayed positive integer multiples standard line plotting addi tional pixels along adjacent parallel line paths lines slope magnitude less modify line drawing routine display thick lines plot ting vertical span pixels x position along line number pix els span set equal integer magnitude parameter 1w plot double width line generating parallel line original line path x sampling position calculate corresponding coordinate plot pixels screen coordinates x x display lines lw alternately plotting pixels single width line path lines slope magnitude greater plot thick lines horizontal spans alternately picking pixels right left line path scheme demonstrated line width plotted horizontal pixel spans although thick lines generated quickly plotting horizontal vertical pixel spans displayed width line measured perpendicular line path dependent slope line displayed thinner factor compared horizontal vertical line plotted samelength pixel spans another problem implementing width options using horizontal vertical pixel spans method produces lines whose ends horizontal vertical regardless slope line effect noticeable thick lines adjust shape line ends give better ap pearance adding line caps one kind line cap butt cap ob tained adjusting end positions component parallel lines thick line displayed square ends perpendicular line path specified line slope square end thick line slope another line cap round cap obtained adding filled semicircle butt cap circular arcs centered line endpoints diameter equal line thickness third type line cap projecting square cap simply extend line add butt caps positioned one half line width beyond specified endpoints methods producing thick lines include displaying line filled rectangle generating line selected pen brush pattern dis cussed next section obtain rectangle representation line double wide raster line slope generated vertical pixel spans section line attributes x r x c oe raster line slope line width parameter lw plotted horizontal pixel spans boundary calculate position rectangle vertices along perpendicu jars line path vertex coordinates displaced line end points one half line width rectangular line appears fig could add round caps filled rectangle extend length display projecting square caps generating thick polylines requires additional considerations gen eral methods considered displaying single line segment produce smoothly connected series line segments displaying thick lines using horizontal vertical pixel spans example leaves pixel gaps boundaries lines different slopes shift horizon tal spans vertical spans generate thick polylines smoothly joined cost additional processing segment endpoints shows three possible methods smoothly joining two line segments miter join accomplished extending outer boundaries two lines meet round join produced capping connection two segments circular boundary whose diameter equal line b ic thick lines drawn butt caps b round caps c projecting square caps b tc thick line segments connected miter join b round join c bevel join width bevel join generated displaying line segments butt caps filling triangular gap segments meet angle tween two connected line segments small miter join generate long spike distorts appearance polyline graphics package avoid effect switching miter join bevel join say two con secutive segments meet small enough angle pen brush options packages lines displayed pen brush selections op tions category include shape size pattern possible pen brush shapes given shapes stored pixel mask identifies array pixel positions set along line path example rectangular pen implemented mask shown fig moving center one corner mask along line path avoid setting pixels frame buffer sim ply accumulate horizontal spans generated position mask keep track beginning ending x positions spans across scan line lines generated pen brush shapes displayed various widths changing size mask example rectangular pen line could narrowed rectangular mask widened 4x4 mask also lines displayed selected patterns superimposing pattern values onto pen brush mask examples line patterns shown additional pattern option provided paint package display simulated brush strokes illustrates patterns displayed modeling different types brush strokes line color system provides color intensity options parameter giving cur rent color index included list system attribute values polyline rou tine displays line current color setting color value frame buffer pixel locations along line path using set pixel procedure number color choices depends number bits available per pixel frame buffer set line color value phigs function setpolylinecolourindex lc section line auributes custom document brushes ae pen brush shapes line display nonnegative integer values corresponding allowed color choices assigned line color parameter lc line drawn background color invisible user erase previously displayed line respecifying back ground color assuming line overlap one background color area example use various line attribute commands applica ions program given following sequence statements setlinetype setlinewictnsscalefactor setpolylinetolourindex polyline nl wcpointsl setpolylinetclourindex polyline n wepoints program segment would display two figures drawn double wide dashed lines first displayed color corresponding code second color line path bi pixel mask rectangular pen b associated array pixels displayed centering mask specified pixel position x _ generating line pen shape curved lines drawn paint program using various shapes patterns left right brush shapes square round diagonal line dot pattern faded airbrush daruma doll symbol good fortune japan drawn computer artist koichi kozaki using paintbrush system daruma dolls actually come without eyes one eye painted wish made painted wish comes true courtesy wacom technology inc parameters curve attributes line segments display curves varying colors widths dot dash patterns available pen brush options methods adapting curve drawing algorithms accommo date attribute selections similar line drawing pixel masks discussed implementing line type options also used raster curve algorithms generate dashed dotted patterns example mask produces dashed circle shown generate dashes various octants using circle symmetry must shift pixel positions maintain correct sequence dashes spaces move one octant next also line algorithms pixel masks display dashes interdash spaces vary length according slope curve want display constant length dashes need adjust num ber pixels plotted dash move around circle circumference stead applying pixel mask constant spans plot pixels along equal angular arcs produce equal length dashes raster curves various widths displayed using method hon zontal vertical pixel spans magnitude curve slope less plot vertical spans slope magnitude greater plot horizontal spans demonstrates method displaying circular arc width first quadrant using circle symmetry generate circle path vertical spans octant x x reflect pixel positions theline x obtain remainder curve shown circle sections quadrants obtained reflecting pixel positions first quadrant coordinate axes thickness curves displayed section method function curve slope circles ellipses curves curve attributes appear thinnest slope magnitude another method displaying thick curves fill area two parallel curve paths whose separation distance equal desired width could using specified curve path one boundary setting second boundary either inside outside original curve path ap proach however shifts original curve path either inward outward de pending direction choose second boundary maintain original curve position setting two boundary curves distance one half width either side specified curve path example approach shown circle segment radius specified width boundary arcs set separation distance either side radius maintain proper dimensions circular arc discussed section 10 set radii concentric boundary arcs r 14and r although method accurate generating thick circles general provides approximation true area thick dashed circular arc displayed dash span pixels interdash spacing pixels circular width plotted pixel spans circular arc width radius displayed filling region two concentric ares circular arc displayed rectangular pen curves example inner outer boundaries fat ellipse generated method foci pen brush displays curves generated using techniques discussed straight line segments replicate pen shape along line path illustrated circular arc first quadrant center rectangular pen moved successive curve positions produce curve shape shown curves displayed rectangular pen manner thicker magnitude curve slope uniform curve thickness displayed rotating rectangular pen align slope direc tion move around curve using circular pen shape curves drawn pen brush shapes displayed different sizes superimposed patterns simulated brush strokes various color intensity level options made available user de pending capabilities design objectives particular system general purpose raster scan systems example usually provide wide range colors random scan monitors typically offer color choices color options numerically coded values ranging positive integers crt monitors color codes converted intensity level settings electron beams color plotters codes could control ink jet deposits pen selections ina color raster system number color choices available depends amount storage provided per pixel frame buffer also color informa tion stored frame buffer two ways store color codes di rectly frame buffer put color codes separate table use pixel values index table direct storage scheme ever particular color code specified application program corre sponding binary value placed frame buffer component pixel output primitives displayed color minimum number colors provided scheme bits storage per pixel shown table three bit positions used control intensity level either corresponding electron gun rgb monitor leftmost bit controls red gun middle bit controls green gun rightmost bit controls blue gun adding bits per pixel frame buffer increases number color choices bits per pixel bits used gun allows four different intensity settings three color guns total color values available screen pixel resolution full color bit per pixel rgb system needs megabytes storage frame buffer color tables alternate means providing ex tended color capabilities user without requiring large frame buffers lower cost personal computer systems particular often use color tables reduce frame buffer storage requirements color tables illustrates possible scheme storing color values color lookup table video lookup table frame buffer values used indices color table example pixel reference one table positions entry table uses bits specify rgb color color code combination green blue color displayed pixel location x systems employing particular lookup table would allow table eight color codes three bit per pixel frame buffer stored color values displa yed color frame buffer color code red green blue black biue green cyan red magenta yellow white wa bw nm h seen hoo oo o70 section color grayscale levels chapter 4a user select colors simultaneous display palette nearly attributes output primitives million colors compared full color system scheme reduces num ber simultaneous colors displayed also reduces frame buffer storage requirements megabyte graphics systems provide bits per pixel frame buffer permitting user select colors could used display user set color table entries phigs applications program function setcolourrepresentation ws ci colorptr parameter ws identifies workstation output device parameter ci specifies color index color table position number exam ple parameter colorptr points trio rgb color values r g b specified range example possible table entries color monitors given several advantages storing color codes lookup table use color table provide reasonable number simultaneous colors without requiring large frame buffers applications different colors sufficient single picture also table entries changed time allowing user able experiment easily different color combinations design scene graph without changing attribute settings graph ics data structure similarly visualization applications store values physical quantity energy frame buffer use lookup table try various color encodings without changing pixel values visual ization image processing applications color tables convenient means setting color thresholds pixel values specified threshold set color reasons systems provide capabilities color code storage user elect either use color tables store color codes directly frame buffer red gun ta green gun biue gun color lookup table bits per entry accessed frame buffer bits per pixel value stored pixel position x references location table containing value bit segment entry controls intensity level one three electron guns rgb monitor ca coler ci color q 03 13 l workstation color tables grayscale monitors color capability color functions used ap plication program set shades gray grayscale displayed primi tives numeric values range j used specify grayscale levels converted appropriate binary codes storage raster allows intensity settings easily adapted systems dif tering grayscale capabilities table lists specifications intensity codes four level gray scale system example intensity input value near 33 would stored binary value frame buffer pixels value would displayed dark gray additional bits per pixel available frame buffer value 33 would mapped nearest level bits per pixel accommodate gray levels bits per pixel would give us shades gray alternative scheme storing intensity information convert intensity code directly voltage value produces gray scale level output device use multiple output devices available installation color table interface may used monitors case color table monochrome monitor set using range rgb values display intensity corresponding given color index ci calculated intensity min r g b max r g b table intensity codes four lfvel grayscale system intensity stored intensity displayed codes values grayscale frame buffer binary code black 33 aly dark gray 67 light gray qi1 white section calor grayscale levels hollow fa patterned te figure polygon fill styles options filling defined region include choice solid color patterned fill choices particular colors patterns fill options applied polygon regions areas defined curved boundaries depending capabilities available package addition areas painted using various brush styles colors transparency parameters fill styles areas displayed three basic fill styles hollow color border filled solid color filled specified pattern design basic fill style selected phigs program function setinteriorstyle fs values fill style parameter fs include hollow solid pattern another value fill style hatch used fill area selected hatching patterns parallel lines crossed lines line tributes selected fill style value recorded list system attributes applied fill interiors subsequently specified areas fill selections pa rameter fs normally applied polygon areas also imple mented fill regions curved boundaries hollow areas displayed using boundary outline inte rior color background color solid fill displayed single color including borders region color solid interior hollow area outline chosen setinteriorcolourindex fc fill color parameter fc set desired color code polygon hollow fill generated line drawing routine closed polyline solid fill gion accomplished scan line procedures discussed section 11 fill options include specifications edge type edge width edge color region attributes set independently fill style fill color provide options line attribute parameters line type line width line color display area edges dotted dashed fat thin available color regardless filled interior mn eee ee diagonal diagonal hatch fill cross hatch fill polygon fill using hatch patterns pattern fill select fill patterns setinteriorstyleindex pi pattern index parameter pi specifies table position example fol lowing set statements would fill area defined i11area command second pattern type stored pattern table setinteriorstyie pattern setinteriorstyleindex fillarea n points separate tables set hatch patterns f selected hatch fill interior yle program segment value assigned parameter pi index stored patterns hatch table fill style pattern table entries created individual output de vices setpatternrepresentation iws p nx ny cp parameter pi sets pattern index number workstation code ws cp isa two dimensional array color codes nx colunins ny rows follow ing program segment illustrates function could used set first entry pattern table workstation cpll ep epli cp setpatternrepresentation cp table shows first two entries color table color array cp ex ample specifies pattern produces alternate red black diagonal pixel lines eight color system color array cp applied fill region need specify size area covered element array setting rectangular coordinate extents pattern setpatternsize dx dy parameters dx dy give coordinate width height array mapping example coordinate size associated pattern array given values dx dy figure given screen co ordinates element color array would applied screen grid containing four pixels reference position starting pattern fill assigned statement setpatrernreferencepoint positicn parameter posit pointer coordinates xp yp fix lower left comer rectangular pattern starting position pattern replicated x directions defined area covered nonover table workstation pattern table two entries using color codes table index pattern p1 cp nn co noh hro norns __ _1 b fer tae ba tap te 4nd fienre 20 pattern array columns rows mapped coordinate rectangle chapter attributes output primitives lapping copies pattern array process filling area rectangu lar pattern called tiling rectangular fill patterns sometimes referred tiling patterns demonstrates tiling triangular fill area starting pattern reference point illustrate use pattern commands following program exam ple displays black white pattern interior parallelogram fill area pattern size program set map array element toa single pixel start position tiling area froma designated start position nonoverlapping adjacent patterns laid cover sean lines passing defined area define ws void patternfill wept2 pts int bwpattern psetpatternrepresentation ws bwpattern pes x pts pts x pts l pts x pts pts x pts psetfillareainteriorstyle pattern psetfillareapatternindex psetpatternreferencepoint pfillarea pts pattern fill implemented modifying scan line procedures dis cussed chapter selected pattern superimposed onto scan lines beginning specified start position pattern fill rectangular patterns would mapped vertically scan lines top bottom fill area horizontally interior pixel positions across scan lines horizontally pattern array repeated intervals specified value size parameter dx similarly vertical repeats pattern separated inter vals set parameter dy scan line pattern procedure applies poly gons areas bounded curves te e pattern array superimposed parallelogram fill area produce display b hatch fill applied regions displaying sets parallel lines fill procedures implemented draw either single hatching cross hatching spacing slope hatch lines set parameters hatch table raster systems hatch fill specified pattern array sets color values groups diagonal pixels many systems pattern reference point xp yp 1s assigned sys tem instance reference point could set automatically polygon ver tex general fill region reference point chosen lower left corner bounding rectangle bounding box determined coordi nate extents region simplify selection reference coordi nates packages always use screen coordinate origin pattern start position window systems often set reference point coordinate ori gin window always setting xp yp coordinate origin also simplifies tiling operations color array clement pattern mapped single pixel example row positions pattern array refer enced reverse bottom top starting pattern value assigned pixel position x screen window coordinates setpixel x cppty mod ny x mod nx ny nx specify number rows number columns pat tern array setting pattern start position coordinate origin however ef fectively attaches pattern fill screen window background rather fill regions adjacent overlapping areas filled pattern would show apparent boundary areas also repositioning refilling object pattern result shift assigned pixel values object interior moving object would appear transparent stationary pattern background instead moving fixed interior pattern also possible te combine fill pattern background colors includ ing grayscale various ways bitmap pattern containing digits values could used transparency indicators let back ground show alternatively digits used fill inte tior two color patterns general color fill patterns combined several ways background colors pattern background colors combined using boolean operations pattern colors simply place background colors demonstrates boolean place operations fill pattern would set pixel values binary black white system particular background pattern ymax bounding rectangle bounding rectangle region coordinate extents xin xmax x varun ang ya x man directions mio section area fill attrivutes eo pattern background pixel values combining fili pattern backgrouna pattern using boolean operations xor exclusive using simple replacement soft fill modified boundary fill flood fill procedures applied repaint areas fill color combined background colors referred soft fill tint fill algorithms one use fill methods soften fill colors object borders blurred antialias edges another allow repainting color area originally filled semitranspar ent brush current color mixture brush color background colors behind area either case want new fill color variations area current fill color example type fill linear soft fill algorithm repaints area originally painted merging foreground color f single background color b f b assuming know values f b determine colors originally combined checking cur rent color contents frame buffer current rgb color p pixel within area refilled linear combination f b p tf ob transparency factor value pixel values less background color contributes interior color region fill color vector equation holds rgb component colors p pp po pad f fz fe fp b bz bg thus calculate value parameter using one rgb color com ponents po pa eb f k r g b f b theoretically parameter value rgb component roundoff integer codes result different values different components minimize roundoff error se lecting component largest difference f b value tis used mix new fill color nf background color using either modified flood fill boundary fill procedure similar soft fill procedures applied area whose foreground color merged multiple background color areas checker board pattern two background colors b b mixed fore ground color f resulting pixel color p p f b b sum coefficients ty color terms must equal set two simultaneous equations using two three rgb color components solve two proportionality parameters tg parameters used mix new fill color two back ground colors obtain new pixel color three background colors one foreground color two background two foreground colors need three rcb equations obtain relative amounts four colors foreground background color combinations however system two three rgb equations solved occurs color val ucs similar proportional appearance displayed characters controlled attributes font size color orientation attributes set entire character strings text individual characters defined marker symbols tex attributes great many text options made available graphics pro grammers first choice font typeface set characters particular design style new york courier helvetica london times roman various special symbol groups characters selected font also displaved assorted underlining styles solid ted doubie boldface italics outline shadow styles particular section character attributes chapter attributes output primitives font associated style selected phigs program setting integer code text font parameter f function sertextfou tf font options mace available predetined sets grid patterns char acter sets designed polylines spline curves color settings displayed text stored system attribute list used procedures load character definitions frame buffer character string displayed current color used set pixel values frame buffer corresponding character shapes positions control text color intensity managed application program settextcolourindex tc text color parameter zc specifies allowable color code adjust text size scaling overall dimensions height width characters scaling character width character size specified printers compositors points point 013837 inch approxi mately 72 inch example text reading point font point measurements specify size body character dif ferent fonts point specifications different character sizes depending design typeface distance bottomline topline character body characters particular size typeface body width may vary proportionally spaced fonts assign smaller body width narrow characters j f compared broad characters w character heighi defined distance baseline capline characters kerned characters f j fig 25 typically extend beyond character body limits letters descend ers g j p q extend baseline fach character positioned within character body font designer allow suitable spacing along tween print lines text displayed character bodies touching text size adjusted without changing width height ratio characters seccharacterheight ich _ character kern _ character pom body e character height base im __ bottom j kern igure character body height height height parameter ch assigned real value greater set coordinate height capital letters distance baseline capline user coordinates setting also affects character body size width spacing characters adjusted maintain text proportions instance dou bling height also doubles character width spacing char acters shows character string displayed three different charac ter heights width text set function effect different character height settings displayed text setcharacterexpansionfactor cw character width parameter cw set positive real value scales body width characters text height unaffected attribute setting examples text displayed different character expansions given fig 27 spacing characters controlled separately setcharacterspacing cs character spacing parameter cs assigned real value value assigned cs determines spacing betwveen character bodies along print lines negative values cs overlap character bodies positive values sert space spread displayed characters assigning value cs causes text displayed space character bodies amount spacing applied determined multiplying value cs character height distance baseline capline character string displayed three different settings character spacing para meter orientation displayed character string set according direc tion character vector setcharacterupvector upvect parameter upvect function assigned two values specify x vector components text displayed orientation characters baseline capline direction vector example upvect direction vector text would displayed shown procedure orienting text rotates characters sides character bodies baseline capline aligned vector rotated character shapes scan converted frame buffer section character attributes widtho width width effect different character width settings displayed text spacing spacing spacing effect different character spacings displayed text chapter tt ee attributes output primitives te uz direction vector vector _ controls orientation oh displayed text b useful many applications able arrange character strings verti cally horizontally attribute parameter option set statement seutextpath tp ax ms cro dpme f text path parameter tp assigned value right left examples text displayed four options shown procedure implementing option must transform character patterns specified orientation transferring frame buffer character strings also oriented using combination vector text path specifications produce slanted text shows directions character strings generated various text path settings vec tor examples text generated text path values right ee vector illustrated oe another handy attribute fer character strings alignment attribute specifies text positioned respect start coordinates align text path attributes set ment attributes set produce horizontai vertical arrangements settextaligumert h vi character strings _ horizontal text parameters h control horizontal vertical alignment respectively horizontal alignment set assigning h value left centre right vertical alignment set assigning v value top cap half base bottom inter pretation alignment values depends current setting text r path shows position alignment settings text displayed horizontally right vertically similar interpretations apply text path values left natural alignment par snmires string ticular text path chosen assigning value norma h v parame ters illustrates common alignment positions tor horizontal vertt cal text labels r precision specification text display given n settextpree sion tpri k vee text precision parameter tpr assigned one values string char stroke highest quality text displayed precision parameter set text displayed four value stroke precision setting greater detail would used defin text path options ing character shapes processing attribute selections string manipulation procedures would carried highest possible ac curacy lowest quality precision setting string used faster display character strings precision many attribute selections text path ignored string manipulation procedures simplified reduce processing time marker attributes marker symbol single character displayed different colors different sizes marker attributes implemented procedures load chosen character raster defined positions specified color size select particular character marker symbol setmarkertype mt marker type parameter mt set integer code typical codes marker type integers specifying respectively dat ver tical cross asterisk circle diagonal cross x displayed marker types centered marker coordinates set marker size setmarkersizescalefactor ms parameter marker size ms assigned positive number scaling parame ter applied nominal size particular marker symbol chosen values greater produce character enlargement values less reduce marker size string left center top cap w voooo ees half ese dase g bottom left right alignment attribute values horizontal vertical strings canter section charac er attributes direction character vector oy lo g text path direction b vector spec fication controls direction text path b b vector produces display fora path display b right path rah ol gnmen center auignment gn tbe aot alig ligure 35 character string alignmenss marker color specified setpolymarkercolourlindex mc selected color cade tor parameter mc stored current attribute list used display subsequently specified marker primitives procedures considered far function references single attribute specifies exactly primitive displayed tribute setting specifications called individual unbundled attrib utes meant used output device capable dis playing primitives way specified application program employing individual attributes interfaced several output devices devices may capability display intended attributes program using individual color attributes example mav modified produce ac ceptable output monochromatic monitor individual attribute commands provide simple direct method specifying attributes single output device used several kinds output devices available graphics installation convenient user able say attributes interpreted different de vices accomplished setting tables output device lists sets attribute values used device display primi tive tvpe particular set attribute values primitive output de vice chosen specifying appropriate table index attributes specified manner called bundled attributes table primitive hat de fines groups attribute values used displaying primitive particular output device 1s called bundle table attributes may bundled workstation table entries involve courdinate specifications color line type choice bundled unbundled specification made setting switch called aspect source flag attributes set individsalasf fattributeptr flagptr parameter attic buteptr points list attributes parameter flagptr points corresponding list aspect source flags aspect source flag assigned value individual bundled attributes may bundled listed following sections bundled lire attributes entries bundle lable line attributes specitied workstation set function setpolylinetepresentation ws li lw lc parameter ws workstation identifier line index parameter 1i defines section bundle table position parameters 1t lw 1c bundled bundled attributes signed values set line type line width line color specifications respec tively designated table index example following statements de fine groups line attributes referenced index number two different workstations setpolyiinerepresentation setpclylinerepresentaticn polyline assigned table index value would displayed using dashed lines half thickness blue color workstation workstation index generates solid standard sized white lines bundle tables set group bundled line attributes chosen workstation specifying table index value setpolylineindex 1i subsequent polyline commands would generate lines worksta tion according set bundled attribute values defined table position specified value line index parameter bundled area fill attributes table entries bundled area fill attributes set setiinteriorrepresentation ws fi fs pi fe defines attribute list corresponding fill index workstation ws parameters fs pi fc assigned values fill style pattern index fill color respectively designated workstation similar bundle tables also set edge attributes polygon fill areas particular attribute bundle selected table func tion setinteriorindex fi subsequently defined fill areas displayed active workstation ac cording table entry specified fill index parameter fi fill area attributes pattern reference point pattern size independent workstation designation set functions previously described bundled text attributes function settextrepresentation ws ti tf tp te ts tc bundles values text font precision expansion factor size color table position workstation ws specified value assigned text index parameter ci text attributes including character vector text path character height text alignment set individually particular text index value chosen function settextindex ti text function invoked displayed workstation set attributes referenced table position bundled marker attrioutes table entries bundled marker attributes set setpolymazkerrepresentation ws mi mt ms mc defines marker type marker scale factor marker color index mi workstation ws bundle table selections made function setpolymarkerindex mi current settings attributes parameters workstation types status system lists retrieved mquiry functions functions allow current values copied specified parameters saved later reuse used check current state system error occurs check current attribute values stating name attribute inquiry function example functions inguirepolvi nelndex lasz1i inguirelinteriorcolourindex lastfc copy current values line index fill color parameters last1i lastfc following program segment illustrates reusing current line type value set lines drawn new line type inquirelinetype aldlt setlincetype newlt setlinetype oldit displayed primitives generated raster algorithms discussed chapter jagged stairstep appearance sampling process digitizes co ordinate points object discrete integer pixel positions distortion information due low frequency sampling undersampling called aliasing improve appearance displayed raster lines applying antialias ing methods compensate undersampling process example effects undersampling shown avoid losing information periodic objects need set sampling fre quency least twice highest frequency occurring object ferred nyquist sampling frequency nyquist sampling rate f f 2fonax another way state sampling interval larger one half cycle interval called nyquist sampling interval x interval sampling nyquist sampling interval ax ax sats axjyce fmax sampling interval one one half times cycle interval sampling interval least three times big want recover object information example need cut sampling interva one third size shown figure one way increase sampling rate raster systems simply display objects higher resolution even highest resolution possible cur rent technology jaggies apparent extent limit big make frame buffer still maintain refresh rate frames per second represent objects accurately continuous para meters need arbitrarily small sampling intervals therefore unless hardware technology developed handle arbitrarily large frame buffers increased screen resolution complete solution aliasing problem nvvma sampling positions ta sampling periodic shape marked positions produces aliased lower frequency b representation b section antialiasing chapter attributes output primitives raster systems capable displaying two intensity levels color gray scale apply antialiasing methods modify pixel tensities appropriately varying intensities pixels along boundaries primitives sinooth edges lessen jagged appearance straightforward antialiasing method increase sampling rate treat ing screen covered finer grid actually available use multiple sample points across finer grid determine appro priate intensity level screen pixel technique sampling object characteristics high resolution displaying results lower resolu tion called supersampling postfiltering since general method involves computing intensities subpixe grid positions combining results obtain pixel intensities displayed pixel positions spots light covering finite area screen infinitesimal mathematical points yet line fill area algorithms discussed intensity pixel de termined location single point object boundary supersam pling obtain intensity information multiple points contribute overall intensity pixel alternative supersampling determine pixel intensity calculat ing areas overlap pixe objects displayed antialias ing computing overlap areas referred area sampling prefiltering since intensity pixel whole determined without calculating sub pixel intensities pixel overlap areas obtained determining object boundaries intersect individual pixel boundaries raster objects also antialiased shifting display location pixel areas technique calied pixel phasing applied microposition ing electron beam relation object geometry supersampling straight line segments supersamp ing straight lines performed several ways gray scale display straight line segment divide pixel number subpixels count number subpixels along line path intensity level pixel set value proportional sub pixel count example method given fig 37 square pixel area divided rine equal sized square subpixels shaded regions show subpixels would selected bresenham algorithm scheme provides three intensity settings zero since maximum nuinber subpixels selected within pixel three exam ple pixel position set maximum ntensity evel pixels set next highest intensity level pix els set lowest intensity zero evel thus line intensity 1s spread greater number pixels stairstep effect smoothed displaying somewhat blurred line path vicinity stair steps horizontal runs want use inten sity levels antialiase line methad increase number sam pling positions across pixel sixteen subpixels gives us four intensity levels zero twenty five subpixels gives us five levels supersampling example considered pixel areas ot fi nite size treated line mathematical entity zero width actu ally displayed lines width approximately equal tha pixel take finite width line account perform supersampling setting pixel intensity proportional number subpixels inside supersampling subpixel positions along straight line segment whose left endpoint screen coordinates polygon representing line area subpixel considered inside line lower left corner inside polygon boundaries advantage supersampling procedure number possible intensity levels pixel equal total number subpixels within pixel area ex ample represent line finite width positioning polygon boundaries parallel line path pixel set one nine possible brightness levels zero another advantage supersampling finite width line total line intensity distributed pixels pixel grid position turned intensity level also pick contributions pixels immediately immediately left posi tion also color display extend method take background colors account particular line might cross several different color areas average subpixel intensities obtain pixel color settings instance five subpixels within particular pixel area determined inside boundaries red line remaining four pixels fall within blue background area calculate color pixel pixel gior red blue trade gains supersampling finite width line identifying interior subpixels requires calculations simply determining subpixels along line path calculations also complicated positioning line boundaries relation line path posi supersampling subpixel positions relation interior line finite width section antialiasing chapter attributes output primitives relative weights grid subpixels tioning depends slope line line line path centered polygon area tor either horizontal vertical line want line path one polygon boundaries instance horizontal line passing grid coordinates would represented polygon bounded horizontal grid lines similarly polygon representing vertical line would vertical boundaries along grid lines x x lines slope mt mathematical line path posi tioned propertionately closer lower polygon boundary lines slope line path placed closer upper polygon boundary pixel weighting masks supersampling algorithms often implemented giving weight sub pixels near center pixel area since would expect subpixels important determining overall intensity pixel pixel subdivisions considered far weighting scheme could used center subpixel weighted four times corner subpixels twice remaining subpixels intensities calculated grid nine subpixels would averaged center subpixel weighted factor top bottom side subpixels weighted factor corner subpixels weighted fac tor 16 atray values specifying relative importance subpixels sometimes referred mask subpixel weights similar masks set larger subpixel grids also masks often extended include con tributions subpixels belonging neighboring pixels su intensities averaged adjacent pixels area sampling straight line segments perform area sampling straight line setting pixel intensity pro portional area overlap pixel finite width line line treated rectangle section line area two adja cent vertical two adjacent horizontal screen grid lines trapezoid overlap areas pixels calculated determining much trape zoid overlaps pixel vertical column horizontal row pixel screen grid coordinates percent coverec line area intensity would set percent maximum ir tensity similarly pixel 21 would set intensity percent maximum method estimating pixel overlap areas illustrated su persampling example total number subpixels within line boundaries approximately equal overlap area estimation im proved using finer subpixel grids color displays areas pixel lap different color regions calculated final pixel color taken average color various overlap areas filtering techniques accurate method antialiasing lines use filtering techniques method similar applying weighted pixel mask imagine con tinuous weighting surface filter function covering pixel shows examples rectangular conical gaussian filter functions methods ap plying filter function similar applying weighting mask integrate pixel surface obtain weighted average intensity lo duce computation table lookups commonly used evaluate integrals pixel phasing raster systems address subpixel positions within screen grid pixel phasing used antialias objects stairsteps along line path ob ject boundary smoothed moving micropositioning electron beam nearly approximate positions specified object geometry systems incorporating technique designed individual pixel positions shifted fraction pixel diameter electron beam typically shifted pixel diameter plot points closer true path line object edge systems also allow size individual pixels ad justed additional means distributing intensities illustrates antialiasing effects pixel phasing variety line paths compensating line intensity differences antialiasing line soften stairstep effect also compensates another raster effect illustrated lines plotted number pixels yet diagonal line longer horizontal line factor v2 visual effect diagonal line appears less bright hori zontal line diagonal line displayed lower intensity per unit length line drawing algorithm could adapted compensate effect adjusting intensity line according slope horizontal verti cal lines would displayed lowest intensity lines would given highest intensity antialiasing techniques applied display common filter functions used antialias line paths volume filter normalized height gives relative weight subpixel position section antialiasing saussian filter c intensities automatically compensated finite width lines taken account pixel intensities adjusted lines display total intensity proportional length antialiasing area boundaries antialiasing concepts discussed lines also applied boundaries areas remove jagged appearance incorporate procedures scan line algorithm smooth area outline area generated system capabilities permit repositioning pixels area boundaries smoothed adjusting boundary pixel positions along line defining area boundary methods adjust pixel intensity bound ary position according percent pixel area inside boundary pixel position x half area inside polygon boundary therefore intensity position would adjusted one half assigned value next position x along boundary tensity adjusted one third assigned value point similar adjustments based percent pixel area coverage applied intensity values aronnd boundary ad abi jagged lines plotted merlin system smoothed b antialiasing technique called pixel phasing technique increases number addressable points system x x courtesy megatek corp unequal length lines displayed number pixels line supersampling methods applied subdividing total area determining number subpixels inside area boundary pixel partition ing four subareas shown original grid pixels turned grid process eight scan lines across grid instead four shows one pixel areas grid overlaps object boundary along two scan lines determine three sub pixel areas inside boundary set pixel intensity percent maximum value another method determining percent pixel area within bound ary developed pitteway watkinson based midpoint line algo tithm algorithm selects next pixel along line determining two pixels closer line testing location midposition two pixels bresenham algorithm set decision parameter p whose sign tells us next two candidate pixels closer line slightly modifying form p obtain quantity also gives percent current pixel area covered object first consider method line slope range straight line path shown pixel grid assuming pixel position x plotted next pixel nearest line x x either pixel one determine pixel nearer calculation ymnia ry b gives vertical distance actual coordinate line halfway point pixels position difference calcula tion negative pixel closer line difference positive vee adjusting pixel intensities along x lael area boundary section antialiasing sqr qr ara ras pixel section raster display subdivided inta grid sean line scan line subdivided pixel area subdivided pixel area three subdivisions inside object boundary line boundary edge area passing pixel grid section pixel closer adjust calculation produces posi tive number range adding quantity p imy bd mm pixel nearer p pixel nearer p il parameter p also measures amount current pixel lapped area pixel x interior part pixel area calculated area mx b expression overlap area pixel x parameter p eq therefore evaluating p determine next pixel po sition along polygon boundary also determine percent area cover age current pixel generalize algorithm accommodate lines negative slopes lines slopes greater calculation parameter p could incorporated midpoint line algorithm locate pixel positions object edge concurrently adjust pixel intensities along boundary lines also adjust calculations reference pixel coordinates lower left coordinates maintain area proportions discussed section 10 polygon vertices skinny polygons shown one boundary edge passing pixel area cases need modify pitteway watkinson algorithm processing edges passing pixel determining correct interior area filtering techniques discussed line antialiasing also applied area edges also various antialiasing methods applied polygon areas regions curved boundaries boundary equations used esti mate area overlap pixel regions area displayed coherence techniques used along scan lines simplify calculations summary chapter explored various attributes control appear ance displayed primitives procedures displaying primitives use attribute settings adjust output algorithms line generation area filling text string displays basic line attributes line type line color line width specifica tions line type include solid dashed dotted lines line color specifica tions given terms rgb components control intensity three electron guns rgb monitor specifications line width given terms multiples standard one pixel wide line attributes applied straight lines curves reduce size frame buffer raster systems use separate color lookup table limits number colors displayed size lookup table full color systems provide bits per pixel separate color lookup table pounder sy mix overlap area pixel rectangle centered position x interior polygon area fill area attributes include fill style mil color fill pattern fill style solid fill color specifies color solid fill polygon interior hollow fill style produces interior background color border fill color third type fill patterned case selected array pattern used fill polygon interior additional fill option provided packages soft fill fill applications antialiasing painting packages soft fill procedures provide new fill color region variations previous fill color one example approach linear soft fill algorithm assumes previous fill linear combination foreground background colors linear relationship determined frame buffer settings used repaint area new color characters defined pixel grid patterns outline fonts dis played different colors sizes orientations set orientation char acter string select direction character vector direction text path addition set alignment text string relation start coordinate position marker symbols displayed using selected characters various sizes colors graphics packages devised handle unbundled bundled attribute specifications unbundled attributes defined one type output device bundled attribute specifications allow different sets attributes used different devices accessed index num ber bundle table bundle tables may installation defined user defined functions set bundle table values specify workstation type attribute list given attribute index determine current settings attributes parameters invoke inquiry functions addition retrieving color attribute infor mation obtain workstation codes status values inquiry func tions scan conversion digitizing process raster systems displayed primitives jagged appearance due undersampling infor mation rounds coordinate values pixel positions improve appearance raster primitives applying antialiasing procedures adjust pixel intensities one method supersample con sider pixel composed subpixels calculate intensity polygons one boundary line passing individual pixel regions chapter attributes output primitives subpixels average values subpixels alternatively perform area sampling determine percentage area coverage screen pixel set pixel intensity proportional percentage also weight subpixel contributions according fo position giving higher weights central subpixels another method antialiasing build special hardware configurations shift pixel positions table lists attributes discussed chapter output primi tive classifications line fill area text marker attribute functions used graphics packages listed category table summary attributes output bundled primitive associated attribute setting attribute type attributes functions functions line type setlinetype setfolylineindex width setlinewidthscalefactor setpolylinerepresentation color setpolylinecolourindex fiil area fill style setinteriorstyle setinteriorindex fill color setinteriorcolorindex setinteriorrepresentation pattern setinteriorstyleindex setpatternrepresentation setpatternsize setpatternreferencepoint text font settextfont settext index color settextcolourindex settextrepresentation size setcharacterheight setcharacterexpansionfactor orientation setcharacterupvector settext path settextalignment marker type setmarkertype set polymarkerindex size setmarkersizescalefactor set polymarkerrepresentation color set polymarkercolour index references calor grayscale considerations discussed crow heckbert soft fill techniques given fishkin barsky antialiasing techniques discussed pitteway watkinson crow turkowski korein badler kirk avro schilling wu attribute functions phigs discussed howard et al hopgood duce gaskins blake information gks workstations attrib utes see hapgood et al enderle kansy pfaff exercises implement line type function modifying bresenham line drawing algorithm display either solid dashed dotted lines 18 20 21 implemeni line type function midporn line algcrithm display either solid dashed dotted lines devise parallel method implementing line type function devise parallel method implementing line width function tine specified two endpoints width converted rectangular poly gon four vertices displayed using scan line method develop effi cient algorithm computing four vertices needed define rectangle using line endpoints line width implement line width function line drawing arogram one three line widths displayed write program output line graph three data sets defined x coor dinate range input program include three sets data values labeling axes coordinates display area screen data sets scaled iit specified area plotted line displayed differert line type solid dashed dotted axes labeled instead changing line type three data sets piotted different colors set algorithm displaying thick tines either butt caps round caps pro jecting square caps options provided option menu devise algorithm displaying thick polylines either miter join round join bevel join options provided option menu implement pen brush menu options line drawing procedure including leasi two options round square shapes madity line drawing algorithm intensity ourput line set according slope adjusting pixel intensities according value slope ines displayed intensity per unit length define tmplement function controlling line type tsolid dashed dotted displayed ellipses define implement function setting width displayed ellipses write routine display bar graph anv spec fied screen area input include data set labeling coordinate axes ths coordinates screen area data set scaled fit designated screen area bars dis played designated colors patterns write procedure display two data sets defined cver x coordinate range data values scaled ft specified region display screen bars one data sets displaced horizontally produce overlapping bar pattern foc easy comparison two sets data ijse different color different fill pattern two sets bars devise algorithm implementing color lookup table set colourrep resentation operation suppose system inch inch video screen display pixels per inch cclor lookup table positions used system smallest possible size bytes frame buffer consider rgb raster system frame buffer bits per pixel color lookup table bits per pixe many distinct gray lev els displayed system b many distinct colors including gray levels displayed c many colors cai displayed one time total memory size e explain two methods reducing memory size maintain ng color capabilities modify scan line algorithm apply specified rectangular fill pattern poly gon interior starting designated pattern position write procedure fill interior given ellipse specified pattern write procedure implement set pat terrrepresentat ion function exercises chapler atuributes output primitives 22 23 24 27 28 23 32 33 34 35 define implement procedure changing size existing rectangular till pattern write procedure implement soft fill algorithm carefully define soft fill algorithm accomplish colors combined devise algorithm adjusting height width haracters defined rectan gular grid patterns implement routines setting character vector text path controlling display character strings write program align text specified input values alignment parame ters develop procedures jor implementing marker attribute functions compare attribute implementation procedures needed systems employ bun dled attributes needed systems using unbundicd attributes develop procedures storing accessing attributes unbundled system attribute tables procedures designed store designated attribute values system tables pass attributes appropriate output routines pass attrrb utes memory locations specified inquiry commands set procedures described previous exercise bundled system tribute tables implement antialiasing procedure extending bresenham line algorithm ad pixel intensities vicinity line path implement antialiasing procedure far midpoint line algorithm develop algorithm antialiasing elliptical boundaries modify scan line algorithm area fill ta incorporate antialiasing use coherence techniques reduce calculations successive scan lines write program implement pitteway watkinson artialiasing algorithm scan line procedure fill polygon interior use routine setpixel x intensity load intensity value frame buffer location x chapter two dimensional geometric transformations final position ew rf ra ee w ith procedures displaying output primitives attributes create variety pictures graphs many applications also need altering manipulating displays design applications facility layouts created arranging orientations sizes component parts scene animations produced moving camera objects scene along animation paths changes orientation size shape accomplished geometric transformations alter coordinate descriptions objects basic geometric transformations trans lation rotation scaling transformations often applied ob jects include reflection shear first discuss methods performing geo metric transformations consider transformation functions incorporated graphics packages first discuss general procedures applying translation rotation scaling parameters reposition resize two dimensional objects section consider transformation equations expressed convenient matrix formulation allows efficient combination object transformations translation translation applied object repositioning aiong straight line path one coordinate location another translate two dimensional point adding translation distances original coordinate position x move point new position x xo axtt v ytt translation distance pair called translation vector shift vector express translation equations single matrix equation using column vectors tc represent coordinate positions translation vec tor p p et xx xx ty allows us write two dimensional translation equations matrix form p p sometimes matrix transformation equations expressed terms coordinate row vectors instead column vectors case would write matrix representations p x since column vector representa tion point standard mathematical notation since many graphics packages example gks phigs also use column vector representa tion follow convention translation rigid body transformation inoves objects without defor mation every point object translated amount straight line segment translated applying transformation equation line endpoints redrawing line new endpoint po sitions polygons translated adding translation vector coordinate position vertex regenerating polygon using new set vertex coordinates current attribute settings illustrates applica tion specified translation vector move object one position similar methods used translate curved objects change position circle ellipse translate center coordinates redraw figure new location translate curves example splines displacing coordinate positions defining objects reconstruct curve paths using translated coordinate points yo att h h moving polygon position 10 20 position b translation ib vector 50 75 translating point position p position p translation vector rotation object angle pivot point x rotation point position x position x angle telative coordinate origin original angular displacement point x axis rotation two dimensional rotation applied object repositioning along cir cular path xy plane generate rotation specify rotation angle position x rotation point pivot point ob ject rotated positive values rotation angle define coun terclockwise rotations pivot point negative values rotate objects clockwise direction transformation alsa de scribed rotation rotation axis perpendicular xy plane passes pivot point first determine transformation equations rotation point posi tion p pivot point coordinate origin angular coordi nate relationships original transformed point positions shown figure r constant distance point origin angle original angular position point horizontal ro tation angle using standard trigonometric identities express trans formed coordinates terms angles x rcos rcos cos rsindsin rsin rcos sin rsin dos original coordinates point polar coordinates x rcos versing substituting expressions obtain transformation equations rotating point position x angle origin x xcos ysin xsind ycos column vector representations coordinate positions write rotation equations matrix form p r p rotation matrix cos sin sin cos coordinate positions represented row vectors instead af col umn vectors matrix product rotation equation transposed go transformed row coordinate vector x calculated pt r p pr r p x transpose r matrix r obtained interchanging rows columns rotation matrix transpose obtained simply changing sign sine terms rotation point arbitrary pivot position illustrated using trigonometric relationships figure generalize eqs obtain transformation equations rotation point specified ro tation position x x x v x cos sin wiry g v sin yy cos general rotation equations differ eqs inclusion additive terms well multiplicative factors coordinate values thus matrix expression could modified include pivot coordinates matrix addition column vector whose elements contain additive translational terms eqs better ways however formulate matrix equa tions discuss section consistent scheme representing transformation equations translations rotations rigid body transformations move objects without deformation every point object rotated angle straight line segment rotated applying rotation equations line endpuints redrawing line new end point positions polygons rotated displacing vertex speci fied rotation angle regenerating polygon using new vertices curved lines rotated repositioning defining points redrawing curves circle cllipse instance rotated noncentral axis mov ing center position subtenas specified rotation angle ellipse rotated center coordinates rotating major minor axes sealing scaling transformation alters size object operation car ried polygons multiplying coordinate values x vertex scaling factors produce transformed coordinates x nos xx yorysy 10 scaling factor scales objects x direction scales direction transformation equations 10 also written matrix form iy e 11 p p 12 scaling matrix eq 11 positive numeric values assigned scaling factors values less reduce size objects values greater produce en largement specifying value leaves size objects un changed assigned value uniform scaling pro section basic transformations igure rotating point position x position ix angle rotation point x chapter two dimensional geometric transformations b turning square rectangle b scaling factors 2ands line scaled eq 12 using reduced size moved closer coordinate ongin pp scaling relative chosen fixed point distances polygon vertex fixed point scaled transformation equations 13 duced maintains relative object proportions unequai values sult differential scaling often used design applications pic tures constructed fram basic shapes adjusted scaling positioning transformetions objects transformed eq 11 scaled repositioned scaling factors values less move objects closer ta coordinate origin values greater move coordinate positions farther origin figure illustrates scaling line assigning value toa sy eq 11 line length distance origin reduced factor control location scaled object choosing position called fixed point remain unchanged scaling transformation co ordinates fixed point x chosen one vertices object centroid position polygon scaled relative fixed point scaling distance vertex fixed point ver tex coordinates x scaled coordinates x calculated xi say x xpsy yy ly ups 13 rewrite scaling transformations separate multiplicative additive terms xo x a1 14 yo yes yl sy additive terms x constant points object including coordinates fixed point scaliny equations similar including coordinates pivot point rotation equations set column vector whose elements constant terms eqs 14 add column vector product p eq 12 next section discuss matrix formulation transformation equations involves matrix multiplication polygons scaled applying transformations 14 vertex regenerating polygon using transformed vertices objects scaled applying scaling transformation equations parameters defin ing objects ellipse standard position resized scaling semima jor semiminor axes redrawing ellipse designated center co ordinates uniform scaling circle done simply adjusting radius redisplay circle center coordinates using transformed radius coordinates many graphics applications involve sequences geometric transformations animation example might require object translated rotated increment motion design picture construction applications perform translations rotations scalings fit picture components proper posihons consider matrix representations dis cussed previous sections reformulated transformation sequences efficiently processed seen section basic transformations ex pressed general matrix form p p 15 coordinate positions p p represented column vectors matrix isa array containing multiplicative factors two element column matrix containing translational terms translation mj identity matrix rotation scaling contains translational terms associated pivot point sealing fixed point produce sequence transformations equations scaling followed rotation translation must calculate transformed coordinates one step time first coordinate posi tions scaled scaled coordinates rotated finally rotated coordinates translated efficient approach would combine transformations final coordinate positions obtained directly initial coordinates thereby eliminating calculation intermediate coordi nate values able need reformulate eq 15 eliminate matrix addition associated translation terms mp combine multiplicative translational terms two dimen sional geometric transformations sing e matrix representation expand ing matrix representations matrices allows us express transformation equations matrix multiplications providing also ex pand matrix representations coordinate positions express two di mensional transformation matrix multiplication represent cartesian coordinate position gr homogeneous coordinate triple x yy fi yooh ya hus gencral homogeneous coordinate representation also written h x ay h two dimensional geometric transformations choose ho mogeneous parameter h nonzero value thus infinite num ber equivalent homogeneous representations coordinate point x convenient choice simply set h two dimensional position represented homogeneous coordinates x values parameter needed example matrix formulations three dimensioral viewing transformations term omogeneous courdmatrs used mathematics refer ef tect representation cartesian equations cartesian point x converted homogeneous representation x yy equations containing x ffx become homogeneous equations three parame lers x h means three parameters replaced value v times parameter value factored equa tions expressing positions homogeneous coordinates allows us represent geometric transformation equations matrix multiplications coordinates section matrix representations 4omageneous coordinates chapter two dimensional geometric transformations represented three element column vectors transformation operations written matrices translation x f x yypato 17 00 write abbreviated form p tct p 18 translation matrix eq 17 inverse trans lation matrix obtained replacing translation parameters negatives similarly rotation transformation equations coordinate origin written x cos sind x j sing cos 19 1yqi p r p 20 rotation transformation operator r 1s matrix eq 19 rotation parameter get inverse rotation matrix replaced finally scaling transformation relative coordinate ongin ex pressed matrix multiplication x 90 yi 21 oc p sis p 22 matrix eq 21 parameters replac ing parameters multiplicative inverses yields inverse scaling matrix matrix representations slandard methods implementing transforma tions graphics systems many systems rotation scaling functions pro duce transformations respect coordinate origin eqs 19 21 rotations scalings relative reference positions handled succession transformation operations alternate approach graphics package provide parameters transformation functions scaling fixed point coordinates pivot point coordinates general rotation scaling matrices include pivot fixed point set directly without need invoke succession transformation functions matrix representations previous section set matrix sequence transformations composite transformation matrix calculating matrix product individual transformations forming prod ucts transformation matrices often referred concatenation compo sition matrices column matrix representation coordinate positions form composite transformations multiplying matrices order right left successive transformation matrix premultiplies product preceding transformation matrices translations two successive translation vectors f ty applied coordi nate position p final transformed location p calculated phe tila ta atc ty pi ty ta tay tat p p p represented homogeneous coordinate column vectors verify resujt calculating matrix product two associative groupings also composite transformation matrix sequence trans lations te ty 00 ty te ty ty f fo tatty c0 ot x ty tet fed thy te fi fy 25 demonstrates two successive translations additive rotations two successive rotations applied point p produce transformed position p r r p r robe p 20 multiplying two rotation matrices verify two successive rota tions additive r r g rca ey 275 final rotated coordinates calculated composite rotation matrix p r p 28 section composite transformations chapter two dimensional geometric transformations x scalings concatenating transformation matrices two successive scaling operations pro duces following composite scaling matrix s2 sx sx sg sy sy sp 29 ee s2 sy2 sey sp sx1 sens sy1 sya 30 resulting matrix case indicates successive scaling operations multiplicative triple size object twice succes sion fina size would nine times original general pivot point rotation graphics package provides rotate function revolving objects coordinate origin generate rotations selected pivot point x performing following sequence translate rotate translate operations translate object pivot point position moved coordi nate origin rotate object coordinate origin translate object pivot point returned original posi tion transformation sequence illustrated composite transforma ate yel fb c id original powinwn tranelateon rotaton transition object object object pivot point pivot point origin pivot point ox b ts retumed origin position x transformation sequence rotating object specified pivot point using rotation matrix r transformation 19 tion matrix tlus sequence obtained concatenation section composite transformations x cos sin 0o x yy sine cos co 90 1 06 l cosf sin x1 cos sin sind cos vil cos x sin 3h expressed form tix uy rco x rg 32 x x general rotate function set ac cept parameters pivot point coordinates well rotation angle generate automatically rotation matrix eq 31 general fixed point scaling illustrates transformation sequence tc produce scaling respect ta selected fixed position using scaling function scale rela ive coordinate origin translate object fixed point coincides coordinate origin seale object respect coordinate origin use inverse translation step return object original posi tion concatenating matrices three operations produces required scal ing matrix x x x ool sy q sy yl sy 331 1 oc 1 thy p sls tx yy sc sy transiormation automatically generated systems provide scale function accepts coordinates fixed point general scaling directions parameters scale objects along x directions scale ob ject directions rotating object align desired scaling direc tions coordinate axes applying scaling transformation suppose want apply scaling factors values specified parame ters directions shown ta accomplish scaling ix vy tat ibe 1c ids ongmal poston transiate object scale object translate object object fixed point respect thot fixed point fixed point x te origin origin ta returned pasition x transformation sequence scaling object respect specified fixed position using scaling matrix transformation 21 scaling parameters applied orthogonal directions defined angular displacement changing orientation object first perform rotation directions coincide x axes respectively scal ing transformation applied followed opposite rotation return points original orientations composite matrix resulting product three transformations r rca cos sin cos 6sin ss cos sin sin cos 35 example scaling transformation turn unit square parallelogram stretching along diagonal rotate diagonal onto axis double length transforma tion parameters eq 35 assumed scaling performed relative ori gin could take scaling operation one step concatenate matrix translation operators composite matrix would include parameters specification scaling fixed position concatenation properties matrix multiplication associative three matrices b c trix product b c performed first multiplying b first multiplying b c b c b c b 36 therefore evaluate matrix products using either left right right left associative grouping hand transformation products may commutative matrix product b equal b general means want wu e ool fal tbl square converted parallelogram b using composite transformation matrix 35 translate rotate object must careful order composite matrix evaluated special cases se quence transformations kind multiplication transforma tion matrices commutative example two successive rotations could performed either order final position would commu tative property holds also two successive translations two successive scal ings another commutative pair operations rotation uniform scaling general composite transformations computational efficiency general two dimensional transformation representing combination trans lations rotations scalings expressed x 1s tsyy ets x nn sy ts 37 1 four elements rs multiplicative rotation scaling terms transfor mation involve rotation angles scaling factors elements frs irs translational terms containing combinations translation distances pivot point fixed point coordinates rotation angles scaling parame ters example object scaled rotated centroid coordi nates x translated values elements composite transformation matrix tey fy roc yor sog yer ser sy cos6 sin x cos ys sin sin sycos cos x sin ty 38 although matrix equation 37 requires nine multiplications six addi tions explicit calculations transformed coordinates section composite transformations chapter two dimensional geometric transformations ca se v final final position position res cy oo poet tii4 eee b reversing order sequence transformations 1s performed may affect transformed position object object first translated rotated b object rctated first translated xs xs aw ps yt etsy yofxy ty ts ersy thus actually need perform four multiplications four additions transform coordinate positions maximum uumber computations required transformation sequence individual matrices concatenated elements composite matrix evaluated without concatenation indiv dual transformations would applied one time number calculations could significantly increased efficent im plementation transformation operations therefore tv formulate trans formation matrices concatenate transformation sequence calculate transformed coordinates using eq 39 parallel systems direct matrix multr plications w th composite transformation matrix ec 37 equally ef ficient general rigid body transformation matrix involving translations rotations expressed form pe vy ir 4en aly thy oo four elements r multiplicative rotation terms elements tr tr translational terms rigid body change coordinate position also sometimes referred rigid motion transformation angles dis tances coordinate positions unchanged transformation ad dition matrix 40 property upper left bv submatrix thogonal matrix means consider row submatrix vector two vectors ry form orthogonal set unit vectors vector unit length boa pk pk ra try eri tea u hy te vectors perpendicular dot product kalyx taylry g therefore unit vectors transformed rotation submatrix r psy converted unit vector along x axis r ry transformed unit vector along axis coordinate system te ty nyy ty ty try 43 1 hy ty ty yz tw ol ry pall 44 1 example following rigid body transformation first rotates object angle pivot point x translates rex cos sin x cos sin ty sin cos cos6 x sin ty 45 orthogonal unit vectors upper left submatrix cos sin sin cos cos sin cos sin cos sn 46 1 similarly unit vector sin cos converted transformation matrix eq 46 unit vector direction orthogonal property rotation matrices useful constructing ro tation matrix know final orientation object rather amount angular rotation necessary put object position direc tions desired orientation object could determined align ment certain objects scene selected positions scene shows object aligned unit direction vectors u v suming original object orientation shown aligned coordinate axes construct desired transformation assigning elements u first row rotation matrix elements v second row convenient method obtaining transforma tion matrix rotation within local object coordinate system know final orientation vectors similar transformation conversion object descriptions one coordinate system another section consider set transformations accomplish coordinate conversion since rotation calculations require trignometric evaluations several multiplications transformed point computational efficiency become important consideration rotation transformations animations applications involve many repeated transformations small rotation gles use approximations iterative calculations reduce computa section composite transformations chapter two dimensional geometric transformations rotation matrix revolving object position ta position b constructed values cf unit orientation vectors u v relative original orientation tions composite transformation equations rotation angle small trigonometric functions replaced approximation values based first terms power series expansions small enough angles less cos approximately sin value close value radians f rotating small angular steps ori gin instance set cos reduce transformation calculations step two multiplications two additions set coordinates rotated xo x ysing xsin 47 sin evaluated steps assuming rotation angle nat change error introduced approximation step decreases rotation angle decreases even small rotation angles accumulated error many steps become quite large control accumulated error estimating error x step resetting object posi tions error accumulation becomes great composite transformations often involve inverse matrix calculations trans formation sequences general scaling directions reflections shears section example described inverse rotation components noted inverse matrix representations basic geometric frans formations generated simple procedures inverse translation trix obtained changing signs translation distances inverse rotation matrix obtained performing matrix transpose changing sign sine terms operations much simpler direct inverse matrix calculations implementation composite transformations given following procedure matrix initialized identity matrix individual transformation specified concatenated total transformation trix transformations specified composite transforma tion applied given object example polygon scaled rotated given reference point object translated shows original final positions polygon transformed sequence section composite transformations 100 200 x 100 200 x oj polygon transformed b composite operations following procedure include math h include graphics h typedef float matrix3x3 matrix3x3 thematrix void matrix3x3setidentity matrix3x3 int j j j il j gi multiplies matrix times b putting result b void matrix3x3premultiply matrix3x3 matrix3x3 b int r c matrix3x3 tmp ry r r c c c ht tmp r ic afr bl c afr bll fic alr bl2 fel r x r c c b rife tmp r cl void translate2 int tx int ty matrix3x3 matrix3x3settdentity oj tx mf1 ty matrix3x3premultiply thematrix void scale2 loat sx oat sy wept refpt matrix3x3 matrix3x3secidentity sx sx refpt x l sy sy refpt matrix3x3premultiply thematrix void rotate2 float wcept2 refpr matrix3x3 matrix3x3setidentity ptoradians q o01 cosf sint refppt x cosf refpt sinf sinf cost z refpt cosf refpt x sinf matrix3x3premu tiply thematrix void transfurmpoints2 int npts wept2 pts int k float tmp k k npts k tmp cthoematrix pts k x thematrix pts k thematrix prs k thematrix pts x x thematrix pts k uhematrix pts k x tmp void main int arge char argv c wept2 pts wept2 refpt long windowin opengraphics azgv setbacxground white setcolor blue pfillarea pts matrix3x3setiidentity thematrix scalez refpt rotate2 refpt translate2 transformpoints2 pts pfillaarea pts sleep closegraphics windowid basic transformations translation rotation scaling included graphics packages packages provide additional transforma tions useful certain applications two transformations reflec tion shear reflection reflection transformation produces mirror image object mirror image two dimensional reflection generated relative axis reflection rotating object reflection axis choose axis reflection xy plane perpendicular xy plane flection axis line xy plane rotation path axis plane perpendicular xy plane reflection axes perpendicular xy plane rotation path xy plane following examples com mon reflections reflection line x axis accomplished transfor mation matrix 0 48 transformation keeps x values flips values coordi nate positions resulting orientation object reflected x axis shown envision rotation transformation path reflection think flat object moving xy plane rotating three dimensional space x axis back xy plane side x axis reflection axis flips x coordinates keeping coordinates matrix transformation 01 49 illustrates change position object reflected line x equivalent rotation case three di mensional space axis flip x coordinates point reflecting relative axis perpendicular xy plane passes coordinate origin transformation referred reflection relative coordinate origin matrix representation 50 section transformations original position reflected position reflection object x axis original reflected position pasition py reflection object axis reflected position v ed x xn md original position reflection object relative axis perpendicular ry plane passing coordinate origin original position ro py sea reflected pos tion f reflection object respect line x pra aa ween eee o71 jz e ee xap x reflection object relative axis perpendicular xy plane passing point p example reflection origin shown reflection trix 50 rotation matrix r simply rotating ob ject ry plane half revolution origin reflection 50 generalized reflection point xy plane reflection rotation xy plane using reflection point pivot point chase reflection axis diagonal line x flection matrix ors eou oo ey derive matrix concatenating sequence rotation coordi nate axis reflection matrices one possible sequence shown first perform clockwise rotation angle rotates line x onto x axis next perform reflection respect x axis final step rotate line x back original position counter clockwise rotation equivalent sequence transformations first reflect object x axis rotate counterclockwise obtain transformation matrix reflection diagonal x could concatenate matrices transformation sequence clockwise ro tation reflection axis counterclockwise rotation resulting transformation matrix qo 0 32 shows original final positions object transformed section reflection matrix transformations reflections line mx xy plane accomplished combination translate rotate reflect transformations general first translate line passes origin rotate line ne onto one coordinate axes reflect axis finally restore line original position inverse rotation translation transforma tions implement reflections respect coordinate axes coordi nate origin scaling transformations negative scaling factors also ele ments reflection matrix set values values whose magnitudes greater shift mirror image farther reflection fa axis values magnitudes less bring mirror image closer reflection axis shear transformation distorts shape object transformed __ shape appears object composed internal layers caused slide called shear two common shearing transfor gg mations shift coordinate x values shift values x direction shear relative x axis produced transforma tion matrix 10 53 ov transforms coordinate positions x x sh yay 54 c real number assigned shear parameter sh coordinate posi poe tion x shifted horizontally amount proportional distance sequence transformations value x axis setting sh example changes square produce reflection parallelogram negative values sh shift coordinate positions line x cleckwise left rotation b reflection generate x direction shears relative reference lines x axisrand c counterclockwise rotation sh shy yet 55 60 coordinate positions transformed x x shy yres yoy 56 example shearing transformation given shear para meter value relative line reflected position original position reflection respect line x bd unit square converted parallelogram b using x direction shear matrix 53 sh direction shear relative line x formation matrix xi generated trans sh shy xyep 57 generates transformed coordinate positions wos x yl sh kx xe 58 transformation shifts coordinate position vertically amount propor tional distance reference line x x illustrates conversion square parallelogram sh x shearing operations expressed sequences basic transformations x direction shear matrix 53 example written composite transformation involving series rotation scaling matrices would scale unit square along diagonal maintaining origi nal lengths orientations edges parallel x axis shifts positions objects relative shearing reference lines equivalent translations yar yer b unit square transformed toa shifted parallelogram b sh q 1in shear matrix 55 a1 xy x ng ea x b unit square turned shifted parallelogram b parameter values sh x direction using shearing transformation 57 graphics applications often require transformation object descriptions one coordinate system another sometimes objects described non cartesian reference frames take advantage object symmetries coordinate descriptions systems must converted cartesian device coordi nates display examples two dimensional non cartesian systems polar coordinates elliptical coordinates parabolic coordinates cases need transform two cartesian systems modeling design applications individual objects may defined local carte sian references local coordinates must transformed position objects within overall scene coordinate system facility management program tor office layouts instance individual coordinate reference de scriptions chairs tables furniture placed floor plan multiple copies chairs iterns different positions applications may simply want reorient coordinate reference displaying scene relationships cartesian reference systems esmmon non cartesian systems given appendix consider transformations two cartesian frames reference shows two cartesian systems coordinate origins xo yo orientation angle x x axes trans form object descriptions xy coordinates x coordinates need set transformation superimposes x axes onto xy axes done two steps translate origin p yg x system moved origin xy system rotate x axis onto x axis translation coordinate origin expressed matrix operation qo x yo 59 061 section transformations coordinate systems chapter two dimensional geometric transformations cartesian x system positioned xp yp orientation xy cartesian system orientation two systems translation operation would ap pear get axes two systems coincidence perform clockwise rotation cos sin r sin cos 60 concatinating two transformations matrices gives us complete compos ite matrix transforming object descriptions ry system x sys tem myyry r xo yo 61 alternate method giving orientation second coordinate sys tem specify vector v indicates direction positive axis shown vector v specified point xy reference frame rela tive origin xy system unit vector direction obtained al v uy en ny obtain unit vector u along x axis rotating v clockwise u yy v u 63 position reference frames shown translating origin x system coordinate origin xy system x axis cartesian system x origin py xa yo axis parallel vector v section noted elements rotation matrix could ex pressed elements set orthogonal unit vectors therefore matrix rotate xy system coincidence xy system written uy uy r vy 64 example suppose choose orientation axis v x axis positive direction rotation transformation trix oro oo equivalently obtain rotation matrix 60 setting orienta tion angle interactive application may convenient choose direc tion v relative position py specifv relative ry coordi nate origin unit vectors u v would oriented shown components v calculated pi po v lp pol 65 u obtained perpendicular v forms right handed cartesian system axis cartesian x system defined two coordinate positions py p within sy reference frame section transformations coordinate systems chapter two dimensional geometric transformations coordinate transformation form x ax ayy b ay x ayy 66 called two dimensional affine transformation transformed coor dinates x linear function original coordinates x para meters constants determined transformation type affine transformations general properties parallel lines transformed parallel lines finite points map finite points translation rotation scaling reflection shear examples two di mensional affine transformations general two dimensional affine transfor mation always expressed composition five transformations another affine transformation conversion coordinate descriptions one reference system another described combination translation rotation affine transformation involving rotation trans lation reflection preserves angles lengths well parallel lines three transformations lengths angle two lines remains transformation graphics packages structured separate commands provided user basic transformation operations procedure trans formobject composite transformation set referencing individ ual functions order required transformation sequence alternate formulation provide users single transformation function cludes parameters basic transformations output func tion composite transformation matrix specified parameter values options useful separate functions convenient simple transforma tion operations composite function provide expedient method specifying complex transformatian sequences phigs library provides users options individual commands generating basic transformation matrices translate trans atevector matrixtrans ate rotate theta matrixrotate scale scalevector matrixscale hach functions produces transformation matrix used transform coordinate positions expressed homogeneous column vec tors parameter translatevector pointer pair translation dis tances similarly parameter scalevector specifies pair scaling values rotate scale matrices matrixtranslate matrix scale transform respect coordinate origin concatenate transformation matrices previously set function composematrix matrix2 matrixl matrixout elements composite output matrix calculated postmultiply ing matrix2 matrix composite transformation matrix perform com bination scaling rotation translation produced function buildfransformationmatrix referencepoint translatevector theta scalevector matrix rotation scaling carried respect coordinate position speci fied parameter referencepoint order transformation sequence assumed scale rotate translate elements composite transformation stored parameter matrix use function generate single transformation matrix composite matrix two three transformations order stated could generate translation matrix setting scalevector theta assigning x shift values parameter translatevector coordinate values could assigned pa rameter referencepoint since transformation calculations unaffected parameter scaling rotation takes place want set translation matrix use function translate simply specify translation vector rotation scaling transformation matrix specified setting translatevector assigning appropriate values parame ters referencepoint theta scalevector obtain rotation matrix set scalevector scaling set theta want rotate scale respect coordinate origin simpler set matrix using either rotate scale function since function buildtransformationmatrix always generates transformation sequence order scale rotate translate fol lowing function provided allow specification sequences composetransformationmatrix matrixin referencepoint translatevector theta scalevector matrixout use function combination buildtransformationma trix function matrix construction functions compose transformation sequence example could set scale matrix fixed point bui ldtransformat ionmatrix function could use composetransformationmatrix function concatenate scale matrix rotation specified pivot point composite rotate scale sequence stored matrixout set transformation matrix apply matrix individual coordinate positions object function transformpoint inpoint matrix outpoint parameter inpoint gives initial xy coordinate position object point parameter point contains corresponding transformed coordi nates additional functions discussed chapter available performing two dimensional modeling transformations section transformation functions chapter two dimensional geometric transformations translating object screen position position b moving rectangular block pixel values coordinate positions p p specify limits rectangular block moved p destination reference posiion particular capabilities raster systems suggest alternate method transforming objects raster systems store picture information pixel patterns frame buffer therefore simple transformations carried rapidly simply moving rectangular arrays stored pixel values one lo cation another within frame buffer arithmetic operations needed pixel transformations particularly efficient raster functions manipulate rectangular pixel arrays generally ferred raster ops moving block pixels one location another also called block transfer pixel values bilevel svstem operation called bitblt bit block transfer particularly function hardware implemented term pixbit sometimes used block transfers multi level systems multiple bits per pixel illustrates translation performed block transfer raster area bit settings rectangular area shown copied block part raster accomplish translation bv first reading pixel tensities specified rectangular area raster array copy array back raster new location original object could erased filling rectangular area background intensity assuming object overlap objects scene typical raster functions often provided graphics packages copy movea pixel block one raster area another read save pixel block designated array write transfer pixel array position frame buffer implementations provide options combining pixel values replace made pixel values simply transfered destination positions op tions combining pixel values include boolean operations aid exclte sive binary arithmetic operations exclusive mode two succes sive copies block raster area restores values originally present area technique used move object across scene without destroying background another option adjusting pixel values combine source pixels specified mask allows selected positions within block transferred shaded patterns defined mask 12014 3 93 7 6 1 10 b c rotating array pixel values original array orientation 1s shown array orientation counterclockwise rotation shown b array orientation rotation shown __ destination rotated pixel areas pixel array destination pixel array raster rotation rectangular block pixels accomplished mapping destination pixel areas onto rotated block rotations degree increments easily accomplished black trans fers rotate object counterclockwise first reversing pixel val ues row array interchange rows columns rota tion obtained reversing order elements row array reversing order rows demonstrates array manipu lations necessary rotate pixel block array rotations multiples must perform computations general procedure illustrated destination pixel area mapped onto rotated array amount overlap rotated pixel areas calculated intensity destination pixel computed averaging intensities overlapped source pixels weighted percentage area overlap raster scaling block pixels analogous cell array mapping discussed section 13 scale pixel areas original block using specified values map scaled rectangle onto set destina tion pixels intensity destination pixel assigned according area overlap scaled pixel areas poteet ty 1 b 4___ destination pixel array b ju 74 bbb trot ett scaled array eta x mapping destination pixel areas onto scaled array pixel values scaling factors applied relative fixed point x section raster methods transformations chapter two dimensional geometric transformations summary basic geometric transformations translation rotation scaling trans lation moves object straight line path one position another rota tion moves object one position another circular path around specified pivot paint ratation point scaling changes dimensions object relative toa specified fixed point express two dimensional geometric transformations trix operators sequences transformations concatenated single composite matrix efficient formulation since allows us duce computations applying composite matrix initial coordinate po sitions object obtain final transformed positions also need express two dimensional coordinate positions three element column row matrices choose column matrix representation coordinate points standard mathematical convention many graph ics packages also follow convention two dimensional transformations coordinate positions represented three element nomogeneous coor dinates third homogeneous coordinate assigned value composite transformations formed multiplications combina tion translation rotation scaling matrices use combinations translation rotation animation applications use combinations rotation scaling scale objects specified direction general trix multiplications commutative obtain different results exam ple change order translate rotate sequence transformation se quence involving translations rotations rigid body transformation since angles distances unchanged also upper left submatrix rigid body transformation orthogonal matrix thus rotation matrices formed setting upper left submatrix equal elements two orthogonal unit vectors computations rotationg transformations duced using approximations sine cosine functions rata tion angle small many rotational steps however approximation error accumulate significant value transformations include reflections shears reflections trans formations rotate object reflection axis produces mir ror image object respect axis reflection axis per pendicular xy plane reflection obtained rotation xy plane reflection axis xy plane reflection obtained rotation ina plane perpendicular xy plane shear transformations distort shape object shifting x coordinate values amount proportional coordinate distance shear reference line transformations cartesian coordinate systems accomplished sequence translate rotate transformations one way specify new co ordinate reference frame give position new coordinate origin direction new axis direction new x axis obtained rotating direction vector clockwise coordinate descriptions objects old reference frame transferred new reference transforma tion matrix superimposes new coordinate axes onto old coordinate axes transformation matrix calculated concatentation translation moves new origin old coordinate origin rotation align two sets axes rotation matrix obtained unit vectors x directions new system two dimensional geometric transformations affine transformations expressed linear function coordinates x affine transformations transform parallel lines parallel lines transform finite points finite points geometric transformations involve scaling shear also preserve angles lengths transformation functions graphics packages usually provided translation rotation scaling functions include individual proce dures creating translate rotate scale matrix functions generating composite matrix given parameters transformation sequence fast raster transformations performed moving blocks pixels avoids calculating transformed coordinates object applying scan conversion routines display object new position three common raster operations bitblts pixblts copy read write block pixels moved new position frame buffer simply replace old pixel values combine pixel values using boolean arithmetic operations raster translations carried copying pixel block new location frame buffer raster rotations multiples obtained manipulating row column positions pixel values block rotations performed first mapping rotated pixel areas onto destination po sitions frame buffer calculating overlap areas scaling raster trans formations also accomplished mapping transformed pixel areas frame buffer destination positions references additional information homogeneous coordinates computer graphics see blinn transformation functions phigs discussed hopgood duce oward et al gaskins blake information gks transformation func tions see hopgood et al enderle kansy pfaff exercises write program continuously rotate object pivot point small angles used successive rotation approximations sine cosine functions used speed calculations rotation angle step chosen object makes one complete revolution less sec onds avoid accumulation coordinate errors reset original coordinate values object start new revolution show composition two retations additive concatinating matrix representations r r obtain r r g rg write set procedures implement buildtrans format ionmatrix composetransformationmatrix functions produce composite transforma tion matrix set input transformation parameters write program applies specified sequence transformations displayed object program designed user selects transformation se quence associated parameters displayed menus composite transfor exercises chapter two dimensional geometric transforma ons ni oo oo eva mation calculated used transform object display original object transformed object different colars different fill patterns modily transformation matrix 35 scaling arbitrary direction clude coordinates specified scaling fixed point x prove multiplication transformation matrices tor following se quence operations commutative two successive rotations b two successive trans ations c two successive scatings prove uniform scaling rotatior form commutative pair opera tions general scaling rotation commutative operations multiply individual scale rotate translate matrices eq 38 verify el ements composite transformation matrix show transformation matrix 51 fora reflection line x equiva lent reflection relative x axis followed counterclockwise rotation show transformation matrix 52 reflection line x equivalent reflection relative axis followed counterclockwise rotation show two successive reflections either coordinate axes equivalent single rotation caordinate origin determine form transformation matrix reflection arbitrary line equation mx b show two successive reflections line passing coordinate origin 1s equivalent single rotation origin determine sequence basic transformations equivalent x direction shearing matrix 53 determine sequence basic transformations equivalent direction shearing matrix 571 set shearing procedure display italic characters given vector font definitior afl character shapes font defined straight line segments italic characters formed shearing transformations determine appropriate value shear parameter comparing italics plain text available font define simple vectar fon input routine derive following equations transforming coordinate point p x yi one cartesian system ta coordinate values x yin another cartesian system thal ro tated angle project point p onto four axes analyse resulting right triangles x xcos ysin xsin vcos write procedure compute elements matrix transforming object de scriptions one cartesian coordinate system another second coordinate system defined origin point py vectar v gives directian positive axis system set procedures implementing block transfer rectangular area frame buffer using onc function read area array another function cop array designated transfer area determine results performing two successive block transfers area frame buffer using various boolean operations results performing two successive block transfers area frame buffer using binary arithmetic operations implement routine perform block transfers trame bulier using specified boolean operation replacement copy operation 23 write routine implement rotations increments frame buffer block transfers exercises 24 write routine implement rotations specified angle frame buffer block transier 25 write routine implement scaling raster transformation pixel block chapter two dimensional viewing viewing coordinate window normalized space viewport l ws2 ny window zt ws ws1 viewport window ws2 viewport monitor monitor w e consider formal mechanism displaying views picture output device typically graphics package allows user specify part defined picture displayed part placed display device convenient cartesian coordinate system referred world coordinate reference frame used define pic ture two dimensional picture view selected specifying subarea total picture area user select single area display several areas could selected simultaneous display animated panning sequence across scene picture parts within selected areas mapped onto specified areas device coordinates multiple view areas selected areas placed separate display locations areas could serted larger display areas transformations world device co ordinates involve translation rotation scaling operations well proce dures deleting parts picture outside limits selected display area world coordinate area selected display called window area ona display device window mapped called viewport window defines viewed viewport defines displayed often windows viewports rectangles standard position rec tangle edges parallel coordinate axes window viewport geome tries general polygon shapes circles used applications shapes take longer process general mapping part world coordinate scene device coordinates referred viewing transfor mation sometimes two dimensional viewing transformation simply ferred window viewport transformation windowing transformation general viewing involves transformation win dow viewport illustrates mapping picture section falls within rectangular window onto designated rectangular viewport computer graphics terminology term window originally referred area picture selected viewing defined beginning section unfortunately term used window manager systems refer rectangular screen area moved resized made active inactive chapter use term window window ywinas r viewpoint yinax l xw erin aw max venues xvnax world coordinates device coordinates viewing transformation using standard rectangies window viewport refer area world coordinate scene selected displav consider graphical user interfaces chapter discuss screen windows window manager systems graphics packages provide window viewport operations allow standard rectangles general approach allow rec tangular window orientation case carry viewing transformation several steps indicated first construct scene world coordinates using output primitives attributes discussed chapters nest obtain particular orientation window set two dimensional viewing coordinate system world coordi nate plane define window viewing coordinate system viewing coordinate reference frame used provide method setting arbitrary orientations rectangular windows viewing reference frame estab lished transform desenptions world coordinates viewing coordi nates define viewport normalized coordinates range map viewing coordinate description scene normalized co ordinates final step parts picture outside viewport clipped contents viewport transferred device coordi nates illustrates rotated viewing coordinate reference frame mapping normalized coordinates changing position viewport view objects different positions display area output device also varying size viewports change size proportions displayed objects achieve zooming effects successively mapping different sized windows construct convert map viewing map normalized world coordinate world coordinates viewport mc scene using wc coordinates vc normalized nvc device modaling coordinate viewing coordinates coordinates transformations viewing using window viewport coordinates specifications two dimensional viewing transformation pipeline device coordinates setting rotated world window viewing coordinates corresponding normalized coordinate viewport fixed size viewport windows made smaller zoom part scene view details shown larger windows similarly overview obtained zooming section scene succes sively larger windows panning effects produced moving fixed size win dow across various objects scene viewports typically defined within unit square normalized coordi nates provides means separating viewing transforma tions specific output device requirements graphics package largely device independent scene transferred normalized coordinates unit square simply mapped display area particu lar output device use time different output devices used pro viding appropriate device drivers coordinate transformations completed viewport clipping performed normalized coordinates device coordinates allows us reduce computations concatenating various transformation matrices clipping procedures fundamental importance computer graphics used viewing transformations also window manager sys tems painting drawing packages eliminate parts picture inside outside designated screen area many applications coordinate system provides reference frame specifying world coordinate window set viewing coordinate system using proce dures discussed section first viewing coordinate origin selected world position po xo yo need establish orientation rotation reference frame one way specify world vector v defines viewing direction vector v called view vector given v calculate components unit vectors v v vy u u u viewing x axes respectively unit vectors used form first second rows rotation matrix r aligns viewing x axes world axes section viewing coordinate reference frame x world ys ey b viewing coordinate frame moved coincidence world frame two steps translate viewing origin world origin b rotate align axes two systems obtain matrix converting world coordinate positions viewing coordinates two step composite transformation first translate view ing origin world origin rotate align two coordinate refer ence frames composite two dimensional transformation convert world coordinates viewing coordinates translation matrix takes viewing origin point p world origin r rotation matrix aligns axes two reference frames illustrates steps coordinate transformation object descriptions transferred viewing reference frame choose window extents viewing coordinates select viewport limits normalized coordinates object descriptions trans ferred normalized device coordinates using transformation maintains relative placement objects normalized space viewing coordinates coordinate position center viewing window instance displayed center viewport illustrates window viewport mapping point position xw yw window 1s mapped position xv yv associated view port maintain relative placement viewport window require xu hveup xw xwyn weax xumin xwax xwoyn yo yun _ yw yw ymax yu min yo max yroin point position rw yw designated window mapped viewport coordinates xv yu relative positions two areas solving expressions viewport position xv yv xv aveug kw xw sx yo ymin yw ym sy scaling factors x vmax xunun xwmax wn ay pes hain yo max ywmin equations also derived set transformtions converts window area viewport area conversion performed fol lowing sequence transformations perform scaling transformation using fixed point position xu pin ywymin scales window area size viewport translate scaled window area position viewport relative proportions objects maintained scaling factors sx sy otherwise world objects stretched contracted either x direction displayed output device character strings handled two ways mapped viewport simplest mapping maintains constant character size even though viewport area may enlarged reduced relative window method would employed text formed standard character fonts changed systems allow changes character size string definitions windowed primitives characters formed line segments mapping viewport carried sequence line transformations normalized coordinates object descriptions mapped vari ous display devices number output devices open part cular application another window viewport transformation performed open output device mapping called workstation transforma section window ta viewpart coordinate transiormation chapter two dimensional viewing viewing coordinate window normalized space viewpon ws2 windowws window monitor monitor mapping selected parts scene normalized coordinates different video monitors workstation transformations tion accomplished selecting window area normalized space viewport area coordinates display device workstation transformation gain additional control positioning parts scene individual output devices illustrated use work station transformations partition view different parts normalized space displayed different output devices define viewing reference system phigs application program following function evaluatevieworientationmatrix xv yo xv yv error viewmatrix parameters x0 y0 coordinates viewing origin para meters xv yv world coordinate positions view vector integer error code generated input parameters error otherwise viewmat rix world viewing transformation calculated number viewing transformation matrices defined application set elements window viewport mapping matrix voke function avaluateviewmappingmatrix xwmin xwmax ywmin ymax xvmin xvmax yvmin yvmax error viewmappingmatrix window limits viewing coordinates chosen parameters xwmin xwmax ywmin ywmax viewport limits set malized coordinate positions xvmin xvmax yvmin yvmax viewing transformation matrix construct several window viewport pairs use projecting various parts scene different areas unit square next store combinations viewing window viewport map pings various workstations viewing table setviewrepresentation ws viewindex viewmatrix viewmappingmatrix xclipmin xclipmax yclipmin yclipmax clipxy parameter ws designates output device workstation parameter viewindex sets integer identifier particular window viewport pair matrices viewmatrix viewmappingmatrix concatenated referenced viewindex additional clipping limits also specified usually set cvincide viewport boundaries pa rameter cl ipxy assigned either value moclip value clip allows us turn clipping want view parts scene outside view port also select noclip speed processing know scene included within viewport limits function setvviewiindex viewindex selects particular set options viewing table view index selec tion applied subsequently specified output primitives associated attributes generates display active workstations final stage apply workstation transformation selecting workstation window viewport pair setworkstationwindow ws xwswindmir xwswindmax ywswindmin ywswindmax setworkstationviewport ws xwsvportmin xwsvportmax ywsvportmin ywsvportmax parameter ws gives workstation number window coordinate extents specified range normalized space viewport limits integer device coordinates ifa workstation viewport specified unit square normalized reference frame mapped onto largest square area possible output de vice coordinate origin normalized space mapped origin device coordinates aspect ratio retained transforming unit square onto square area output device example two dimensional viewing example example use viewing functions following sequence state ments sets rotated window world coordinates maps contents upper right corner workstation keep viewing coordinate origin world origin choose view direction window gives us viewing coordinate system rotated clockwise world coordinate reference frame view index set value section two dimensional viewing functions chapter two dimensional viewing evaluatevieworlentationmatrix viewerror viewmat evaluateviewmappingmatrix 24 75 c viewmaperror viewmapmat setviewrepresentation viewmat viewmapmat clip setviewindex similarly could set additiona transformation view index would map specified window viewport lower left screen two graphs example could displayed opposite screen comers following statements setviewindex polyline axes polyline datal setvviewindex polyline axes polyline data2 view index selects viewport upper right screen display view index selects viewport lower left corner function polyline axes produces horizontal vertical coordinate reference data plot graph generally procedure identifies portions picture either inside outside specified region space referred clipping algo rithm simply clipping region object clipped called clip window applications clipping include extracting part defined scene view ing identifying visible surfaces three dimensional views antialiasing line seg ments object boundaries creating objects using sclid modeling procedures displaying multiwindow environment drawing painting operations allow paris picture selected copying moving erasing duphi cating depending application clip window general polygon even curved boundaries first consider clipping methods using rectangular clip regions discuss methods clip region shapes viewing transformation want display picture parts within window area assuming clipping flags set noclip everything outside window discarded clipping algorithms applied world coordinates contents window terior mapped device coordinates alternatively complete world coor dinate picture mapped first device coordinates normalized device coordinates clipped viewport boundaries world coordinate clipping removes primitives outside window considera tion thus eliminating processing necessary transform primitives device space viewport clipping hand reduce calculations al lowing concatenation viewing geometric transformation matrices viewport clipping require transformation device coordinates section performed objects including outside window area raster _ line clipping systems clipping algorithms often combined scan conversion following sections consider algorithms dipping following primitive types point clipping line clipping straight line segments area clipping polygons curve clipping text clipping line polygon clipping routines standard components graphics pack ages many packages accommodate curved objects particularly spline curves conics circles ellipses another way handle curved objects approximate straight line segments apply line polygon clipping procedure assuming clip window rectangle standard position save point p x display following inequalities satisfied xweyin xfs awersy yin ys yurx edges clip window pin xwmax lmine wmax either world coordinate window boundaries viewport boundaries one four inequalities satisfied point clipped saved display although point clipping applied jess often line polygon clipping applications may require point lipping procedure example point clipping applied scenes involving explosions sea foam mod eled particles points distributed region scene illustrates possible relationships line positions standard rectangular clipping region line clipping procedure involves several parts first test given line segment determine whether lies completely side clipping window try determine whether lies com pletely outside window finally identify line completely side completely outside must perform intersection calculations one clipping boundaries process lines inside outside tests checking line endpoints line endpoints inside clipping boundaries line p p saved line endpoints outside one clip boundaries line p p outside win window clipping clipping tb line clipping rectangular clip window dow lines cross one clipping boundaries may require cal culation multiple intersection points minimize calculations try de vise clipping algorithms efficiently identify outside lines reduce tersection calculations line segment endpoints x yy one end points outside clipping rectangle parametric representation aeox fey xd wey tuys yh peusl could used determine values parameter intersections chp ping boundary coordinates value u intersection rectangle boundary edge outside range line enter interiar window boundary value u within range line segment dues indeed cross clipping area method ap phed chpping boundary edge turn determine whether part line segment displayed line segments parallel window edges handled special cases clipping line segments parametric tesis requires good deal computation faster approaches clipping possible number effi cient jine clippers developed survey major algorithms next sections algorithms designed explicitly two dimensional pictures easily adapted three dimensional applications cohen sutherland line chpping one oldest popular kne clipping procedures generally method speeds processing hne segments performing initial tests reduce number intersections must calculated every line end point picture assigned four digit binary code called region code identifies location point relative boundaries clipping rec tangle regions set reference boundaries shown bit position region code used indicate one four relative co ordinate positions point respect clip window left right top bottom numbering bit positions region code right left coordinate regions correlated bit posi tions bit left bit nght bit bit value bit position indicates point relative position otherwise bit position set point within clipping rectangle region code point left rectangle region code bit values region code determined comparing endpoint coordi nate values x clip boundaries bit set x xwgin three bit values determined using similar comparisons languages bit manipulation possible region code bit values determined following two steps calculate differences endpoint coordi nates clipping boundaries use resultant sign bit difference calculation set corresponding value region code bit sign bit x xw pin dit sign bit xw x bit sign bit ywain bit sign bit yn established region codes line endpoints quickly determine lines completely inside clip window clearly outside lines completely contained within window boundaries region code endpoints trivially accept lines lines bit position region codes endpoint completely outside clipping rectangle trivially ject lines would discard line region code one endpoint code endpoint endpoints line left clipping rectangle indicated first bit position region code method used test lines total clipping perform logical operation region codes result line completely outside clipping region lines identified completely inside completely outside clip window tests checked intersection window bound aries shown lines may may cross window terior begin clipping process line comparing outside endpoint clipping boundary determine much line discarded remaining part line checked boundaries continue either line totally discarded section found inside window set algorithm check line endpoints clipping boundaries order left right bottom top illustrate specific steps clipping lines rectangular bound aries using cohen sutherland algorithm show lines could processed starting bottom endpoint line p p2 section line clipping 1000 0000 oo1c ___ lwinctow _ 0100 o11c binary region codes assigned line endpoints according relative position respect clipping rectangle define round py window lines extending one pp coordinate region another may py pass clip window p p may intersect clipping boundaries without entering window check p left right bottom boundaries turn find point clipping rectangle find intersection point p bottom boundary discard line section p p line reduced section p p2 since p outside clip window check endpoint boundaries find left window intersection point p calculated point window final intersection calculation yields p line p p saved completes processing line save part go next line point p next line left clipping rectangle determine intersection p eliminate line section p3 p checking region codes line section p p find remain der line clip window discarded also intersection points clipping boundary calculated using slope intercept form line equation line endpoint coordinates x xx coordinate intersection point vertical boundary obtained calculation tm x x value set either xwypin xwmax slope line cal culated x similarly looking intersection horizontal boundary x coordinate calculated x x set either yw ywrax following procedure demonstrates cohen sutherland line clipping algorithm codes endpoint stored bytes processed using bit manipulations ifint as0 bat masks encode point position relative clip edges point status encoded ing together appropriate bit masks fdefine left_edge oxl caefne right edge 0x2 gdefine buttom_edge 0x4 define top edge ox8 points encoded completely inside clip rectangle others ere outside least one edge cr ing two codes false mo bits set either code ine accepted operation two codes true line defined endpoints completely outside clip region rejected ys define inside define reject b akb define accept b alb unsigned char encode wept2 pt dcpt winmin dept winmax unsigned char code 0x60 ipt x winmin x code code left_edge pt x winmax x code code right_edge pt winmin code code bottom_edge pc winmax code code top_enge return code void swappts wept2 pl weopt2 p2 worte tmp imp pl pl p2 p2 tmp vo swapcodes junsigned char cl unsigne char unsigned char tmp tmp cl cl c2 c2 tmp r void clipbline dcpt winmin ucpt winmax weft2 pl weptz2 p2 unsigned char codel code2 int done false draw false float done codel encode pi winmin winmax code2 encode p2 winmin winmax accept codel code2 done true draw true else reject codel code2 done true else ensure pl outside window inside codei swappts pl p2 swapcodes codel code2 use slope find line clipedge intersections p2 x pl x p2 pl p2 x pl x codel left_edge pl winmin x pl x pl x winmin x else codel right_edge pl winmax x pl x pl x winmax x else codel bottom_edge need update pl x non vertical lines tp2 x pl x pl x winmin pl m1 pl winmin else codel top_edge p2 x x pl x pl x winmax pl pl winmax draw linedda round p1 x round pl round p2 x round p2 liang barsky line clipping faster line clippers developed based analysis para metric equation line segment write form x x udx udy qsu sl ax x x ay using parametric equations cyrus beck developed algorithm generally efficient cohen sutherland algorithm later liang barsky independently devised even faster parametric line clipping algorithm following liang barsky ap proach first write point clipping conditions parametric form xwin x uax xw max 10 yw min way ywmax four inequalities expressed k 4 11 parameters p q defined po ax x aw pz ax xwmar oe 12 p ay yt wein ps ay vw line parallel one clipping boundaries p value k corresponding boundary k correspond left right bottom top boundaries respectively value k also find q line completely outside boundary elimi nated consideration q line inside parallel clipping boundary p infinite extension line proceeds outside inside infinite extension particular clipping boundary p line proceeds inside outside nonzero value p calculate value corresponds point infinitely ex tended line intersects extension boundary k ht 13 pa line calculate values parameters u u define part line lies within clip rectangle value u deter mined looking rectangle edges line proceeds side inside p edges calculate r q p value u taken largest set consisting various values r con versely value determined examining boundaries line proceeds inside outside p value calculated boundaries value u minimum set consisting calculated r values u tu line completely outside clip win dow rejected otherwise end points clipped line calcu lated two values parameter algorithm presented following procedure line intersection parameters initialized values v anc wy clipping boundary appropriate values p q calculated used func tion cliptest determine whether line rejected whether intersec tion parameters adjusted p parameter r used update p parameter r used update ff updating u uy results u uy reject line otherwise update appropriate u parameter new value results shortening hne p q discard line since parallel outside boundary line rejected four values p g tested endpoints clipped line determined values tp finclude graphics define round 1int at9 int cliptest float p float q float ul fleat section line clipping float r int retval true p oo req p r u2s retval false else iv ul sul er else p r qg ppp ry ul retval false else r u2 u2 else p line parallel clipping edge q line outside clipping edge retval false return retval void clipline depe winmin dcpt winmax wefiz pl wept2 p2 float ul u2 dx p2 x pl x dy cliptest dx pl x winmin x ul u2 cliptest dx winmax x pl x ul u2 dy p2 pl cliptest dy pl winmin ul cliptest dy winmax pl sui u2 u2 p2 x pl x u2 dx p2 pl u2 dy ful pl x ul dx pl ul dy linedda round pl x round pl round p2 x round p2 general liang barsky algorithm efficient cohen sutherland algorithm since intersection calculations reduced update parameters u u requires one division window intersec tions line computed final values u u computed contrast cohen sutherland algorithm repeatedly cal culate intersections along line path even though line may completely outside clip window intersection calculation requires divi sion multiplication cohen sutherland liang barsky al gorithms extended three dimensional clipping chapter nicholl lee nicholl line clipping creating regions around clip window nicholl lee nicholl nln algorithm avoids multiple clipping individual line segment cohen sutherland method example multiple intersections may calcu lated along path single line intersection clipping rectan gle located line completely rejected extra intersection calcula tions eliminated nln algorithm carrying region testing intersection positions calculated compared cohen suther land liang barsky algorithms nicholl lee nicholl algorithm per forms fewer comparisons divisions trade nln algorithm applied two dimensional clipping whereas liang barsky cohen sutherland methods easily extended three dimensional scenes line endpoints p p3 first determine position point p nine possible regions relative clipping rectangle three regions shown need considered p lies one six regions move one three regions using sym metry transformation example region directly clip window transformed region left clip window using reflection line x could use counterclockwise rotation next determine position p relative p create new regions plane depending location p boundaries new regions half infinite line segments start position p pass window corners p inside clip window p side set four regions shown intersection ap propriate window boundary carried depending one four regions l r b contains p course p p inside clipping rectangle simply save entire line p region left window set four regions l lt lr lb shown four regions determine unique bound ary line segment instance p region l clip line left boundary save line segment intersection point p p region lt save line segment left window boundary top boundary p four regions l lt lr lb entire line clipped p window p edge region ta b section line clipping f corner region ic three possibfe positions line endpoint p nln line clipping algorithm four clipping regions used nln algorithm p inside clip window pj outside jour chipping regions used nln algorithm p directly left clip window third case p left clip window use clipping regions case two possibilites shown depending position p relative top left corner window p one regions l tr tb lr lb determines unique clip window edge intersection calculations otherwise entire line jected determine region p located compare slope line slopes boundaries clip regions example p left clipping rectangle p region lt slope p prp slope p p slope p p 14 wow bow 15 xpo xp myo ky moy clip entire line yo x x yn wd coordinate difference product calculations used slope tests saved also used intersection calculations parametric equations x x x xu yit g2 ypu x intersection position left window boundary x x x x x intersection position two possible sets clipping regions used nln algonthin p 1s co left clip window line chaping using nonrectangular clip windows applications often necessary clip lines arbitrarily shaped polygons algorithms based parametric line equations liang barsky method earlier cyrus beck approach extended eas ily convex polygon windows modifying algorithm clude parametric equations boundaries clip region preliminary screening line segments accomplished processing lines coordinate extents clipping polygon concave polygon clipping gions still apply parametric clipping procedures first split concave polygon set convex polygons circles curved boundary clipping regions also possible less commonly used clipping algorithms areas slower intersec tion calculations involve nonlinear curve equations first step lines clipped bounding rectangle coordinate extents curved clip ping region lines identified completely outside bounding rec tangle discarded identify inside lines calculate distance line endpoints circle center square distance endpoints line less equal radius squared save entire line remaining lines processed intersection calculations must solve simultaneous circle line equations splitting conc ave polygons identify concave polygon calculating cross products succes sive edge vectors order around polygon perimeter z component chapter two dimensional viewing splitting concave polygon using vector method identifying concave polygon calculating cross products successive pairs edge vectors cross products positive others negative z component concave polygon otherwise polygon convex assuming series three successive vertices collinear case cross product two edge vectors vertices zero vertices collinear degenerate polygon straight line illustrates edge vector cross product method identifying concave polygons vector method splitting concave polygon xy plane calculate edge vector cross products counterclockwise order note sign z component cross products z component tums neg ative polygon concave split along line first edge vector cross praduct pair following example illustrates method splitting concave polygon example vector method far splitting concave polygons shows concave polygon six edges edge vectors poly gon expressed e e e ey e z component since edges xy plane cross product e x e two successive edge vectors vector perpendicular xy plane z component equal e ey ee jy e x e e x e e x e e x e e x e e x e since cross product e x e negative z component split polygon along line vector e line equation edge slope intercept determine intersection line splitting concave polygon using rotational method rotating v3 onto x axis find v x axis split polygon along line vy polygon edges split polygon two pieces edge cross products negative two new polygons convex also split concave polygon using rotational method proceeding counterclockwise around polygon edges translate polygon vertex v turn coordinate origin rotate clockwise direction next vertex v x axis next vertex v x axis polygon concave split polygon two new polygons along x axis repeat concave test two new polygons otherwise continue rotate vertices x axis test negative vertex values illustrates rotational method splitting concave polygon clip polygons need modify line clipping procedures discussed previous section polygon boundary processed line clipper may displayed scries unconnected line segments depending orientation polygon clipping window really want dis play bounded area clipping polygon clipping quire algorithm generate one closed areas scan converted appropriate area fill output polygon clipper sequence vertices defines clipped polygon boundaries lo eee display polygon processed balore clipping clipping line clipping algorithm section polygon clipping chapter two dimensional viewing original polygon wr display correctly clipped clipping clipping polygon sutherland hadgeman polygon clipping correctly clip polygon processing polygon bound ry whole window edge could accomplished processing poly gon vertices clip rectangle boundary turn beginning ini tial set polygon vertices could first clip polygon left rectan gle boundary produce new sequence vertices new set vertices could successively passed right boundary clipper bottom bound ary clipper top boundary clipper step new se quence output vertices generated passed next window boundary clipper four possible cases processing vertices sequence around perimeter polygon pair adjacent polygon vertices passed window boundary clipper make following tests first vertex outside window boundary second vertex inside intersec tion point polygon edge window boundary second vertex added output vertex list input vertices inside win dow boundary second vertex added output vertex list first vertex inside window boundary second vertex outside edge intersection window boundary added tu output vertex list input vertices outside window houndary nothing added output list four cases illustrated successive pairs polygon vertices vertices processed one clip window boundary output hst vertices clipped next window bound ary clip left clip top clipping polygon successive window boundaries ydaras xewm 4dop utnm jdop q ebbpga z3domm eptsut qut bv ode n sugep ebpa woqjog 4ysta ajet umus zapadday arepunog mopurm siy 10j isi xowia jndyno ayy ur spnod ayy jaqry pasn o78 siaquinu pout xayaa yim sunieys mopulm eyo arepumog 1a au surese uosajod e buiddy aand14 modular arepunog yea ysuteze paddy syutod yse pue ysiy ayy aq pauyap seury sdip autynor busop e passadoid uaaq aaey saotien uo8ajod tle tay arepunog yey ysutese paddy yurod ys1y ayy arepunog mopuim yea jo saloys jutog aszy aeue ayy syutod jo aerie jndyno ay owl pasayua uay st sare punog mopul je ysuteze butddips saatains yey yutod auy a8vys buiddy jxau ay passed st yl mopulm ayy apisut st j adeys sutiddyp yxau ay passed pue payepngyes st uolpasiaqul ay arepunog mopuuia sty sassop azepunog pue syuiodpua kq pauyap aul ay jj arepunog mmopulm jsiy ay ysurese butddips jo aun jutodat ay xayiaa yea sassed autos urew ayy arepunoq mopulm dip yses 10j paddija sem yey yurod yuaoas jsou ay sprosar aeue uy yoeoidde zutddip aurjadid ay sayexjsuowap ounpasoid zuimot os ay ssaddya arepunog jo auyedid e ysnoryy ul santen uosatod ayy jo ucissarzoid ay esnyyi 2m sly u moppulm dip e ym squtod uokqdesja ui syi pure uosatod ev smoys amsi4z auyadid ayy ur anuguoo jou saop yurod ay asimsayyq sueddyo punog moj te 4q arepunog mopulm ud jo apisul aq peululiajap uaaq uaaq sey u saye afuo 3st xaqea ndno ayy pappe st quod uotdessayui payems eo 10 xoyed jndur ue saya yutod sauynos zutddip yo auryjedid e pue sossaz0id afsuis e siossadoid jayjered yum auop aq ues siqy aeddro arepunog yxau ayy uo saoquea paddy ay butssed pure days yora ye saoysaa enplarpul buid dyp ajduns aq syst xayaa yndyno ayerpaunaqut ayy ayeutums ued aay arepunoqg mopuim yea ysuteze paddy st uobajod e se saotyre jo yst yndyno ue joy abei0 dn 8unjas samnbar paquosap jsnl aaey se wyyo08je ay suyuewarduiy azepuncg mopulm 4xau ay oy ssadoid ayy yead a1 pinom sjutod panes aay ayy butsy julod uoysasjajui ayy aaes pur puy os apis st xa iaa puy pul xis al paaes osje aay pue aprsul aq paululiajap pue p saorplaa xapaa puke yuod uotpasjayul ayy yo aves pue vosasiayt ay ayenz e apisut st yonym xayaa sucre suraocpy punog ayy jo apisyno ay uo aq pumoy ale zz pur saotwan arepunog mopuim ye ay ysulese bly ul eare ayy bunssadoid aq poyyaur sy ayeaysnyy ay arepunog mopumm yet ay ysurese saoysaa u08ajod jo sited jo sutssazoid aatssa2ons 24n314 audu bars oars ta oape ala 2aes 1nd ul ul ul ur ino polygon overlapping rectangular clip window es top ee clipper vy v1 vi v5 vy mg gn _ vs vy _ v5 vv processing vertices polygon boundary clipping pipeline vertices processed pipeline vertex list clipped polygon v3 vz vx vi case left p x wmin x return false break case right p x wmax x return false break case bottom p wmin return false break case top p wmax return false break return true int cross wcpt2 pl wcpt2 p2 edge b dcpt wmin dcpt wmax inside pl b wmin wmax inside p2 b wmin wmax return false else return true wept2 intersect wcpt2 pl wecpt2 p2 edge b dcpt wmin dcpt wmax weopt2 ipt float pl x p2 x pl p2 pl x p2 x gwitch b case left ipt wmin x ipt p2 wmin x p2 x break case right ipt x wmax x ipt p2 wmax x p2 x break case bottom ipt wmin pl x p2 x ipt x p2 x wmin p2 else ipt x p2 x break case top ipt wmax pl x p2 x ipt x p2 x wmax p2 else ipt x p2 x break vt return ipt void clippoint wcpt2 p edge b dept wmin dcpt wmax wept2 pout int cnt wept2 first weopt2 wept2 ipt previous point exists edge save point first b first b p else previous point exists p previous point cross edge find intersection clip next boundary edges add intersection output list cross p b b wmin wmax ipt intersect p b b wmin wmax b top clippoint ipt b wmin wmax pout ent first else pout ent ipt ent b p save p recent point edge point inside proceed next clip edge inside p b wmin wmax b top clippoint p b wmin wmax pout cnt first else pout cnt p ent void closeclip dcpt wmin dcpt wmax wept2 pout int cnt wept2 first wopt2 wept2 edge b b left b top bre cross b first b b wmin wmax intersect b first b b wmin wmax b top clippoint b l wmin wmax pout cnt first else pout ent ent int clippolygon dcpt wmin dcpt wmax int n wcpt2 pin wept2 pout first holds pointer toa first point processed clip edge holds recent point processed edge wept2 first n_edge int ert q i1 n elippoint pin n_edge left wmin wmax pour cnt first closeclip wmin wmax pout cnt first return cnt convex polygons correctly clipped sutherland hodgeman algo rithm concave polygons may displayed extraneous lines demon strated occurs clipped polygon two separate sections since one output vertex list last ver tex list always joined first vertex several things could correctly display concave polygons one could split con cave polygon two convex polygons process convex poly gon separately another possibility modify sutherland hodgeman ap proach check final vertex list multiple vertex points along chp window baundary correctly join pairs vertices finally could use general polygon clipper either weiler atherton algorithm weiler algorithm described next section weiler atherton polygen clipping vertex processing procedures window boundaries modified concave polygons displayed correctly clipping procedure de veloped method identifying visible surfaces apphed arbitrary polygon clipping regions basic idea algorithm instead always proceeding around polygon edges vertices processed sometimes want follow window boundaries path follow depends polygon processing direction clockwise counterclockwise whether pair polygon ver tices currently processed represents outside inside pair inside window po tee j clipping concave polygon sutherland hodgeman tees n clipper produces two connevted b areas b v stop b clipping concave polygon weiler atherton algorithm generates two separate polygon areas b outside pair clockwise processing polygon vertices use follow ing rules outside inside pair vertices follow polygon boundary inside outside pair vertices follow window boundary clockwise direction processing direction weiler atherton algorithm sulting clipped polygon shown rectangular clipping window improvement weiler atherton algorithm weiler algorithm applies constructive solid geometry ideas clip arbitrary polygon polygon clipping region illustrates general idea approach two polygons figure correctly dipped polygon calculated intersection clipping polygon polygon object polygon clipping algorithms various parametric line clipping methods also adapted polygon clipping particularly well suited clipping convex poly gon clipping windows liang barsky line clipper example ex tended polygon clipping general approach similar suther land hodgeman method parametric line representations used process polygon edges order around polygon perimeter using region testing proce dures similar used line clipping polygon tipping abject clipping pelygon clipping polygon determining _ clipped intersection two polygon area areas section polygon clipping chipping clipping chipping filled carcle string clipt clipping __ string clipy ci ipping text clipping using bounding rectang e entire string areas curved boundaries clipped methods similar dis cussed previous sections curve clipping procedures involve nonlin ear equations however requires processing objects linear boundaries bounding rectangle circle curved object used first test overlap rectangular clip window bounding rectangle object completely inside window save object rectangle determined completely outside window discard object either case computation necessary bounding rectangle test fails look computation saving approaches circle use coordinate extents individual quadrants octants prelimi nary testing calculating curve window intersections ellipse test coordinate extents individual quadrants illustrates circle clipping rectangular window similar procedures applied clipping curved object general polygon clip region first pass clip bounding rectangle object bounding rectangle clip region two regions overlap need solve simultaneous line curve equations obtain clipping intersection points several techniques used provide text clipping graph ics package clipping technique used depend methods used generate characters requirements particular application simplest method processing character strings relative window boundary use none string clipping strategy shown string inside clip window keep otherwise string dis carded procedure implemented considering bounding rectangle around text pattern boundary positions rectangle com pared window boundaries string rejected overlap method produces fastest text clipping alternative rejecting entire character string overlaps window boundary use aff none character clipping strategy discard characters completely inside window case boundary limits individual characters compared window character either overlaps outside window boundary clipped final method handling text clipping clip components indi vidual characters treat characters much way thal treated lines individual character overlaps clip window boundary clip parts character outside window outline character fonts formed line segments processed way using line clipping algorithm characters defined bit maps would clipped com paring relative position individual pixels character grid patterns clipping boundaries far considered procedures clipping picture interior region eliminating everything outside clipping region saved procedures inside region cases want reverse want clip picture exterior specified region picture parts saved outside region referred exte rior clipping typical example application exterior clipping multiple window systems correctly display screen windows often need apply internal external clipping illustrates multiple window display objects within window clipped interior win dow higher priority windows overlap objects objects also clipped exterior overlapping windows exterior clipping used also applications require overlapping pictures examples include design page layouts advertising pub lishing applications adding labels design patterns picture tech nique also used combining graphs maps schematics ap plications use exterior clipping provide space insert larger picture procedures clipping objects interior concave polygon windows also make use external clipping shows line p p clipped interior concave window vertices v v v v vs line p p clipped two passes first p p clipped interior convex polygon v v v3v yield clipped segment p p b external clip p p performed convex polygon v v v yield final clipped line segment p p summary chapter seen map two dimensional world coordinate scene display device viewing transformation pipeline multiple window screen display showing examples interior exterior clipping courtesy sun microsystems summary string oh string string clipping ng oi tring string clipping ligure 29 text clipping using bounding rectangle individual characters tring oe clipping tring clipping text clipping performed components individual characters interior clip tb exterior clip c clipping line p p interior concave polygon vertices v v v4v4vs using convex polygons v v v v hb v_v v c produce clipped line p p cludes constructing werld coordinate scene using modeling transformations transferring world cocrdinates viewing coordinates mapping viewing coordinate descriptions f objects normalized device coordinates finally mapping device coordinates normalized coord nates specified range thev used make viewing packages independent ot particular output devices viewing coordinates specified giving werld coordinate position viewing origin view vector defines directior viewing axis parameters used construct tne viewing transforma tion matrix maps world coordinate object descriptions viewing coordi nates window set viewing coordinates viewport specified normalized device coordinates typically window viewport rec tangles standard position rectangle boundaries parallel coordinate axes mapping viewing coordinates normal zed device coordinates carried relative positions window maintained viewport viewing functions graphics programming package used create one sets viewing parameters one function typically provided tu calculate elements matrix transforming world coordinates view ing coordinates another function used set window viewport transformation matrix third function used specify combinations viewing transforma ions window mapping viewing table select different viewing combinations spo ifving particular view indices listed viewing table objects displayed output device parts scene side window viewport clipped oft unless set clip parameters turn clipping many packages clipping gone normalized device co ordinates transformations concatenated single transfor mation operation applying clipping alponthms clipping region commonly referred clipping window clisping rectangle window viewport standard rectangles several algorithms developed clipping objects clip windew boundaries line clipping algorithms include cohen sutherland method liang barsky method nicholl lee nicholl method cohen suther land method widely used since one first line clipping algorithms developed region codes used identify position line endpoints telative rectangular clipping window boundaries lines im mediately identified completely ins de window completely outside chpped window boundaries liang barsky use parametric line representation similar earlier cyrus beck algorithm set efficient line clipping procedure reduces intersectian calculations nicholl lee nicholl algorithm uses region testing xy plane reduce intersection calculations even parametric liie clipping easily extended convex clipping windows three dimensional clipping windows line clipping also carried concave polygon clipping win dows chpping windows curved boundaries concave poly gons use either vector method revational method split con cave polygon number convex polygons curved clipping windows calculate line intersections using curve equations polygon clipping algorithms include sutherland hodgeman method liang barsky method weiler atherton method suther land hodgeman clipper vertices convex polygon processed order four rectangular window boundaries produce output vertex list clipped polygon liang barsky use parametric line equations repre sent convex polygon edges use similur testing performed n line clipping produce outpul vertex list clipped polygon weiler atherland method weiler method correctly clip convex concave polygons polygon clippers also allow clipping window ov general polygon weiler atherland algorithm processes polygon ver tices order produce one lists output polygon vertices weiler method performs clipping finding intersection region two polygons objects curved boundaries processed rectangular clipping windows calculating intersections using curve equations clipping procedures slower line clippers polygon clippers curve equations nonlinear fastest text clipping method completely clip string part string outside window boundary another method text clipping use none approach individual characters string third method apply either point line polygon curve clipping individual characters string depending whether characters defined point prids outline fonts applications creating picture insets managing multi ple screen windows exterior clipping performed case parts scene inside window clipped exterior parts saved summary chapter two dimensional viewing references line clipping algorithms discussed sproul sutherland cyrus beck liang barsky methods improving speed cohen sutherland fine clipping algorithm given duvanenko polygon clipping methods presented sutherland hodgeman liang barsky general techniques clipping arbitrarily shaped polygons given weiler atherton weiler two dimensional viewing operations phigs discussed howard et al gask ins hopgood duce blake information gks viewing operatians see hopgood et al enderle et al write procedure implement evaluatevieworientationmatrix func tion calculates elements matrix transforming world coordinates viewing coordinates given viewing coordinate origin py view vector v derive window viewport transformation equations first scaling win dow size viewport translating scaled window view port position write procedure mplement evaluateviewmappingmatrix function calculates elements matrix performing window viewport transforma tion write procedure implement set viewrepresentat ion function concate nate viewmatrix viewmappingmatrix store result referenced spetitied view index viewing table write set procedures implement viewing pipeline without clipping without workstation transformation program allow scene ta con structed modeling coordinate transformations specified viewing system specified window v ewport pair option viewing table implemented store different sets viewing transformation parameters derive matrix representation workstation transformation write set procedures implement viewing pipeline without clipping cluding workstation transformation program allow scene con structed modeling coordinate transformations specified viewing system specified window viewport pair workstation transformation parameters given world coordinate scene composite viewing transformation matrix transform scene output device display tmplement cohen sutherland line clipping algorithm carefully discuss rationale behind various tests methods calculating intersection parametets u u liang barsky line clipping algorithm compare number arithmetic operations performed cohen sutherland liang barsky line clipping algorithms several different line orientations rel ative clipping window write procedure implement liang barsky line c ipping algorithm devise symmetry transformations mapping intersection calculations three regions six reg ons xy plane set detailed algorithm nicholl lee nicholl approach line clipping input pair line endpoints compare number arithmetic operations performeo nln algorithm cohen sutherland liang barsky line clipping algorithms several different line orientations relative clipping window write routine identify concave polygons calculating cross products pairs edge vectors write routine split concave polygon using vector method write routine split concave polygon using rotational method adapt liang barsky line clipping algorithm polygon clipping set detailed algorithm weiler atherton polygon clipping assuming clipping window js rectangle standard position devise algorithm weiler atherton polygon clipping clipping win dow specified polygon write routine clip ellipse rectangular window assuming characters text string width develop text clip ping algorithm clips string according ta none character clipping strategy develop text clipping algorithm clips individual characters assuming characters defined pixel grid specified ze write routine implement exterior clipping part defined picture using specified window write routine perform interior exterior clipping given particular win dow system display input routine set window positions screen objects displayed window window priorities individuat objects clipped fit respective windows clipped remove parts overlapping windows higher display priority exercises chapter structures hierarchical modeling f great many applications convenient able create nipulate individual parts picture without affecting picture parts graphics packages provide capability one form another ability define object ina picture separate module make modi fications picture easily cesign applications try differ ent positions orientations component picture without disturbing parts picture take parts picture easily put parts back display later time similarly modeling applications separately create position subparts complex ob ject system overall hierarchy animations apply trans formations individual parts scene one object animated one type motion objects scene move differently main stationary labeled set output primitives associated attributes phigs called structure commonly used names labeled collection primitives segments gks olyects graphics library silicon graphics systems section consider basic structure managing functions phigs similar operations available packages handling labeled groups primi tives picture basic structure functions create structure coordinate positions attribute values spec fied structure stored labeled group ina system structure list called central structure store create structure function openstructure id label segment positive integer assigned parameter id phigs use character strings label structures instead using inte ger names makes easier remember structure identifiers primitives attributes listed end structure signaled clogestructure statement example following program chapter structures hierarchical modeling statements define structure line sequence specified polyline designated line type color openstructure ic setlinetype 1t setpolylinecolourindex lc polyline nr pts clesestructure number structures created picture one structure open creation process time open structure must closed fore new structure created requirement eliminates need structure identification number closestructure statement structure created displayed ona selected output device function poststructure ws id priority parameter ws workstation identifier ic structure name priority assigned rea value range parameter pr ority sets display priority relative structures two structures overlap onan output display device structure higher priority visible example structures posted workstation following priorities poststructure poststructure parts structure overlap structure hidden since struc ture higher prioritv two structures assigned priority value last structure posted given display precedence structure posted active workstation primitives structure scanned interpreted display selected output device video monitor laser printer etc scanning structure list sending graphical output workstation called traversal list current attribute values primitives stored data structure called traversal state list changes made posted structures system structure list tra versal state list updated automatically modifies display posted structures workstation ta remove display structure part cular output device voke function unpoststructure iws id deletes structure active list structures designated put device system structure list affected raster system structure removed display redrawing primitives back ground color process however may also affect display primitives fram structures overlap structure want erase remedy use coordinate extents various structures scene deter mine ones overlap structure erasing simply draw overlapping structures erased structure unposted structures removed selected output device unpostallstructures ws want remove particular structure system structure list accomplish function deletestructure id course also removes display structure posted output devices structure deleted name reused another set primitives entire system structure list cleared deleteallstructures sometimes useful able relabel structure accomplished changestructureldentifier oldid newid one reason changing structure label consolidate numbering structures several structures deleted another cycle set structure labels displaying structure multiple locations test structure positioning setting structure attributes set certain display characteristics structures workstation filters three properties set filters visibility highlighting ca pability structure selected interactive input device visibility invisibility settings structures particular workstation selected device specified function setinvisibilityfilter ws devcode invisset visset parameter invisset contains names structures invisi ble parameter visset contains names visible invisibility filter turn display structures selected workstations without actually deleting workstation lists al lows us example view outline building without interior de tails reset visibility view building ternal features included additional parameters specify number structures two sets structures made invisible raster monitor using procedures discussed unposting deleting structure difference however remove structure active structure list device simply making invisible highlighting another convenient structure characteristic map dis play could highlight cities populations certain value fora section structure concepts chapter structures hierarchica modeling landscape layout could highlight certain varieties shrubbery circuit diagram could highlight components within specific voltage range done function sethighlightingfilter ws devcode highlightset nohighlightset parameter highlightset contains names structures highlighted parameter nohighlightset contains names highlighted kind highlighting used accent structures de pends type capabilities graphics system color video mon itor highlighted structures could displayed brighter intensity color reserved highlighting another common highlighting implementation turn visibility rapidly blinking structures displayed blinking also accomplished rapidly alternating intensity highlighted structures low value high value third display characteristic set structures pickability refers capability structure selected pointing position ing screen cursor want sure certain structures dis play never selected declare nonpickable pick ability filter next chapter take topic input methods detail often would like modify structure created closed structure modification needed design applications try different graph ical arrangements change design configuration response new test data additional primitives added structure done simply reopening structure openstructure nclon append ing required statements example simple appending following program segment first creates structure single fil area adds second fill area structure openstructure shape setiinteriorstyle solid setinteriorcolouriindex fillarea ni vertsl closestructure openstructure shape setintericrstyle hollow fillarea nz verts2 closestructure sequence operations equivalent initially creating structure fill areas openstructure shape setinteriorstyle solid setinteriorcolourindex fillarea nl vertsl setinteriorstyle hollow fillarea n2 verts2 closestructure addition appending may also want sometimes delete certain items structure change primitives attribute settings insert items selected positions within structure general editing operations carried accessing sequence numbers individual components structure setting edit mode structure lists element pointer individual items structure output primitives attribute values referred structure elements simply elements element signed reference position value 1s entered structure shows storage structure elements associated position numbers created following program segment openstructure gizmo setlinetype ltl setpolylinecolourindex 1cl1 polyline nl ptsl setlinetype 1t2 setpolylinecolcurindex 1c2 polyline n2 pts2 closestructure structure elements numbered consecutively integer values starting value indicates position first element structure opened element pointer set assigned position value used edit structure opened structure new already existing system structure list element pointer set opened structure already exist system list element pointer set po sition value last element structure elements added struc ture element painter incremented set value element pointer position within struc ture function setelementpointer k gizmo structure setlinetype 1tl setpolylinecolcurindex 1c1 setpolylinecolourindex wp element element position values pointer polyline n2 pts2 structure gizmo section uditing structures chapter structures hierarchical modeling parameter k assigned integer vajue maximum number elements structure also possible position element pointer using following offset function moves pointer relative current position offsetelementpo nter dk dk assigned positive negative integer offset present position pointer positioned element pointer edit struc ture position setting edit mode structures modified one two possible modes referred edit mode structure set value edit mode seted tmode moce parameter mode assigned either value fsert value replace inserting structure elements edit mode set msert next item entered structure placed position immediately following element pointer elements structure list tollowing inserted item automatically renumbered illustrate insertion operation let change standard line width currently structure g zmo value serting line width statement anywhere first polyline command openstructure gizmo seteditmode insert setelemertpointer setlinewidth lw closestructure shows modified element list gizmo created previous sett operation insert element pointer assigned value position new line width attribute also elements line width statement renumbered starting value gizmo structure element pointer getlinewidth lw getlinetype t1 setpolylinefolourindex lcl modified element list position clement pointer inserting line width attribute structure gizmo polyline nl pts1 setlinetype 1t2 setpolylinecolourindex 1c2 swoon ewnad polyline n2 pts2 new structure created edit mode automatically et value insert assuming edit mode changed iefault value reopen structure append items end ele ment list without setting values either edit mode element pointer demonstrated beginning section edit mode mains value insert element pointer reopened structure points last element list replacing structure elements edit mode set value replace next item entered struc ture placed position element pointer element originally position deleted value element pointer remains unchanged example replace operation suppose want change color second polyline structure gizmo sequence openstructure gizmc seteditmode replace setelementpointer setpolylinecolourindex lc2new closestructure shows element list gizmo new color second polyline replace operation element pointer remains position position new line color attribute deleting structure elements delete element current position element pointer function deleteeiement removes element structure sets value element pointer immediately preceding element example element deletion suppose decide poly lines structure gizmo displayed color accom plish deleting second color attribute gizmo structure setlinetype modified element list position element pointer changing color second polyline structure gizmo setpolylinecolourindex 1c1 setlinetype 1t2 slement pointer get polylinecolourindex 1c2new polyline nl ptsl polyline n2 pts2 section editing structures chapter structures hierarchical modeling openstructure gizmo setelementfointer deleteelement closestructure element pointer reset value following elements renumbered shown contiguous group structure elements deleted function deleteelementrange kl k2 integer parameter k1 gives beginning position number k2 speci fies ending position number example delete second polyline associated attributes structure gizmo deleteelementrange elements structure deleted function emptystructure iid labeling structure flements made number modifications structure could easily lose track element positions deleting inserting elements shift ele ment position numbers avoid keep track new position numbers modifications made simply label different elements struc ture function label k parameter k integer position identifier labels inserted within structure list aid locating structure elements without ferring position number label function creates structure elements effect structure traversal process simply use labels stored structure editing references rather using individual element po sitions also labeling structure elements need unique sometimes convenient give two elements label value particularly editing operations likely applied several positions structure gizmo structure setlinetype 1t1 eetpolylinecolourindex ae modified element jist position polyline ni ptsl j element oortinee ie element pointer deleting pointer bet iinetype color attribute statement polyline n2 pts2 second polyline structure gizmo illustrate use labeling create structure labeledgizmo following routine elements position numbers shown openstructure labeledgizmo label objectllinetype setlinetype 1t1 label objectlcolor setpolylinecolouriindex 1cl1 label objectl polyline nl pts1 label object2linetype setlinetype 1t2 label object2color setpolylinecolourindex 1c2 label object2 polyline n2 pts2 closestructure want change primitives attributes structure referencing labels although labeled every item structure labeling schemes could used depending type much editing anticipated example attributes could lumped one label color attributes could given label identifier label referenced function setelementpointeratlabel k sets element pointer value parameter k search label begins current element pointer position proceeds forward element list means may reset pointer reopening structure since pointer always positioned last element reopened structure label searching done backward ele ment list instance want change color second object structure labeledgizmo could reposition pointer start ele ment list reopening structure search appropriate calor tribute statement label iabeledgizme structure label objectilinetype setlinetype 1tl label abjeccicolor setpolylinecolourindex 1c1 label objectl polyline nl ptsi label object2linetype getlinatype 1t2 label object2color setpolylinecolourindex label object2 element __ pointer set labeled objects associated position numbers stored structure labeledgizmo polyline n2 pts2 section editing structures chapter steuctures hierarchical modeling openstructure iabeledgizmo setelementpointer seteditmode replace setelementpointeratlabel object2color offsetelementpointer setpolylinecolourindex 1c2new closeftructure deleting item referenced label similar replacement opera tion illustrated last openstructure routine first locate appropri ate label offset pointer example color attribute sec ond polyline structure labeledgizmo deleted sequence openstructure labeledgizmo setelementpointer seteditmode replace setelementpointeraatlabel object2color offsetelementpointer deleteelement closestructure also delete group structure elements specified labels function deleteelementsbetweenlabels k1 k2 set elements deleted element pointer set position k1 copying elements one structure another copy entries specified structure open structure copyalllelementsfromstructure id elements structure id inserted open structure starting position immediately following element pointer regardless setting edit mode copy operation complete element pointer set position last item inserted open structure important use structures design representation different types systems architectural engineering systems building lay outs electronic circuit schematics commonly put together using com puter aided design methods graphical methods used also representing economic financial organizational scientific social environmental systems representations systems often constructed simulate behavior system various conditions outcome simulation serve instructional tool basis making decisions system ef fective various applications graphics package must possess efficient methods constructing manipulating graphical system representations creation manipulation system representation termed model ing single representation called model system models sys tem defined graphically purely descriptive set equations defines relationships system parameters graphical models often referred geometric models component parts system represented geometric entities lines polygons cir cles concerned graphics applications use term model mean computer generated geometric representation system model representations shows representation logic circuit illustrating features com mon many system models component parts system displayed geometric structures called symbols relationships symbols represented example network connecting lines three standard symbols used represent logic gates boolean operations connecting lines define relationships terms input output flow left right system parts one symbol gate dis played two different positions within logic circuit repeated positioning basic symbols common method building complex models occurrence symbol within model called instance symbol one instance symbols fig two instances symbol many cases particular graphical symbols chosen represent parts system dictated system description circuit models stan dard electrical logic symbols used models representing abstract con cepts political financial economic systems symbols may con venient geometric pattern information describing model usually provided combination geometric nongeometric data geometric information includes coordinate positions locating component parts output primitives attribute func tions define structure parts data constructing connections parts nongeometric information includes text labels algorithms de scribing operating characteristics model rules determining relationships connections component parts specified geometric data model logic circuit section basic modeling concepts chapter structures hierarchical madeling two methods specifying information needed construct manipulate model one method store infomation data struc ture table linked list method specify information procedures general model specification contain data structures procedures although models defined completely data struc tures others use procedural specifications application perform solid modeling objects might use mostly information taken data structure define coordinate positions procedures weather model hand may need mostly procedures calculate plots tem perature pressure variations example combinations data strictures procedures used consider alternative model specifications logic circuit one method define logic components data table table processing procedures used specify network connections made circuit operates geometric data table include coor dinates parameters necessary drawing pasitioning gates symbols could drawn polygon shapes could formed com binations straight line segments elliptical arcs labels com ponent parts also included table aithough labels could omitted symbols displayed commonly recognized shapes proce dures would used display gates construct connecting lines based coordinate positions gates specified order connect ing additional procedure used produce circuit output binary values given input procedure could set display final output could designed display intermediate vutput values il lustrate internal functioning circuit alternatively might specify graphical information circuit model data structures connecting lines well gates could de fined data table explicitly lists endpoints lines cir cuit single procedure might display circuit calculate output extreme could completely define model procedures using external data structures symbol hierarchies many models organized hierarchy symbols basic building blocks model defined simple geometric shapes appropriate type model consideration basic symbols used form composite objects called modules grouped form higher level modules various components model table data table defining structure position gate circuit fig symbol geometric identitying code description label gate coordinates paramete gate gate gate simplest case describe model one level hierarchy component parts circuit exarnple assume gates posi tioned connected straight lines according connection rules specified gate description basic symbols hier archical description logic gates although gates could described hierarchies formed straight lines elliptical arcs text sort description would convenient one constructing logic cir cuits simplest building blocks gates application interested designing different geometric shapes basic symbols could defined straight line segments arcs example two level symbol hierarchy appears fa cility layout planned arrangement work areas work area fitted collection furniture basic symbols furniture items worktable chair shelves file cabinet forth higher order objects work areas put together different furniture organizations stance basic symbol defined specifying size position orientation within work area facility layout package fixed sizes objects position orientation need specified user positions given coordinate locations work areas orientations specified rotations determine way symbols facing second level hi erarchy work area defined specifying size position orientation within facility layout boundary work area might fitted divider encloses work area provides aisles within facility complex symbol hierarchies formed repeated grouping sym bol clusters higher level facility layout could extended include symbol clusters form different rooms different floors build ing different buildings within complex different complexes widely sep arated physical locations modeling packages general purpose graphics systems gks example designed accommodate extensive modeling applications routines necessary handle modeling procedures data structures often set separate modeling packages graphics packages adapted interface mod eling package purpose graphics routines provide methods gener two level hierarchical description facility layout ating manipulating final output displays modeling routines contrast provide means defining rearranging model representations terms symbol hierarchies processed graphics routines dis play systems phigs graphics library gl silicon graphics equipment designed modeling graphics functions integrated one package symbols available application modeling package defined structured according type application package designed handle modeling packages designed either two dimensional three dimensional displays illustrates two dimensional layout used cir cuit design example three dimensional molecular modeling shown three dimensional facility layout given three dimensional displays give designer better appreciation appearance layout following sections explore characteristic features model ing packages methods interfacing integrating modeling functions graphics routines two dimensional modeling layout used circuit design courtesy summagraphics one half stereoscopic image pair showing three dimensional molecular model dna data supplied tamar schlick nyu wilma k olson rutgers university visualization jerry greenberg sdsc courtesy stephanie sides san diego supercomputer center three dimensional view office layout courtesy intergraph corporation hierarchical model system created structures nesting structures one another form tree organization structure placed hierarchy assigned appropriate transformation fit properly overall model one think setting office facil ity furniture placed various offices work areas turn placed departments forth hierarchy local coordinates modeling transformations many design applications models constructed instances transformed copies geometric shapes defined basic symbol set instances created positioning basic symbols within world coordinate refer ence model various graphical symbols used application defined independent coordinate reference called modeling coordi nate system modeling coordinates also referred local coordinates sometimes master coordinates illustrates local coordinate definitions section hierarchical modeling structures chapter structures hierarchical arrays chair coordi nates modeling x chair chair ww wowww two symbols could used two dimensional facility layout applica tion construct component parts graphical model apply transfor mations local coordinate definitions symbols produce instances symbols world coordinates transformations applied modeling coordi nate definitions symbols referred modeling transformations typi cally modeling transformations involve translation rotation scaling posi tion symbol world coordinates transformations might also used applications modeling transformations obtain particular modeling transformation matrix using geometric transformation functions discussed chapter set indi vidual transformation matrices accomplish modeling transformation input transformation parameters allow system build matrices either case modeling package concatenates individual trans formations construct homogeneous coordinate modeling transformation trix mt instance symbol world coordinates produced ap plying mt modeling coordinate positions p generate corresponding world coord inate positions p p mt px structure hierarchies seen modeling applications typically require composition basic symbols groups called modules modules may combined arrays tor worktable coordinates worktable ywernsbn j chair coisuis ler tipyiiticins 10 workable fb objects defined local coordinates higher level modules symbol hierarchies created em bedding structures within structures successive level tree first define module structure list symbol instances transfor mation parameters next level define higher level module list lower module instances transformation parameters process continued root tree represents total picture world coordinates structure placed within another structure function executestruccure id jo properly orient structure first assign appropriate local transforma tion structure id done setlocaltransformation mlt type parameter mlt specifies transformation matrix parameter type signed one following three values pre post replace indicate type matrix composition performed current modeling transformation matrix simply want replace current transformation matrix imt set parameter type value replace want current matrix premultipled local matrix specifying function choose pre similarly value post following code section illustrates se quence modeling statements set first instance object hier archy root node createstructure id0q setlocaltransformation lmt type execurestructure idl closestructure procedure used instance objects within structure id0 set nodes level hierarchy create next level tree instancing objects within structure idl structures ido repeat process tree complete entire tree displayed posting root node structure id0 previ ous example following pracedure illustrate hierarchical struc ture used model object void main enum frame wheel bicycle int npcs wept2 pts pmatrix3 routines generate geometry extern void getwheelvertices int npts wept2 prs extern voic getframevertices int npts wcpt2 pts make wheel structure section hierarchical modeling structures getwheelvertices npts prsi epenstructure wreeli setlinewidth polyline npts f ts closestructure make frame structure getframevertices npts pts openstructure iframe setlinewidth polyline infts ts closestructure make bic openstructure bic nclude frame executestructure iframe position include rear wheel matrixsetidenti mi l setlocaltransformationmatrix replace executestructure wheel position iaclude front wheel mfl setlocaltransformationmatrix replace executestructure wheel closestructure delete hierarchy function deletestructurenetwork 1d parameter id rererences root structure tree deletes root node hierarchy structures placed root using executestyucture function assuming thet hierarchy orga nized tree summary structure also called segment object systems labeled group output statements associated attributes bv designing pictures sets structures easily add delete manipwate picture components independently another structures created entcred central structure store structures displayed posting various output devices assigned priorities two structures overlap struc ture higher pnority displayed structt lower prior itv use workstation filters set attributes visibility high lighting structures visibility filter turn display structure retaining structure list highlighting filter used emphasize displayed structure blinking color high intensity patterns various editing operations applied structures reopen structures carry append insert delete operations locations struc ture referenced element pointer addition mdividually label primitives attributes structure term model graphics applications refers graphical representa tion system components system represented symbols de exercises fined loca modeling coordinate reference frames many models elec trical circuits constructed placing instances symbols selected locations many medels constructed symbol hierarchies bicycle instance constructed bicycle frame wheels frame include parts handlebars pedals wheels contain spokes rims tires construct hierarchial model nesting structures example set bike structure contains frame structure wheel structure frame wheel structures contain primitives additional structures continue nesting structures con tain output primitives attributes structure nested within another structure associated model ing transformation set nested structure transformation de scribes operations necessary properly orient scale structure fit hierarchy references structure operations hierarchical modeling phigs discussed hopgoed duce howard et al gaskins blake information gks segment operations see hopgood enderle et ai exercises write procedure creating manipulating intormation central structure store procedure invoked functians openstructure deletestructure changestructurelident ifier write routine tor storing information traversal state fist kr write routine erasing specified structure raster system given coordi nate extents displayed structures scene wrile procedure implement unsost structure function raster system write procedure implement deletestructure function rasler system write procedure implement highlighting blinking operation write set routines editing structures routines provide ror fol lowing types editing appending insening replacing deleting structure ele ments discuss model representations would appropriate far several distinctly difter ent kinds systems also discuss graphical representations might imple mented tor system fora logi circuit modeling applicatior give detailed graph tcal description standard logic symbols used constructing display circuit 10 develop modeling package electrical design allow user position elecrical symbols within circuit network translations reed applied place instance one electrical menu shapes network component placed network connected specified components straight line segments 11 devwse two dimensional facility layout package nenu furniture shapes chapter structures hierarchical modeling 12 pravided des gner place objects ary location within single room one level hierarchy instance transformations limited translatiors reta tions devise two dimensional facility layout package presents menu furniture shapes two leve hierarchy used furniture items placed various work areas work areas arranged within larger area instance transformations may limited translations rotations scaling could used furniture items different sizes available chapter oe graphical user interfaces interactive input methods human computer interface systems invalves extensive graph ics regardless ot application typically general systems consist windows pull pop menus icons pomting devices mouse spaceball positioning screen cursor popular graphical user terfaces include x windows windows macintosh openlook motif interfaces used variety applications including word processing spreadsheets databases file management systems presentation systems page layout systems graphics packages specialized interactive dialogues designed individual applications engineering design architectural design data visualization drafting business graphs artist paintbrush pro grams general graphics packages interfaces usually provided standard system example x window system interface phigs chapter take look basic elements graphical user interfaces techniques interactive dialogues also consider dialogues graphics packages particular allow us construct manipulate pic ture components select menu options assign parameter values select position text strings variety input devices exists general graphics packages designed interface various devices provide exten sive dialogue capabilities particular application user mioael serves basis design dialogue user model describes system designed accom plish graph cs operations available states type objects displayed objects manipulated example graphics system ta used tool architectural design model de scribes package used construct display views buildings positioning walls doors windows building components similarly facilitv layout system objects could defined set furniture items tables chairs etc available operations would include posi tioning removing different pieces furniture within facility layout circuit design prograni might use electrical logic elements objects positioning operations available adding deletirg elements within circuit design information user dialogue presented language section application architectural design package means interactions user dialogue described architectural terms without reference particular data structures concepts may unfamiliar architect follow ing sections discuss general considerations structuring user dialogue windows icons shows examples common window icon graphital interfaces vi sual representations used objects manipulated application actions performed application objects window system provides window manager interface user functions handling display manipulation windows common functions window system opening closing windows reposition ing windows resizing windows display routines provide interior exterior clipping graphics functions typically windows displayed sliders buttons menu icons selecting various window options general systems x windows news capable supporting multiple window managers different window styles accommo dated window manager window managers designed particular applications cases window system designed one specific application window style icons representing objects furniture items circuit elements often referred application icons icons representing actions ro tate magnify scale clip paste called control icons command icons accommodating multiple skill levels usually interactive graphical interfaces provide several methods selecting ac tions example options could selected pointing icon clicking different mouse buttons accessing pull pop menus typ ing keyboard commands allows package accommodate users different skill levels less experienced user interface easily understood oper ations detailed prompting effective one large compre c examples screen layouts using window systems icons courtesy intergraph corporation b visual numerics inc c sun microsystems nm caples graphical ser lilertaces aac interac e faput methods hensive operation set simplifies setot menus options easy learn remember user concentrate application uistead de tails intertace sim ple point click operations arv often easiest experienced user applications package therefore mterfaces typically pro vide means maskirg complexity package beginners use system without overwhelmed wrth much deta experienced users hand typically want speed means fewer prompts input trom kevboard sith multiple mouse ton clicks actions selected function keys simultaneous combina tions keyboard keys ince experienced users remember shortcuts commonly used actions similarly help tacuities designed several levels beginners carry detailed dialogue experienced neers reduce eliminate prompts messages help facilities also include one tu torial applications provide users introduction capabilities use svstem corns stencs important design consideration interface consistenev example particular icon shape always single mear ing rather serving represent different actions objects depending context ex amples consistency always placing menus relative positions user hunt particular option always using particu lar combination keyboard keys action always color coding sa color docs different meanings vifferent situations generally complicated inconsistent model difficult user stand work effective way objects operations provided designed farm minimum consistent set svstent easy learn os ersimplified point ditficult apply minimizing memarngaitien operations interface also structured hat thev easy un derstand remem er obscure complicated incorsistent abbreviated command formats lead confusion reduction effeetiveness ol use package one key button used ail delete operations example easier remember number different keys different tvpes delete operations icons window systems also aid minimizing memorization different kinds information separated different windows nat rely memorization different information displays overlap simply retain multiple information screen different windows switch back forth window areas cons used reduce mem orizing displaying casily recognizable shapes various objects actions select particular action simply select icon resembles action bas kup brot andi oe mechanism tor backing aborting sequence operations common teature cl interface often operation canceled execution completed system restored state operation started ability back point confi dently explore capabilities system knowing effects mis take erased backup provided many forms standard undo key command used cancel single operation sometimes system backed several operations allowing us reset system specified point system extensive backup capabilities inputs could saved back replay part session sometimes operations undone deleted trash desktop wastebasket instance recover deleted files case interface would ask us verify delete operation proceeding good diagnostics error messages designed help determine cause error additionally interfaces attempt minimize error possibilities anticipating certain actions could lead error examples allowing us transform object position delete object ob ject selected allowing us select line attribute selected ob ject line allowing us select paste operation nothing clipboard feedback interfaces designed carry continual interactive dialogue informed uf actions progress step particularly important response time high without feedback might begin wonder system whether input given input received system normally provides type sponse object highlighted icon appears message displayed informs us input received also tells us system processing completed within seconds several feedback messages might displayed keep us informed progress system cases could flashing message indicating system still working input request may also possible system dis play partial results completed final display built piece time system might also allow us input commands data one instruction processed feedback messages normally given clearly enough lit tle chance overlooked overpowering concentration interrupted function keys feedback given audible click lighting key pressed audio feedback advantage use screen space need take attention work area receive message messages displayed screen fixed message area used always know look mes sages cases may advantageous place feedback messages work area near cursor feedback also displayed different colors distinguish displayed objects speed system response feedback techniques chosen take ad vantage operating characteristics type devices use typical raster feedback technique invert pixel intensities particularly making menu selections feedback methods include highlighting blinking color changes section user dialogue chapter graphical user interfaces interactive input methods special symbols designed different types feedback example cross frowning face thumbs symbol often used indicate error blinking work sign used indicate processing progress type feedback effect experienced user beginner may need detailed feedback clearly dicates system also user input next types input echo feedback desirable typed characters displayed screen input detect correct er rors immediately button dial input echoed way scalar values selected dials displayed scales usually echoed screen let us check input values accuracy selection coordinate points echoed cursor symbol appears selected position precise echoing selected positions coordinate values dis played screen graphics programs use several kinds input data picture specifications need values coordinate positions values character string parameters scalar values transformation parameters values specifying menu options values identification picture parts input devices discussed chapter used input various graphical data types de vices better suited fur certain data types others make graphics pack ages independent particular hardware devices used input functions structured according data description handjed function approach provides logical input device classification terms kind data input device logical classitication input dey ices various kinds input data summarized following six logical de vice classifications used ph gs gks locator device specifying coordinate position x stroke device specifying series coordinate positions string device specifying text input valuator device specifying scalar value choice device selecting menu options pick device ter selecting picture components packages single logical device used tur locator stroke operations mechanism switch used indicate whether one coordinate position stream positions input six logical input device classifications van implemented hardware devices hardware devices convenient certain kinds data others device pointed screen posi tion convenient entering coordinate data kevboard exam ple following sections discuss vanous physical devices used provide input ithin logical classifications locator devices standard method interactive selection coordinate point position ing screen cursor mouse joystick trackball spaceball thumbwheels dials digitizer stylus hand cursor cursor posi tioning device screen cursor desired location button acti vated store coordinates screen point keyboards used locator input several ways general purpose keyboard usually four cursor control keys move screen cursor left right additional four keys move cursor diag onally well rapid cursor movement accomplished holding se lected cursor key alternatively joystick joydisk trackball thumbwheels mounted keyboard relative cursor movement last resort could actually type coordinate values slower process also quires us know exact coordinate values light pens also used input coordinate positions spe cial implementation considerations necessary since light pens operate de tecting light emitted screen phosphors nonzero intensity level must present coordinate position selected raster system paint color background onto screen long black areas present light pen used select screen position pos sible eliminate black areas display vector system ex ample light pen used locator creating small light pattern pen detect pattern moved around screen finds light pen stroke devices class logical devices used mput sequence coordinate positions stroke device input equivalent multiple calls locator device set input points often used display line sections many physical devices used generating locator input used stroke devices continuous movement mouse trackball joystick tablet hand cursor translated series input coordinate values graphics tablet one common stroke devices button activation used place tablet continuous mode cursor moved across tablet surface stream coordinate values generated process used pain brush systems allow artists draw scenes screen engineering systems layouts traced digitized storage string devices primary physical device used string input keyboard input charac ter strings typically used picture graph labels physical devices used generating character patterns text writing mode input individual characters drawn screen stroke locator type device pattern recognition program interprets characters using stored dicticnary predefined patterns valuator devices logical class devices employed graphics systems input scalar val ues valuators used setting various graphics parameters rotation section b input graphical data chapter graphical user interfaces interactive input methods angle scale factors setting physical parameters associated par ticular application temperature settings voltage levels stress factors etc typical physical device used provide valuator input set control dials floating point numbers within predefined range input rotating dials dial rotations one direction increase numeric input value opposite rotations decrease numeric value rotary potentiometers convert dial rotation corresponding voltage voltage translated real ridinber within defined scalar range instead dials slide potentiometers sometimes used convert linear movements scalar values keyboard set numeric keys used valuator device user siriply types numbers directly floating point format although slower iriethod using dials slide potentiometers joysticks trackballs tablets interactive devices adapted valuator input interpreting pressure movement device relative scalar range one direction movement say left right increasing scalar values input movement opposite direction decreases scalar input value another technique providing valuator input display sliders tons rotating scales menus video monitor illustrates possibilities scale representations locator input mouse joystick spaceball device used select coordinate position display screen coordinate position converted numeric input value feedback mechanism yser selected position scale marked symbol numeric values may also echoed somewhere screen confirm selections scales displayed video monitor interactive selection parameter values display sliders provided selecting scalar values superellipse parameters s1 s2 individual r g b color values addition small circle positioned color wheel selection combined rgb color buttons activated make small changes color values choice devices graphics packages use menus select programming options parameter values object shapes used constructing picture choice device defined one enters selection list menu alternatives com monly used choice devices set buttons cursor positioning device mouse trackball keyboard cursor keys touch panel function keyboard button box designed stand alone unit often used enter menu selections usually button programmable function altered suit different applications single purpose tons fixed predefined functions programmable function keys fixed function buttons often included standard keys keyboard screen selection listed menu options use cursor control de vices coordinate position x selected compared coordi nate extents listed menu item menu item vertical horizontal boundaries coordinate values xpin xmax yminv ymax selected input coordinates x satisfy inequalities xmin x xmaxs ymin ymax larger menus options displayed time touch panel commonly used cursor control device mouse selected screen position compared area occupied menu choice alternate methods choice input include keyboard voice entry standard keyboard used type commands menu options method choice input abbreviated format useful menu listings numbered given short identifying names similar codings used voice input systems voice input particularly useful number op tions small less pick devices graphical object selection function logical class devices pick de vices used select parts scene transformed edited way typical devices used object selection menu se lection cursor positioning devices mouse joystick position cursor primitives displayed structure press selection button position cursor recorded several levels search may necessary locate particular object selected first cursor position compared coordinate extents various structures scene bounding rectangle structure contains cur sor coordinates picked structure identified two structure areas contain cursor coordinates checks necessary coordinate extents individual lines structure checked next cursor coordinates determined inside coordinate extents one line example identified picked object otherwise need addi tional checks determine closest line cursor position one way find closest line cursor position calculate dis tance squared cursor coordinates x line segment whose bounding rectangle contains cursor position line end points x x y2 distance squared x line calculated section input graphical data distances line segments pick position _ axy aye p ax ay ax x x ay various approximations used speed distance calculation identification schemes used another method finding closest line cursor position spec ify size pick window cursor coordinates centered win dow candidate lines dipped window shown making pick window small enough ensure single line cross window method selecting size pick window de scribed section consider parameters associated various input functions methed avoiding calculation pick distances window clipping intersections highlight candidate structures allow user resolve pick ambiguity one way highlight structures overlap cursor position one one user signals desired structure highlighted alternative cursor positioning use button input highlight suc cessive structures second button used stop process desired structure highlighted many structures searched way process speeded additional button used help identify structure first button initiate rapid successive highlighting struc tures second button used stop process third button used back slowly desired structure passed op erator pressed stop button finally could use keyboard tu type structure names straightforward less interactive pick selection method descriptive names used help user pick process method several drawbacks generally slower interactive picking screen user probably need prompts remember various structure names addition picking structure subparts keyboard difficult picking subparts screen w e p pick window centered pick tyra coordinates x used resolve w _ pick object overlaps graphical input functions set allow users specify following options physical devices provide input within particular logical clas sification example tablet used stroke device graphics program devices interact input mode either program devices initiate dat entry operate si multaneously data input device used time deliver particular input type specified data variables input modes functions provide input structured operate various input modes specify program input devices interact input could initi ated program program input devices could operating simultaneously data input could initiated devices three input modes referred request mode sample mode event mode request mode application program initiates data entry input values requested processing suspended required values received input mode corresponds typical input operation general program ming language program input devices operate alternately devices put wait state input request made program waits data delivered sample mode application program input devices operate inde pendently input devices may operating time program processing data new input values input devices stored placing previously input data values program requires new data samples current values input devices event mode input devices initiate data input application pro gram program input devices operate concurrently input devices deliver data input queue input data saved program requires new data goes data queue number devices operating time sample event modes operating sample mode others operating event mode one device time providing input request mode input mode within logical class particular physical device operat ing specified workstation declared one six input class functions form set moce ws devicecode inputmode echoflaq devicecode positive integer inputmode assigned one val ues request sampl2 event parameter echoflag assigned either value echo value noecho input data echoed display de vice deterrained parameters set othex input functions described later section section input functions chapter table graphical user interfaces assignment input device interactive input methods codes device code physical device type keyboard graphics tablet mouse lovstick trackball button tu e wn device code assignment installation dependent one possible assignment device codes shown table using assignments table could make following declarations setlocatormode sample noecho settextmode request echo setpickmode event echo thus graphics tablet declared locator device sample mode workstation input data feedback echo keyboard text device request mode workstation input echo mouse declared pick device event mode workstation input echo request mode input commands used mode correspond standard input functions high level programming language ask input request mode processing suspended input received device assigned request mode discussed preceding section input requests made device using one six logical class functions represented following request ws devicecode status values input function workstation code device code turned values assigned parameter status data parameters cor responding requested logical class value ok none returned parameter status according va lidity input data value none indicates input device acti vated produce invalid data locator input could mean coordinates range pick input device could acti vated pointing structure break button input device could pressed returned value none used end data signal terminate programming sequence locator stroke input request mode request functions two logical input classes requestlocator ws devcode status viewindgex ot regqueststroke ws devccce nmax status viewlindex prs locator input pt world coordinate position selected stroke input pts list n coordinate positions parameter nmax gives maxi mum number points go input list parameter viewindex signed two dimensional view index number determination world coordinate position two step process physical device selects point device coordinates usually video dis play screen inverse workstation transformation performed obtain corresponding point normalized device coordinates inverse window viewport mapping carried get viewing co ordinates world coordinates since two cr views may overlap device correct viewing transformation identified according view transformation input priority number default view index number lower number higher priority view index highest priority change view priority relative another reference viewing transformation setviewtransformationinputpriority ws viewindex refviewindex prior ty viewindex identifies viewing transformation whose priority changed refviewindex identifies reference viewing transformation parameter priority assigned either value lower value higher example alter priority first four viewing transformations workstation shown sequence functions setviewtransformationinputpriority higher set viewtransformationinputpriority lower string input request mode request input function regueststring ws devcode status nchars str parameter str function assigned input string number charac ters string given parameter nchars original final priority ordering priority ordering rearranging viewing priorities section input functions chapter graphical user interfaces inleractive input methods valuator input request mode numerical value input request mode requestvaluator ws devcode status value parameter value cai assigned real number value choice input request mode make menu selection following request function requestchoice ws devcode status itemnum parameter itemnum assigned positive integer value corresponding menu item selected pick input request mode mode obtain structure identifier number function requestpick ws devcode maxpathdepth status pathdepth pickpath parameter pickpath list information identifying primitive selected list contains structure name pick identifier primitive ele ment sequence number parameter pickdepth number levels returned pickpath maxpathdepth specified maximum path depth included pickpath subparts structure labeled pick input following function setpickidentifier pickid example sublabeling structure creation given following programming sequence openstructure 1d k k n k setpickidentifier k closestructure picking structures subparts structures also controlled work station filters section objects picked invisible also set ability pick objects independently visibility accom plished pick filter setpickfilter ws devcode pickables nonp ckabes set pickabies contains names objects structures primi tives may want select specified pick device similarly set nonpickables contains names objects want avail able picking input device sample mode sample mode set one physical devices data input zins without waiting program direction joystick designated ocator device sample mode coordinate values current position activated joystick immediately stored activated stick position changes stored values continually replaced coordinates current stick position sampling current values physical device mode begins sample command encountered application program locator device sampled one six logical class functions represented following sample ws devicecode device classes status parameter sample mode input parameters request mode example sample input suppose want translate rotate selected object final translation position object obtained locator rotation angle supplied valuator device demon strated following statements samplelocator wsl devl viewindex pr samplevaluator ws2 dev2 angle event mode input device placed event mode program device operate simultaneously data input device accumulated event queue input queue input devices active event mode enter data referred events single event queue device entering data values generated one time event queue contain mixture data types order input data entered queue identi tied according logical class workstation number physical device code application program directed check event queue input function awaitevent time ws deviceclass dev cecode parameter time used set maximum waiting time application pro gram lf queue happens empty processing suspended either number seconds specified time elapsed input arrives waiting time run data values input parameter aeviceclass assigned value none time given value program checks queue immediately returns processing queue empty section input functions chapter graphical user interfaces interactive input methods processing directed event queue awaitevent function queue empty first event queue transferred current event record particular logical device class locator stroke made input stored parameter deviceclass codes identifying particular workstation physical device made input stored pa rameters ws devicecode respectively retrieve data input current event record event mode input function used functions event mode similar request sample modes however workstation device code parameters neces sary commands since values parameters stored data record user retrieves data get example ask locator input invoke function getlocator viewindex pt following program section give example use awaitevent get functions set points tablet device code workstation input plot series straight line segments connecting input coordinates setstrokemode event noecho awaitevent ws deviceclass devicecode deviceclass stroke getstroke nmax viewindex n pts polyline n pts repeat loop bypasses data devices might queue tablet active input device event mode loop necessary number devices used time event mode rapid interactive processing displays following statements plot input lines tablet attributes specified button box setpolylineindex set tablet stroke device event mode setstrokemode evenz noecho set buttons choice device event mode setchoicemode event noecho awaitevent ws deviceclass devicecode deviceclass choice getchoice status option setpolylineindex option else deviceclass stroke getstroke nmax viewindex n pts polyline n pts deviceclass none additional housekeeping functions used event mode func tions clearing event queue useful process terminated new application begin functions set clear entire queue clear data associated specified input devices workstations concurrent use input modes example simultaneous use input devices different modes given following procedure object dragged around screen mouse final position selected button pressed terminate movement sbject mouse positions obtained sample mode button input sent event queue drags object response mouse input terminate processing button press setlocatormode sample echo setchoicemode event noecho samplelocator viewindex pt trarslate object centroid position pt draw awaitevent ws class code class choice quite number parameters set input devices using nitial ize function logical class initialize ws devicecode ps coordext datarec parameter pe prompt echo type parameter coordext assigned set four coordinate values parameter datarec record various con trol parameters locator input values assigned prompt echo parameter pe installation defined pe crosshair cursor centered current position pe line initial position current position pe rectangle defined current initial points several options also available structure picking following options pe highlight picked primitives pe highlight primitives value pick id pe highlight entire structure well several others section initial valves input device parameters chapter graphical user interfaces interactive input methods echo input data requested displayed within bounding rectangle specified four coordinates parameter coordext additional options also set parameter datarec example set following size pick window minimum pick distance type size cursor display type structure highlighting pick op rations range min max valuator input resolution scale valuator input plus number options several techniques incorporated graphics packages aid interactive construction pictures various input options provided coordinate information entered locator stroke devices ad justed interpreted according selected option example restrict lines either horizontal vertical input coordinates establish po sition boundaries objects drawn used rearrange pre viously displayed objects basic positioning methods coordinate values supplied locator input often used positioning methods specify location displaying object character string teractively select coordinate positions pointing device usually posi tioning screen cursor object text string positioning pe formed depends selected options text string example scteen point could taken center string position start end posi tion string string positioning options discussed chapter tines straight line segments displayed two se lected screen positions aid positioning objects numeric values selected positions echoed screen using echoed coordinate values guide make adjustments selected location obtain accurate positioning constraints applications certain types prescribed orientations object align ments useful constraint rule altering input coordinate values produce specified orientation alignment displayed coordinates many kinds constraint functions specified com mon constraint horizontal vertical alignment straight lines type constraint shown figs useful forming network layouts constraint create horizontal vertical lines without worrying precise specification endpoint coordinates section interactive picture construction techniques 3e select first select endpoint position second endpoint position along approximate horizontal path horizontal line constraint _ select first select endpoint position second endpoint position along approximate vartical path vertical line constraint horizontal vertical constraint implemented determining whether two input coordinate endpoints nearly horizontal nearly vertical difference values two endpoints smaller difference x values horizontal line displayed otherwise vertical line drawn kinds constraints applied input coordinates produce variety alignments lines could constrained particular slant input coordinates could constrained lie along predefined paths circular arcs grids another kind constraint grid rectangular lines displayed part screen area grid used input coordinate position rounded nearest intersecton two grid lines illustrates line drawing grid two cursor positions shifted nearest grid intersection point line drawn grid points grids facilitate object con structions new line joined easily previously drawn line selecting position near endpoint grid intersection one end dis played line seiect first endpoint position near grid intersection select position near second grid intersection line drawing using grid chapter graphical user interfaces interactive input methods gravity field around line selected point shaded area shifted position line spacing grid lines often option set user similarly grids turned sometimes possible use par tial grids grids different sizes different screen areas gravity field construction figures sometimes need connect lines positions tween endpoints since exact positioning screen cursor connecting point difficult graphics packages designed convert input position near line position line conversion input position accomplished creating gravity field area around line selected position within gravity field line moved gravitated nearest position line gravity field area around line illustrated shaded boundary shown areas around endpoints enlarged make easier us connect lines endpoints selected positions one circular areas gravity field attracted endpoint area size gravity fields chosen large enough aid positioning small enough reduce chances overlap lines many lines displayed gravity areas overlap may difficult specify points correctly normally boundary gravity field displayed rubber band methads straight lines constructed positioned using rubber band methods stretch line starting position screen cursor moved demonstrates rubber band method first select screen posi tion one endpoint line cursor moves around line displayed start position current position cursor finally select second screen position line endpoint set rubber band methods used construct position objects sides straight lines demonstrates rubber band construction rec tangle shows rubber band circle construction ao ee f qo sn ee ne select cursor line follows first moves line cursor position line stretches second endpoint initial endpoint point selected rubber band method drawing positioning straight line segment select rectangle select final pasition stretches position one corner cursor moves opposite corner rectangle ractangle rubber band method constructing rectangle dragging technique often used interactive picture construction move ob jects position dragging screen cursor first select ob ject move cursor direction want object move se lected object follows cursor path dragging objects various positions scene useful applications might want explore different possibil ities selecting final location painting drawing options sketching drawing painting come variety forms straight lines polygons circles generated methods discussed pre vious sections curve drawing options provided using standard curve shapes circular arcs splines freehand sketching procedures splines interactively constructed specifying set discrete screen points give general shape curve system fits set points polynomial curve freehand drawing curves generated follow ing path stylus graphics tablet path screen cursor video monitor curve displayed designer alter curve shape adjusting positions selected points along curve path joo select position circle stretches select circle final radius center cursor moves circle constructing circle using rubber band method chapter graphical user interfaces interactive input ss os et il cal nl screen layout showing one type interface artist painting package courtesy thomson digital image line widths line styles attribute options also commonly found painting drawing packages options implemented methods discussed chapter various brush styles brush patterns color combinations object shapes surface texture patterns also available many systems particularly designed artist workstations paint systems vary line width brush strokes according pressure artist hand stylus shows window menu system used painting package allows artist select variations specified ob ject shape different surface textures variety lighting conditions scene typical virtual reality environment illustrated interactive input accomplished environment data glove section ca pable grasping moving objects displayed virtual scene computer generated scene displayed head mounted viewing system section stereoscopic projection tracking devices compute pasition ori entation headset data glove relative object positions scene system user move scene rearrange object posi tions data glove another method generating virtual scenes display stereoscopic pro jections raster monitor two stereoscopic views displayed alter nate refresh cycles scene viewed stereoscopic glasses inter active object manipulations accomplished data glove tracking device monitor glove position orientation relative posi tion objects scene using head tracking stereo display called boom fake space labs inc dataglove vpl inc researcher interactively manipulates exploratory probes unsteady flow around harrier jet airplane software developed steve bryson data harrier courtesy sam uselton nasa ames research center summary dialogue applications package designed user model describes furictions applications package elements di alogue presented language applications examples electrical architectural design packages graphical interfaces typically designed using windows icons window system provides window manager interface menus icons allows users open close reposition resize windows window system contains routines carry operations well various graphics operations general window systems designed support multiple window managers icons graphical symbols designed quick iden tification application processes control processes considerations user dialogue design ease use clarity flexibil ity specifically graphical interfaces designed maintain consistency user interaction provide different user skill levels addition interfaces designed minimize user memorization provide sufficient feedback provide adequate backup error handling capabilities input graphics programs come many different hardware de vices one device providing general class input data graphics input functions designed independent particular input hardware use adopting logical classification input devices devices classified according type graphics input rather summary chapter graphical user interfaces interactive input methods hardware designation mouse tablet six logical devices com mon use locator stroke string valuator choice pick locator devices devices used program inpul single coordinate position stroke de vices input stream coordinates string devices used input text valuator devices input devices used enter scalar value choice devices enter menu selections pick devices input structure name input functions available graphics package defined three input modes request mode places input control application program sample mode allows input devices program operate concur rently event mode allows input devices initiate data entry control pro cessing data mode chosen logical device class particular physical device used enter class data input functions program used enter data values program application pro gram make simultaneous use several physical input devices operating different modes interaclive picture construction methods commonly used variety applications including design painting packages methods provide users capability position objects constrain figures predefined orientations alignments sketch figures drag objects around screen grids gravity fields rubber band methods used aid posi tioning picture construction operations references guidelines user interface design presented apple bleser digital osf motif information x window svstem see young cutler gilly reilly additional discussions interface design found phillips goodman spence locdding swezey davis carroll arrithers foley wallace chan good et al evolution concept logical virtual input devices discussed wallace rosenthal et al early discussion input device classifications found newman input operations phigs found hopgood buce howard et al gaskins blake iniormation gks input functions see hopgood et al ana enderle ansy pratt exercises select graphics application witn familiar set user model serve basis design user interface tor yraphics applications area list possible help facilines provided user interface discuss types help would appropriate different levels ef users summarize possible ways handling backup errors state approaches suitable foy beginner better suited experienced user list possible iormats presenting menus user ard explain whal cir cumstances might appropriate discuss alternatives feedback terms various jevels users list functions must performed window manager handling screen layouts multiple ovedapping windows 10 11 12 21 22 23 24 25 26 27 set design ior window manager package mesign user interface painting program design user interface two level hierarchical modeling package area familiar design ac umplete user interface graph ics package providing capabilities users area develop program allows objects positioned screen using locator device object menu geometric shapes presented user se lect object placement position program allow number ob jects positioned terminate signal ts given extend program previous exercise selected objects scaled rotated positioning transformation chcices transformation parameters presented user menu options write program allows user interactively sketch pictures using stroke de vice discuss methods could employed pattern recognition procedure match input characters stored library shapes write routine displays linear scale slider screen allows nu meric values selected positioning slider along scale line number value selected echoed box displayed near linear scale write routine displays circular scale pointer slider moved around circle select angles degrees angular value selected ta echoed box displayed near circular scale write drawing program allows users create picture set line segments drawn specified endpoints coordinates individual line segments selected locator device write drawing package allows pictures created straight line segments drawn specified endpoints set gravity field around line pic lure aid connecting new lines existing lines modify drawing package previous exercise allows lines con strained horizontally vertically develop drawing package display optional grid pattern selected screen positions rounded grid intersections package provide line drawing capabilities line endpoinis selected locator device write routine allows designer create picture sketching straight lines rubber band method write drawing package allows straight lines rectangles circles con structed rubber band methods write program allows user design picture menu basic shapes dragging selected shape position pick device design implementation input functions request mode design implementation sample mode input functions design implementation input functions event mode set general implementation input functions request sample event modes fxercises chapter three dimensional concepts ade w hen model display three dimensional scene many considerations must take account besides including coordinate values third dimension object boundaries constructed various combinations plane curved surfaces sometimes need specify information object interiors graphics packages often provide routines displaying internal components cross sectional views solid ob jects also geometric transformations involved three dimen sional space two dimensions example rotate object axis spatial orientation three dimensional space two dimensional rotations hand always around axis perpendicular xy plane viewing transformations three dimensions much com plicated many parameters select specifying three dimensional scene mapped display device scene descrip tion must processed viewing coordinate transformations projec tion routines transform three diniensional viewing coordinates onto two di mensional device coordinates visible parts scene selected view must identified surface rendering algorithms must applied realistic ren dering scene required obtain display three dimensional scene modeled world coordinates must first set coordinate reference camera co ordinate reference defines position orientation plane cam era film plane want use display view ob jects scene object descriptions transferred camera reference coordinates projected onto selected display plane display aan display tt prone fogure dd ps coordinate reference obta ning particular view ofa _ three dimensional scene objects wireframe outline form apply lighting surface rendering techniques shade visible surfaces parallel projection one method generating view solid object project points ob ject surface along parallel lines onto display plane selecting different viewing positions project visible points object onto display plane obtain different two dimensional views object parallel projection parallel lines world coordinate scene project parallel lines two dimensional display plane technique used engineer ing architectural drawings represent object set views maintain relative proportions object appearance solid object reconstructured major views wireframe display three objects back lines removed commercial database object shapes object database defined grid coordinate points viewed wireframe form surface rendered form courtesy viewpoint datalabs tc top side frant three parallel projection views object showing relative proportions different viewing positions perspective projection another method generating view three dimensional scene project points display plane along converging paths causes objects farther viewing position displayed smaller objects size nearer viewing position perspective projection parallel lines scene parallel display plane projected converging lines scenes displayed using perspective projections appear realistic since way eyes camera lens form images perspective projection view shown parallel lines appear converge distant point background distant objects appear smaller objects closer viewing position depth cueing exceptions depth information important easily iden tify particular viewing direction front back displayed objects illustrates ambiguity result wireframe object displayed without depth information several ways include depth information two dimensional representa tion solid objects simple method indicating depth wireframe displays vary intensity objects according distance viewing position fig ure shows wireframe object displayed depth cueing lines closest section three dimensional display methods perspective projection view airport scene courtesy evans sutherland b wireframe representation pyramid contains depth information indicate whether viewing direction b downward position apex c upward position base wireframe object displayed depth cueing intensity lines decreases front back object viewing position displayed highest intensities lines farther away displayed decreasing intensities depth cueing applied choosing maximum minimum intensity color values range dis tances intensities vary another application depth cueing modeling effect atmos phere perceived intensity objects distant objects appear dimmer us nearer objects due light scattering dust particles haze smoke atmospheric effects change perceived color object model effects depth cueing visible line surface identification also clarify depth relationships wireframe display identifying visi ble lines way simplest method highlight visible lines display different color another technique commonly used engi neering drawings display nonvisible lines dashed lines another ap proach simply remove nonvisible lines figs b c removing hidden lines also removes information shape back surfaces object visible line methods also identify visible surfaces objects objects displayed color shaded surfaces apply surface rendering procedures visible surfaces hidden surfaces obscured visible surface algorithms establish visibility pixel pixel across viewing plane algorithms determine visibility object surfaces whole surface rendering added realism attained displays setting surface intensity objects according lighting conditions scene according assigned sur face characteristics lighting specifications include intensity positions light sources general background illumination required scene sur face properties objects include degree transparency rough smooth surfaces procedures applied generate cor rect itumination shadow regions scene surface rendering methods combined perspective visible surface identification gen erate degree realism displayed scene exploded cutaway views many graphics packages allow objects defined hierarchical structures internal details stored exploded cutaway views objects used show internal structure relationship object parts shows several kinds exploded displays mechanical de sign alternative exploding object component parts cut away view removes part visible surfaces show internal structure three dimensional stereascepic views another method adding sense realism computer generated scene display objects using either three dimensional stereoscopic views seen chapter three dimensional views obtained reflecting section three dimensional display methods _a realistic room display achieved stochastic ray tracing methods apply perspective projection surface texture mapping illumination models courtesy john snyder jed lengyel devendra kalra barr california institute technology copyright caltech fully rendered assembled turbine display also viewed b exploded wireframe display c surface rendered exploded display surface rendered color coded exploded display courtesy autodesk inc raster image vibrating flexible mirror vibrations mirror syn chronized display scene crt mirror vibrates focal length varies point scene projected position corre sponding depth stereoscopic devices present two views scene one left eye right eye two views generated selecting viewing po sitions correspond two eye positions single viewer two views displayed alternate refresh cycles raster monitor viewed glasses alternately darken first one lens synchronization monitor refresh cycles chapter three dimensional concepts color coded cutaway view lawn mower engine showing structure relationship internal components courtesy autodesk inc design three dimensional packages requires considerations necessary two dimensional packages significant difference two packages three dimensional package must include methods mapping scene descriptions onto flat viewing surface need consider im plementation procedures selecting different views using different pro jection techniques also need consider surfaces solid objects modeled visible surfaces identified transformations ob jects performed space describe additional spatial proper ties introduced three dimensions later chapters explore consid erations detail considerations three dimensional packages straightforward extensions two dimensional methods world coordinate descriptions extended three dimensions users provided output input rou tines accessed specifications polyline3 n wepoints fillarea3 n wcpoints text3 wepoint string getlocator3 wcpoint translate3 translatevector matrixtranslate points vectors specified three components transforma tion matrices four rows four columns two dimensional attribute functions independent geometric con siderations applied two dimensional three dimensional appli cations new attribute functions need defined colors line styles marker modeling coordinates world coordinates projection coordinates pipeline transforming view world coordinate scene device coordinates attributes text fonts attribute procedures orienting character strings ever need extended accommodate arbitrary spatial orientations text tribute routines associated vector require expansion include z co ordinate data strings given spatial orientation area filling routines positioning pattern reference point map ping patterns onto fill area need expanded accommodate various ori entations fill area plane pattern plane also two di mensional structure operations discussed earlier chapters carried three dimensional package shows general stages three dimensional transformation pipeline displaying world coordinate scene object definitions converted viewing coordinates projected display plane scan conversion algorithms applied store raster image device coordinates chapter three dimensional object representations raphics scenes contain many different kinds objects trees flowers clouds rocks water bricks wood paneling rubber paper marble steel glass plastic cloth mention itis probably surprising one method use describe objects include characteristics different materials produce realistic displays scenes need use representations accurately model object characteris tics polygon quadric surfaces provide precise descriptions simple eu clidean objects polyhedrons ellipsoids spline surfaces construc tion techniques useful designing aircraft wings gears engineer ing structures curved surfaces procedural methods fractal constructions particle systems allow us give accurate representations clouds clumps grass natural objects physically based modeling methods using systems interacting forces used describe nonrigid behavior piece cloth glob jello octree encodings used repre sent internal features objects obtained medical ct images isosurface displays volume renderings visualization techniques applied three dimensional discrete data sets obtain visual representa tions data representation schemes solid objects often divided two broad categories although representations fall neatly one two categories boundary representations b reps describe three dimen sional object set surfaces separate object interior environ ment typical examples boundary representations polygon facets spline patches space partitioning representations used describe interior properties partitioning spatial region containing object set small nonoverlapping contiguous solids usually cubes common space par titioning description three dimensional object octree representation chapter consider features various representation schemes used applications commonly used boundary representation three dimensional graphics object set surface polygons enclose object interior many graphics systems store object descriptions sets surface polygons simplifies speeds surface rendering display objects since surfaces described linear equations reason polygon descrip wireframe representation cylinder back hidden lines removed tions often referred standard graphics objects cases polyg onal representation one available many packages allow objects described schemes spline surfaces converted polygonal representations processing polygon representation polyhedron precisely defines surface fea tures object objects surfaces tesselated tiled produce polygon mesh approximation surface cylinder repre sented polygon mesh representations common design solid modeling applications since wireframe outline displayed quickly give general indication surface structure realistic renderings pro duced interpolating shading patterns across polygon surfaces eliminate reduce presence polygon edge boundaries polygon mesh ap proximation curved surface improved dividing surface smaller polygon facets polygon tables specify polygon surtace set vertex coordinates associated tribute parameters information polygon input data placed tables used subsequent processing display manipu lation objects scene polygon data tables organized two groups geometric tables attribute tables geometric data tables contain ver tex coordinates parameters identify spatial orientation polygon surfaces attribute information object includes parameters specifying deyree transparency object surface reflectivity texture char acteristics convenient organization storing geometric data create three lists vertex table edge table polygon table coordinate values ver tex object stored vertex table edge table contains pointers back vertex table identify vertices polygon edge polygon table contains pointers back edge table identify edges polygon scheme illustrated two adjacent polygons object surface addition individual objects component polygon faces assigned object facet identifiers easy reference listing geometric data three tables provides conve nient reference individual components vertices edges polygons object also object displayed efficiently using data edge table draw component lines alternative arrangement use two tables vertex table polygon table scheme less convenient edges could get drawn twice another possibility use poly gon table duplicates coordinate information since explicit coordinate values listed vertex polygon also edge information would reconstructed vertex listings polygon table add extra information data tables ot faster infor mation extraction instance could expand edge table include ward pointers polygon table common edges polygons could identified rapidly particularly useful ren dering procedures must vary surface shading smoothly across edges one polygon next similarly vertex table could expanded vertices cross referenced corresponding edges additional geometric information usually stored data tables includes slope edge coordinate extents polygon vertices input calculate edge slopes scan coordinate e vv p vy vv vertex table edge table polygon surface ver xe ey ey vy sy ey vai xge vas 2a ey va v4 ey 8s ey vai xy ey v3 vy val nye var ze ey va vy vas ee vor ey va vs eg vue vy geometric data table representation two adjacent polygon surfaces formed six edges five vertices values identify minimum maximum x z values individual polygons edge slopes bounding box information polygons needed subsequent processing example surface rendering coordinate ex tents also used visible surface determination algorithms since geometric data tables may contain extensive listings vertices edges complex objects important data checked consis tency completeness vertex edge polygon definitions speci fied possible particularly interactive applications certain input er rors could made would distort display object information included data tables easier check errors fore error checking easier three data tables vertex edge polygon used since scheme provides information tests could performed graphics package every vertex listed endpoint least two edges every edge part least one polygon every polygon closed polygon least one shared edge edge table contains pointers polygons every edge ref erenced polygon pointer reciprocal pointer back polygon plane equations produce display three dimensional object must process input data representation object several procedures processing steps include transformation modeling world coordinate descriptions viewing coordinates device coordinates identification visible sur faces application surface rendering procedures processes need information spatial orientation individual section polygon surfaces ey vi sy ey vy vy sy e53 va vy sy se ey va vu ey vys vee eg vs vy sz edge table surfaces expanded include pointers polygon table chapter three mensional object representations figitre vector n normal surtace plane described equation ax cz cartesian components g4 b cy surface components ot object information 1s obtained vertex coordinate values tne equations describe polygon planes equation plane surface expressed form ay cz wie ly iy point plane coetficients b c constants describing spatial properties plane obtain values b c solving set three plane equations using coordinate values three noncollinear points plane purpose select three successive polygon vertices xy yo xs y3 solve following set simultaneous linear plane equations ratios b c x b dyy c z k uo solution set equations obtained determinant form using cramer rule x b x ys x3 regdest cz fy ws v expanding determinants write calculations plane coeffi cients form yey yolea yale za b 29lx xy 2x xe lytdeg co xy yn yay x2 ya wy xag yo dis xyqysts yeo x32 wizs eslyze vertex values information entered inte polygon data struc ture values b c computed polygon stored polygon data orientation plane surface space described normal vector plane shown surface normal vector carte sian components b c parameters b c plane coeffi cients calculated eqs since usuaily dealing polygon surfaces thal enclose object interior need distinguish two sides surface side plane faces object interior called inside face visible outward side ts outside face polygon vertices specified coun terclockwise direction viewing outer side plane right handed coordinate system direction normal vecter inside side ts demonstrated one plane unit cube determine components normal vector shaded surface shown select three four vertices along boundary polygon points selected counterclockwise direction view outside cube toward origin coordinates vertices order selected used eqs obtain plane coefficients b c thus normal vector plane direction positive x axis elements plane normal also obtained using vector cross product calculation select three vertex positions v vz v3 taken counterclockwise order viewing surface outside inside right handed cartesian system forming two vectors one v v v v3 calculate n vector cross product n v2 v v5 vy generates values plane parameters b c obtain value parameter substituting values coordinates one polygon vertices plane equation solving plane equation expressed vector form using normal n position p point plane n p plane equations used also identify position spatial points rela tive plane surfaces object point x z plane parameters b c ax cz identify point either inside outside plane surface according sign negative positive ax cz ax cz point x z inside surface ax cz point x z outside surface inequality tests valid right handed cartesian system provided plane parameters b c calculated using vertices selected counterclockwise order viewing surface outside inside direc tion example point outside shaded plane satisfies equality x point inside plane x coordinate value less polygon meshes graphics packages example phigs provide several polygon functions modeling objects single plane surface specified function illarea object surfaces tiled convenient specify surface facets mesh function one type polygon mesh triangle strip function produces connected triangles shown fig given coordinates n vertices another similar function quadri lateral mesh generates mesh n mn quadrilaterals given shaded polygon surface unit cube plane equation x normal vector n triangle strip formed w triangles connecting vertices ith ae ay quadrilateral mesh containing quadrilaterals constructed input vertex array coordinates n array vertices shows vertices forming mesh quadrilaterals polygons specified three vertices possible vertices may lie one plane due numerical errors errors selecting coordinate positions vertices one way handle situation simply divide polygons triangles another approach sometimes taken approximate plane parameters b c averaging methods project polygon onto coordinate planes using projection method take proportional area polygon projection yz plane b proportional projection area xz plane c proportional projection area xy plane high quality graphics systems typically model objects polygon meshes set database geometric attribute information facilitate processing polygon facets fast hardware implemented polygon renderers incorporated systems capability displaying hundreds thousands one million shaded polygons per second usually trian gles including application surface texture special lighting effects displays three dimensional curved lines surfaces generated input set mathematical functions defining objects set user specified data points functions specified package project defining equations curve display plane plot pixel positions along path projected function surfaces functional description often tesselated produce polygon mesh approximation surface usually done triangular polygon patches ensure vertices polygon one plane polygons specified four vertices may vertices single plane examples display surfaces generated functional descriptions include quadrics superquadrics set discrete coordinate points used specify object shape functional description obtained best fits designated points according constraints application spline representations examples class curves surfaces methods commonly used design new object shapes digitize drawings describe animation paths curve fit ting methods also used display graphs data values fitting specified curve functions discrete data set using regression techniques least squares method curve surface equations expressed either parametric nonparametric form appendix gives summary comparison paramet ric nonparametric equations computer graphics applications parametric representations generally convenient frequently used class objects quadric surfaces described second degree equations quadratics include spheres ellipsoids tori paraboloids hyperboloids quadric surfaces particularly spheres ellip soids common elements graphics scenes often available graphics packages primitives complex objects con structed sphere cartesian coordinates spherical surface radius r centered coordi nate origin defined set points x z satisfy equation tyra also describe spherical surface parametric form using latitude longitude angles x rcos cos 2s os rcos sin ms sn z rsing parametric representation eqs provides symmetric range angular parameters alternatively could write parametric equations using standard spherical coordinates angle specified colatitude defined range often taken range could also set representation using pa rameters u v defined range substituting au 2a ellipsoid ellipsoidal surface described extension spherical surface radii three mutually perpendicular directions different val ues cartesian representation points surface el lipsoid centered origin ur parametric representation ellipsoid terms latitude angle longitude angle x r cos cos 2ehs w r cosd sin mws9sq7 10 z r sing torus torus doughnut shaped object shown generated rotating circle conic specified axis cartesian represen section quadric surfaces axia psixy v axis x axis parametric coordinate position r surface sphere radius r x axis spherical coordinate parameters r using colatitude angle ellipsoid radii r r centered coordinate origin zaxis xy z xy plane torus circular cross section x axis centered coordinate origin tation points surface torus written form z r 11 ry yr vay r given offset value parametric representations torus simi lar ellipse except angle extends using latitude longitude angles describe torus surface set points satisfy x rr cos cos rshen r r cos sin ns sa7 12 z r sing class objects generalization quadric representations super quadrics formed incorporating additional parameters quadric equations provide increased flexibility adjusting object shapes number additional parameters used equal dimension object one para meter curves two parameters surfaces superellipse obtain cartesian representation superellipse corresponding equation ellipse allowirg exponent x terms vari able one way write cartesian superellipse equation form qs se 13 ty ty parameter assigned real value get ordi nary ellipse corresponding parametric equations superellipse eq 13 expressed x r cos ms0s7 74 rysin illustrates supercircle shapes generated using various values parameter superellipsoid cartesian representation superellipsoid obtained equation ellipsoid incorporating two exponent parameters se 15 ry ry n ordinary ellipsoid write corresponding parametric representation superellipsoid eq 15 x r cos cos26 n 2sosn r cos sin s0s7 16 r sin id illustrates supersphere shapes generated using various values parameters superquadric shapes com bined create complex structures furniture threaded bolts hardware e superellipses plotted different values parameter r section s5uperquadrics representations 88s molecular bonding two molecules move away surface shapes stretch snap finally contract spheres c2 b blobby muscle shapes human arm oto7 od bqo dd ee superellipsoids plotted different values parameters r r r objects maintain fixed shape change surface characteris tics certain motions proximity objects examples class objects include molecular structures water droplets liquid ef fects melting objects muscle shapes human body objects described exhibiting blobbiness often simply referred blobby objects since shapes show certain degree fluidity molecular shape example described spherical isolation shape changes molecule approaches another molecule distortion shape electron density cloud due bonding occurs two molecules illustrates stretching snap ping contracting effects molecular shapes two molecules move apart characteristics adequately described simply spherical elliptical shapes similarly shows muscle shapes human arm exhibit similar characteristics case want model surface shapes total volume remains constant several models developed representing blobby objects dis tribution functions region space one way model objecis combinations gaussian density functions bumps sur face function defined fix yz x f 17 rj vx zt parameter specified threshold parame ters b used adjust amount blobbiness individual objects negative values parameter b used produce dents instead bumps illustrates surface structure composite object modeled four gaussian density functions threshold level numerical root finding techniques used locate coordinate intersection values cross sec tions individual objects modeled circles ellipses two cross sections aie near merged form one blobby shape whose structure depends separation two objects methods generating blobby objects use density functions fall finite interval rather exponentially metaball model de scribes composite objects combinations quadratic density functions form b1 3r if0 r fry 5o ridy ifa rsd 18 ifr soft object model uses function 22r 4r coif0 r fir 9d od 19 ifr design painting packages provide blobby function modeling handling applications adequately modeled polygon spline functions alone shows user interface blobby object modeler using metaballs drafting terminology spline flexible strip used produce smooth curve designated set points several small weights distributed along length strip hold position drafting table curve drawn term spline curve originally referred curve drawn manner mathematically describe curve piecewise cubic screen layout used blob modeler blob animator packages modeling objects metaballs courtesy thorson digital image section spline representations three dimensional gaussian bump centered position height b standard deviation composite blobby object formed four gaussian bumps chapter three dimensional object representations set six contro points interpolated piecewise continuous polynomial sections set six control points approximated piecewise continuous polynomial sections polynomial function whose first second derivatives continuous across various curve sections computer graphics term spline curve refers composite curve farmed polynomial sections satisfying speci fied continuity conditions boundary pieces spline surface described two sets orthogonal spline curves several different kinds spline specifications used graphics applications individ ual specification simply refers particular type polynomial certain specified boundary conditions splines used sn graphics applications design curve acd surface shapes digitize drawings computer storage ard specify animation paths objects camera scene typical cad applications splines include design automobile bodies aircraft spacecraft surfaces ship hulls interpolation approximation splines specify spline curve giving set coordinate positions called control points indicates general shape curve control points fitted piecewise continuous parametric polynomial functions one two ways polynemual sections fitted curve passes control point resulting curve said interpolate set control points hand polynomials fitted general control point path without necessarily passing control point resulting curve said approximate set control points interpolation curves commonly used digitize drawings specify animation paths appreximation curves primarily used design tools structure object surfaces shows approximation spline surface created design application straight lines connect control point positions surface spline curve defined modified manipulated operations control points interactively selecting spatial positions control points designer set initial curve polynomial fit displayed given set control points designer reposition control points restructure shape curve addition curve translated rotated scaled transformations applied control points cad packages also insert extra contro points aid designer ad justing curve shapes canvex polygon boundary encloses set control points called convex hull one way envision shape convex hull imagine rubber band stretched around positions contro points con trol point either perimeter hull inside convex hulls provide measure deviation curve surface region bounding contro points splines bounded convex hull thus ensuring polynomials smoothly follow control points without erratic oscillations also polvgon region inside convex hull useful al gorithms asa clipping region polyline connecting sequence control points approximation spline usually displaved remind designer control point ordering set connected line segments often referred control graph curve names series straight line sections connecting control points order specified control polygon characteristic polygon fig ure 23 shows shape control graph control point sequences approximation spline surface cad application automotive design surface contours plotted polynomial curve sections surface control points connected straight line segments courtesy evans sutherland parametric continuity conditions ensure smooth transition one section piecewise parametric curve next impose various continuity conditions connection points section spline described set parametric coordinate functions form x x u yu z u w susu 20 pz convex hull shapes dashed jines two sets control points section spline representations chapter thiee dumensional object representations fronre 24 piecewise construction curve joining two curve segments using different orders continuity zero order continuily b first order continuity second order continuity r g ws p rs po py p b xn ae figure 23 control graph shapes dashed lines two different sets contro points set parametric continuity matching parametric derivatives adjoin ing curve sections common boundary zero order parametric continuity described c continuity means simply curves meet values x z evaluated uv first curve section equal respectively values x z evaluated u next curve section first order parametric continuity referred c continuity means first parametric derivatives tangent lines coor dinate functions eq 20 two successive curve sections equal joining point second order parametric continuity c continuity means first second parametric derivatives two curve sections intersection higher order parametric continuity conditions de fined similarly shows examples cy c c continuity second order continuity rates change tangent vectors connecting sections equal intersection thus tangent line transi tions smoothly one section curve next fig 24 c first order cor tinuity rates change tangent vectors two sec tiors quite different b general shapes two adjacent sections change abruptly first order continuity often sufficient digitizing drawings design applications second order continuity useful setting animation paths camera motion many preci sion cad requirements camera traveling along curve path b equal steps parameter would experience abrupt change accelera tion boundary two sections producing discontinuity motion sequence camera traveling along path c frame sequence motion would smoothly transition across boundary geometric continuity conditions alternate method joining two successive curve sections specify condi tions geometric continuity n case require parametric deriva tives two sections te proportional te common bound ary instead equal zero order geometric continuity described g continuity zero order parametric continuity two curves sections must coordinate position boundary point first order geometric continu ity g continuity means parametric first derivatives proportional intersection two successive sections denote parametric posi tion curve p u direction tangent vector p u neces sarily magnitude two successive curve sections joining point g continuity second order geometric continuity g con tinuity means first second parametric derivatives two curve sections proportional boundary g continuity curva tures two curve sections match joining position curve generated geometric continuity conditions similar one generated parametric continuity slight differences curve shape provides comparison geometric parametric continuity geometric continuity curve pulled toward section greater tan gent vector spline specifications three equivalent methods specifying particular spline representa tion state set boundary conditions imposed spline state matrix characterizes spline state set blending functions basis functions determine spec ified geometric constraints curve combined calculate positions along curve path illustrate three equivalent specifications suppose fol lowing parametric cubic polynomial representation x coordinate along path spline section xu aw bw cu dy osus 21 boundary conditions curve might set example endpoint co ordinates x x parametric first derivatives endpoints x four boundary conditions sufficient determine values four coefficients b c boundary conditions obtain matrix characterizes spline curve first rewriting eq 21 matrix product po aa p po b go cc ta b three control points fitted two curve sections joined parametric continuity b geometric continuity tangent vector curve c point p greater magnitude tangent vector curve c p section spline representations chapter three dimensional object representations oe x w3 22 ro fr m4 u cc u row matrix powers parameter u c coefficient col umn matrix using eq 22 write boundary conditions matrix form solve coefficient matrix c c moypine mgeom 23 mygeom four element column matrix containing geometric constraint values boundary conditions spline mypine matrix transforms geometric constraint values polynomial coefficients provides characterization spline curve matrix mgcom contains control point coordinate values geometric constraints specified thus substitute matrix representation c eq 22 obtain x u mapiine migeom 24 matrix mypune characterizing spline representation sometimes called basis matrix particularly useful transforming one spline representation another finally expand eq 24 obtain polynomial representation coordinate x terms geometric constraint parameters aw gy bf 23 k g constraint parameters control point coordinates slope curve control points bf u polynomial blending functions following sections discuss commonly used splines matrix blending function specifications class splines often used set paths object motions provide representation existing object drawing interpolation splines also used sometimes design object shapes cubic polynomials offer reasonable compromise flexibility speed computation com pared higher order polynomials cubic splines requ less calculations memory stable compared lower order polynomials cubic splines flexible modeling arbitrary curve shapes given set control points cubic interpolation splines obtained fit ting input points piecewise cubic polynomial curve passes every control point suppose contro points specified coordinates pow oe ye ah k 02 cubic interpolation fit points illustrated de scribe parametric cubic polynomial fitted pair control points following set equations x u aw bu cu dy yu aye bye ourd su 26 zlu au ba cu three equations need determine values four co efficients b c polynomial representation curve sections n control points setting enough bound ary conditions joints curve sections obtain nu merical values coefficients following sections discuss com mon methods setting boundary conditions cubic interpolation splines natural cubic splines one first spline curves developed graphics applications nat ural cubic spline interpolation curve mathematical representation original drafting spline formulate natural cubic spline requiring two adjacent curve sections first second parametric deriva tives common boundary thus natural cubic splines c continuity control points fit n curve sections total polynomial coefficients determined n interior control points four boundary conditions two curve sections either side control point must first sec ond parametric derivatives control point curve must pass control point gives us 4n equations satisfied 4n polynomial coefficients get additional equation first control point pp position beginning curve another condition control point p must last point curve still need two conditions able determine values coefficients one method obtaining two additional conditions set second derivatives pp p another approach add two extra dummy control points one end original control point sequence add control point p control point p original control points interior points necessary 4n boundary conditions although natural cubic splines mathematical model drafting spline major disadvantage position one control point altered entire curve affected thus natural cubic splines allow local control restructure part curve without specifying entirely new set control points piecewise continuous cubic spline interpolation n control points section cubic spline interpolation methods chapter three dimensional object representations hermile interpolation hermite spline named french mathematician charles hermite interpolating piecewise cubic polynomial specified tangent cach control point unlike natural cubic splines hermite splines adjusted locally curve section dependent endpoint constraints p u represents parametric cubic point function curve section tween control points py p a5 shown ther boundary con ditions define hermite curve section p py pod pay 27 po dp p dp dp dp specifying values parametric derivatives slope curve control points p p respectively write vector equivalent eqs 26 hermite curve sec tion poo au ecu qfue1 28 x component p x u a6 bu cu similar yand z components matrix equivalent eq 28 1s b pu fut wt dy 29 derivative point function expressed pra 2u q 30 aa oe substituting endpoint values parameter w previous two equa tions express hermite boundary conditions 27 matrix form pi 1 101 pro b c30 dp c dpi pb ee ee ee plu olu youl xn tal gla yi 20a parametric point function p u bp hermite curve section control points p p solving equation polynomial coefficients px part dp dp 1 px pao 0 dp 0 dpist ane ep wor oo w 32 pitt dp dpx ih hermite matrix inverse boundary constraint matrix equation 29 thus written terms boundary conditions px p u v2 uw pe 33 dp dp finally determine expressions hermite blending functions carrying matrix multiplications eq 33 collecting coefficients boundary constraints obtain polynomial form pad p28 py 3x7 dp ue dpy u 34 pou pyr wi u dp hu dp hy polynomials h u k referred blending functions cause blend boundary constraint values endpoint coordinates slopes obtain coordinate position along curve shows shape four hermite blending functions hermite polynomials useful digitizing applications may difficult specify approximate curve slopes problems computer graphics useful generate spline curves without requiring input values curve slopes geometric information addition control point coordinates cardinal splines kochanek bartels splines discussed following twa sections variations hermite splines require input values curve derivatives control points procedures splines compute parametric derivatives co ordinate positions control points cardinal splines hermite splines cardinal splines interpolating piecewise cubics specified endpoint tangents boundary curve section difference section cubic spline interpolation methods hla 4 h u e e hiya 4 h u 6 2 u eda hermite blending functions pee parametric puint function p u cardinal spline section control points p p give values endpoint tangents cardinal spline value slope control point calculated coordinates two adjacent control points cardinal spline section completely specified four consecutive con tral points middie two control points section endpoints two points used calculation endpoint slopes take p u representation parametric cubic point function curve section contrel points p four control points p _ py used set boundary conditions cardinal spline section p p pias 35 po depa pe pl per pod thus slopes control points p p taken proportional respec tively chords p py py pxrz parameter called tension parameter since controls loosely tightly cardinal spline fits input control points illustrates shape cardinal curve small large values tension class curves referred catmull rom splines overhauser splines using methods similar hermite splines convert boundary conditions 35 matrix form p u u2 ww pe 30 cardinal matrix 37 withs expanding matrix equation 36 polynomial form p u py su 28u su pyl su u proil u8 3b 2s u sul pyaolsu su 38 py 1car u p car u pyis car w pyy2car u polynomials car u k cardinal blending func tions gives plot basis functions cardinal splines kochanek bartels splines interpolating cubic polynomials extensions cardinal splines two additional parameters introduced constraint equations defining kochanek bartels splines provide flexibility adjusting shape curve sections given four consecutive control points labeled p _1 pp pes1 py define boundary conditions kochanek bartels curve section p px p q px pcd piss po n nig ha py pr 349 b cp ear pd pou ug ou oper pd bml ch pes ped tension parameter b bias parameter c continuity parameter kochanek bartels formulation parametric derivatives may continuous across section boundaries tangent vectors endpoints cardinal spline section proportional chords formed neighboring control points dashed lines ln aan effect tension parameter shape cardinal spline looser curve tighter curve _ section tension parameter interpretation cardinal spline formulation controls looseness tightness curve sections bias b used adjust amount curve bends end section curve sections skewed toward one end pa rameter controls continuity tangent vector across boundaries sections c assigned nonzero value discontinuity slope curve across section boundaries kochanek bartel splines designed model animation paths par ticular abrupt changes motion object simulated nonzero val ues parameter c carglu car u 4 st ee te ttt uv 4 1 ah b carau carsu 0 poi ditsirtiri liriitiiiit uv 0 0 te id cardinal blending functions oand p p2 yn po wd py po ps po p oe po b b effect bias parameter shape kochanek bartels spline section spline approximation method developed french engineer pierre b zier use design renault automobile bodies b zier splines number properties make highly useful convenient curve surface design also easy implement reasons b zier splines widely available various cad systems general graphics packages gl silicon graphics systems assorted drawing painting pack ages aldus superpaint cricket draw b zier curves general b zier curve section fitted number control points number control points approximated relative position de termine degree b zier polynomial interpolation splines b zier curve specified boundary conditions characterizing matrix blending functions general b zier curves blending func tion specification convenient suppose given n control point positions py yy k varying coordinate points blended produce fol lowing position vector p u describes path approximating b zier polynomial function p p pu sp bez uw ofu 40 k b zier blending functions bez u bernstein polynomials bez u cin ku wet 41 c n k binomial coefficients n kg _ 42 c n k equivalently define b zier blending functions recursive calcula tion bez u u bez u ubez _ h k 43 section b zier curves surfaces chapler bez w bf z wk vector equation 40 represents set three oimensional object three parametric equations individual curve coordinates representations x x bez u k yu bez u 44 k u z bez au k asa rule b zier curve polynomial degree cne less number control points used three points generate parabola four points cubic curve forth demonstrates appearance bezier curves various selections control points xy plane z certain control point placements however obtain degenerate b zier polynomials example b zier curve generated three collinear contro points straight line segment set control points coordi nate position produces b zier curve single point b zier curves commonly found painting drawing packages well cad systems since easy implement reasonably powerful curve design efficient methods determining coordinate positions along b zier curve set using recursive calculations example suc cessive binomial coefficients calculated examples two dimensional b zier curves generated trom three four five control points dashed lines connect control point positions k ci k la k 45 n k following example program illustrates method generating b zier curves include math h include graphics h void computecoefficients int n int c int k k ks n k compute n k n k e k c k n k e k k l void computepoint float u wopt3 pt int ncontrols wept controls int int k n nfontrols float blend pt x pt pt z2 add influence control point k k ncontrols k blend c k powf u k powf l u n k pt x controls k x blend pt controls k blend controls k z blend pt z void bezier wept3 controls int ncontrols int wept3 curve allocate space coefficients int int malloc ncontrols sizeof int int computecoefficients ncontrols c computepoint float curveli ncontrols controls c free c properties b zier curves useful property b zier curve always passes first last contro points boundary conditions two ends curve p po 46 p p section b zier curves surfaces chapter three dimensional ohyect representations p3 lf v4 poe l pe oe p bo px pp piguere e0 closed bezier curve generated specifying first last control points location p b p pe pe figtay 36 bezier curse made pass closer loa given coordinate pusition assigning muluple control points positian values parametric first derivatives b zier curve endpoints calculated control point coordinates p np poume 47 p np ap thus slope beginning curve along hne joining first two control points slope end curve along line joining last two endpoints similarly parametric second derivatives b zier curve endpoints calculated p 0o nt dips pd pi pol 45 p c1 gr dip poe ae pw another important property b zier curve lies within convex hull convex polygon boundary control points follows properties b zier blending functions positive sum always nbez ub 49 kat curve position simply weighted sum control point posi tions convex hull property b zier curve ensures polynomial smoothly follows control points without erratic oscillations design techniques using bezier curves closed b zier curves penerated specifving first last control paints position example shown also specifying mul tiple control points single coordinate position gives weight posi tion single coordinate position input two centro points resulting curve pulled nearer position fit b zier curve number control points requires calculation polynonial functions higher degree complicated curves generated formed piecing several b zier sections lower degree together piecing together smaller sections also gives us better control shape curve small regions since bezier curves pass endpoints 1s easy match curve sections zero order continuity alsu b zier curves invportant property tangent curve endpoint 1s along line joining endpoint adjacent control point therefore obtain first order continuity curve sections pick control points p p new section along straight line control points p p previous section two curve sections number contre points obtain c continuity choosing first cantrol point new section last control point previous section positioning second control point new sec tion position pot py pe piecewise approximation curve formed two b zier sections zero order first order continuity attained curve sections setting po p making points p p p collinear thus three control points collinear equally spaced obtain c continuity two b zier sections calculating po sition third control point new section terms positions last three control points previous section pn pa pra requiring second order continuity b zier curve sections unnecessarily restrictive especially true cubic curves four control points per section case second order continuity fixes position first three control points leaves us one point use adjust shape curve segment cubic b zier curves many graphics packages provide cubic spline functions gives reason able design flexibility avoiding increased calculations needed higher order polynomials cubic b zier curves generated four control points four blending functions cubic b zier curves obtained substi tuting eq 41 bezo u wu bez u 3u wu bez u 3w1 w bez u 50 plots four cubic b zier blending functions given form blending functions determine control points influence shape curve values parameter u range u section b zier curves surfaces bez iu ie bez ur le q popuidrrrit l poi 0 08 bez u bez 6 o2t tot u 0 66 four b zier blending functions cubic curves nonzero blending function bez value atu nonzero function bez value j point thus cubic b zier curve always pass control points p p func tions bez bez influence shape curve intermediate values parameter u resulting curve tends toward points p py blend ing function bez maximum wv bez maximum note four blending functions nonzero entire range parameter u thus b zier curves allow local control curve shape decide reposition one control points entire curve affected end positions cubic b zier curve parametric first deriva tives slopes po sp pod pc p ps parametne second derivatives p p 2p py p p 2p pd use expressions parametric derivatives te construct piece wise curves c c continuity sections expanding polynomial expressions blending functions section write cubic b zier point function matrix form zier curves surfaces po pi plu fe uw moe p 51 p3 b zier matrix m3 52 30 co esa 0 could also introduce additional parameters allow adjustment curve tension bias interpolating splines use ful b splines well splines provide capability bezier surfaces two sets orthogonal b zier curves used design object surface specifying input mesh control points parametric vector function b zier surface formed cartesian product b zier blending func tions plu v sd py bez bez uy 53 pa0k p specifying location gm n control points illustrates two b zier surface plots control points con nected dashed lines solid lines show curves constant u con stant v curve constant u plotted varying v interval u fixed one values unit interval curves constant v plotted similarly ae z oe f v prs ps ft _s nno siz xn wie b b zier surfaces constructed b dashed lines connect contro points chapter three dimensional object representations boundary line composite b zier surface constructed two b zier sections joined indicated boundary line dashed lines connect specified control points first order continuity established making ratio length l length l constant collinear line control points across boundary surface sections b zier surfaces properties b zier curves provide convenient method interactive design applications surface patch select mesh control points xy ground plane choose elevations ground plane z coordinate values control points patches pieced together using boundary constraints illustrates surface formed two b zier sections curves smooth transition one section assured establish ing zero order first order continuity boundary line zero order continuity obtained matching control points boundary first order continuity obtained choosing control points along straight jine across boundary maintaining constant ratio col inear line segments set specified contro points across section boundar cs widely used class approximating splines b splines two advantages b zier splines degree cf b spline polynomial set independently number control points certain limitations b splines allow local control shape spline curve surface trade b splines complex b zier splines b spline curves write general expression calculation coordinate positions along b spline curve blending function formulation plu pp uymin sus mg 2d eh 54 k p input set n control points several differences b spline formulation b zier splines range para meter u depends choose b spline parameters b spline blending functions b polynomials degree parameter chosen integer value range number control points actually also set value curve point plot control points local control b splines achieved defining blending functions subintervals total range u blending functions b spline curves defined cox deboor cursion formulas ifuysu ua b otherwise 55 u u upeg bu __t_ g lu sv bysia uged ux ugrg heat blending function defined subintervals total range u selected set subinterval endpoints u referred knot vector choose values subinterval endpoints satisfying relation u wy4 values uy ua depend number control points select value choose parameter set subinter vals knot vector since possible choose elements knot vector denominators previous calculations value mulation assumes terms evaluated assigned value demonstrates local control characteristics b splines addition jocal control b splines allow us vary number control points used design curve without changing degree polynomial also number control points added modified manipulate curve shapes similarly increase number values knot vector aid curve design however also need add control points since size knot vector depends parameter b spline curves following properties polynomial curve degree c continuity range u control points curve described n blending func tions blending function defined subintervals total range u starting knot value range parameter u divided n subintervals n values specified knot vector section b spline curves surfaces chapter three dimensional object representations local modification b spline curve changing one control points produces curve b modified neighborhood altered control point knot values labeled uo resulting b spline curve defined interval knot value u knot value u section spline curve two successive knot values fluenced control points one control point affect shape curve sections addition b spline curve lies within convex hull control points b splines tightly bound input positions value u interval knot value u _ u sum basis functions sb 56 k given control point positions value parameter need specify knot values obtain blending functions using recur rence relations 55 ate three general classifications knot vectors uni form open uniform nonuniform b splines commonly described accord ing selected knot vector class uniform periodic b splines spacing knot values constant resulting curve called uniform b spline example set uniform knot vector 0 often knot values normalized range convenient many applications set uniform knot values sepa ration starting value following knot vector example specification scheme u b alu 8 6 o4 a2 footbag pti leto petririiy u 4 1 5 b u u 0 0 04 2 toda cortirritiit lriit poi tera isis batts ly 0g 4 c periodic b spline blending functions n uniform integer knot vector uniform b splines periodic blending functions given val ues blending functions shape successive blending function simply shifted version previous function b g gut au boy du 57 aw interval adjacent knot values shows quadratic uniform b spline blending functions generated following exam ple curve four control points example uniform quadratic b splines illustrate calculation b spline blending functions uniform integer knot vector select parameter values n knot vector must contain n knot values range parameter u n subintervals chapter four blending functions spans subintervals total range three dimensional object using recurrence relations 55 obtain first blending function representations tw fordsu bul2 w fe gb w forl u 43 for2 u obtain next periodic blending function using relationship 57 substitut ing u vin bg3 shifting starting positions tu forl u fu dg ww yu d4 yw for2su uy for3su similarly remaining two periodic functions obtained successively shifting b right r qlu 2y u boga fle w bqi 3ks 4h fordsu uf for4su x stu for3eu dtu wu v for4su l 2m uy fors su plot four periodic quadratic blending functions given demonstrates local feature b solines first control point multi plied blending function bo u therefore changing position first control point affects shape curve u similarly last control point influences shape spline curve interval b defined also illustrates limits b spline curve example blending functions present interval uy u 338 blending functions present range poly pp pz c ay quadratic periodic b spline fitted four control points xy es ps plane nomial curve interval eq 56 valid thus sum blending functions within interval outside interval sum blending functions since defined since range resulting polynomial curve deter mine starting ending positions curve evaluating blending functions paints obtain poan po ppd pend pr py thus curve starts midposition first two control points ends mid position last two control points also determine parametric derivatives starting ending posi tions curve taking derivatives blending functions substitut ing endpoint values parameter u find pon pi po pend p3 po parametric slope curve start position parallel line join ing first two control points parametric slope end curve parallel line joining last two control points example plot quadratic periodic b spline curve given four control points selected xy plane preceding example noted quadratic curve starts first two control points ends position last two control points result valid quadratic periodic b spline fitted number distinct control points general higher order polynomials start end positions weighted averages control points pull spline curve closer control point position specifying position mul tiple times general expressions boundary conditions periodic b splines oe obtained reparameterizing blending functions parameter u mapped onto unit interval beginning ending conditions obtained u dandu cubic periodic b splines since cubic periodic b splines commonly used graphics packages con sider formulation class splines periodic splines particularly useful generating certain closed curves example closed curve fig 44 generated sections cyclically specifying four six control chapter three dimensiona object representations closed periodic piecewise cubic b spline constructed cyclic specification six control points points shown step three consecutive control points identical curve passes coordinate position cubics blending function spans four subintervals total range u fit cubic four control points could use integer knot vector recurrence relations 55 obtain periodic blending functions last section quadratic periodic b splines section consider alternate formulation periodic cubic b splines start boundary conditions obtain blending functions normalized interval u using formulation also easily obtain characteristic matrix boundary conditions periodic cubic b splines four consecutive control points labeled po p pz ps po po 4p pad pc py 4p2 ps 58 p p po p p5 py boundary conditions similar cardinal splines curve sec tions defined four control points parametric derivatives slopes beginning end curve section parallel chords joining ad jacent contro points b spline curve section starts position near p ends position near p matrix formulation cubic periodic b splines four control points written p u v2 59 b spline matrix periodic cubic polynomials 30 60 1 matrix obtained solving coefficients general cubic polynomial expression using specified four boundary conditions also modify b spline equations include tension parameter cardinal splines periodic cubic b spline tension matrix form 9r 18 61 21 reduces mg obtain periodic cubic b spline blending functions parame ter range expanding matrix representation polynomial form example tension value boat ta u osusl b u 62 bz u 3u8 bn u open uniform b splines class b splines cross uniform b splines nonuniform b splines sometimes treated special type uniform b spline times considered nonuniform b spline classification open uniform b splines simply open b splines knot spacing uniform except ends knot values repeated times following two examples open uniform integer knot vectors starting value ford 2andn ford 4andn normalize knot vectors unit interval 33 67 ford 2andn ford 4andn section b spline curves surfaces chapter three dimensional object representations values parameters n generate open uniform knot vector integer values using calculations forosj qr od ford en 63 n forj n values j ranging x assignment first knots assigned value last knots value n open uniform b splines characteristics similar b zier splines fact degree polynomial open b splines duce b zier splines knot values either example cubic open b spline four control points knot vector 0 01 polynomial curve jor open b spline passes first last con trol points also slope parametric curves first control point parallel line connecting first two control points parametric slope last control point parallel line connecting last two control points geometric constraints matching curve sections b zier curves b zier curves specifying multiple control points coor dinate position pulls b spline curve closer position since open b splines start first control point end last specified control point closed curves genetated specifying first last control points position example open uniform quadratic b splines conditions 63 n five control points obtain following eight values knot vector ing wy ws ug ws meg uz total range u divided seven subintervals five blend ing functions b defined three subintervals starting knot position thus bg defined u3 defined xu u b defined u uw explicit polynomial expressions zre ob tained blending functions recurrence relations 55 bo alt wu osu l qsu lu uy l u u wy fu2 w 4t dg w 1su uy qsu tu lsu u u bu u u u 2eu shows shape five blending functions local fea tures b splines demonstrated blending function nonzero subinterval first control point influences curve interval similarly function b zero outside interval position last control point affect shape beginning middle parts curve matrix formulations open b splines conveniently generated periodic uniform b splines due multiplicity knot values beginning end knot vector nonuniform b splines class splines specify values intervals knot vec tor nonuniform b splines choose multiple internal knot values unequal spacing knot values examples nonuniform b splines provide increased flexibility controlling curve shape unequally spaced intervals knot vector obtain different shapes blending functions different intervals used ad spline shapes increasing knot multiplicity produce subtle variations curve shape even introduce discontinuities multiple knot values also duce continuity repeat particular value obtain blending functions nonuniform b spline using methods similar discussed uniform open b splines given set control points set degree polynomial select knot values using recurrence relations could either obtain set blending functions evaluate curve positions directly display curve graph ics packages often restrict knot intervals either reduce compu tations set characteristic matrices stored used compute section spline curves surfaces ylub alu b o4 u pee deri ivi vida pedi dt 1 3 qo 2 b b lu b au 8 6 o4 2 pat tad u wititiiia pe et pe u 1 3 q 18 3 c b u 6 2 poirot irrirtririnr boos tut lol 1 5 fe open uniform b spline blending functions n andd values along spline curve without evaluating recurrence relations curve point plotted b spline suriaces formulation b spline surface similar b zier splines ob tain vector point function b spline surface using cartesian product b spline blending functions form prototype helicopter designed modeled daniel langlois softimage inc montreal using 000 b spline surface patches scene rendered using ray tracing bump mapping reflection mapping courtesy silicon graphics inc nl nz pu pi epbeysty biy ag 64 ky ko vector values p specify positions nm con trol points b spline surfaces exhibit properties component b spline curves surface constructed selected values parameters determine polynomial degrees used specified knot vector shows object modeled b spline sur faces generalization b splines beta splines also referred splines formulated imposing geometric continuity conditions first second parametric derivatives continuity parameters beta splines called b parameters beta spline continuity canditions specified knot vector designate spline sections left right particular knot position vectors p _ u p u zero order continuity positional continuity g u obtained requiring p_ u pau 65 first order continuity unit tangent continuity g obtained requiring tangent vectors proportional section 10 beta splines position vectors along curve sections left right knot u chapter three dimensional oaject representations bp uw pu b parametric first derivatives proportional unit tangent vectors continuous across knot second order continuity curvature vector continuily g imposed condition bip ua bop cu pu 67 assigned rea number f curvature vector pro vides measure amount bending curve position u f beta splines reduce b splines parameter called vias parameter since controls skewness curve pb curve tends flatten right direction unit tangent vector knots curve tends flatten left effect shape spline curve shown parameter called tension parameter since controls tightly loosely spline fits control graph increases curve approaches shape control graph shown cubic periodic beta spline matrix representation applying beta spline boundary conditions cubic polynomial uni form knot vector obtain following matrix representation periodic beta spline a2 s5 rb v effect parameter shape beta spline curve b effect parameter b shape beta spline curve ab br br pb wab b mg b 2b 2b 3b 68 b b 6b 2p b b b 4b obtain b spline matrix get b spline tension matrix mz b rational function simply ratio two polynomials thus rational spline ratio two spline functions example rational b spline curve described position vector vv sg pr gu pu 69 ayb glu ko p set n control point positions parameters weight factors control points greater value particular closer curve pulled toward control point p weighted parameter weight factors set value standard b spline curve since denominator eq 69 sum blending functions rational splines two important advantages compared nonrational splines first provide exact representation quadric curves conics circles ellipses nonrational splines polynomials approximate conics allows graphics packages model curve shapes one representation rational splines without needing library curve functions handle different design shapes another advantage rational splines invariant respect perspective viewing transfor mation section means apply perspective viewing trans formation control points rational curve obtain cor rect view curve nonrational splines hand invariant respect perspective viewing transformation typically graphics design packages use nonuniform knot vector representations constructing rational b splines splines referred nurbs nonuniform rational b splines homogeneous coordinate representations used rational splines since denominator treated homogeneous factor four dimen sional representation control points thus rational spline thought projection four dimensional nonrational spline three dimen sional space constructing rational b spline representation carried wilh procedures constructing nonrational representation given set contrel points degree polynomial weighting factors knot vector apply recurrence relations obtain blending functions section 11 rationat splines chapter three dimensional object representations plot conic sections nurbs use quadratic spline function three contro points b spline function defined open knot vector quadratic b zier spline set weighting func tions following values g r rational b spline representation p u pobosty p rp pzbz sw 71 bo gu r l r b su x u obtain various conics following values para meter r r hyperbola section r w parabola section r w ellipse section r straight line segment generate one quarter arc unit circle first quadrant xy plane setting w cos choosing control points nn hyperbola ir po _ straight line parabola r w r ellipse r conic sections generated various values rational spline weighting factor w tone tno pp circular arc first quadrant p xy plane po pi pp sections unit circle obtained different control point posi tions complete circle generated using geometric transformation xy plane example reflect one quarter circular arc x axes produce circular arcs three quadrants cad systems construct conic section specifying three points arc rational homogeneous coordinate spline representation determined computing control point positions would generate selected conic type example homogeneous representation unit cir cular arc first quadrant xy plane x w yale qu zu h ttu sometimes desirable able switch one spline representation another instance b zier representation convenient one sub dividing spline curve b spline representation offers greater design flex ibility might design curve using b spline sections convert equivalent bezier representation display object using recursive sub division procedure locate coordinate positions along curve suppose spline description object expressed following matrix product plu u myonne maggot 72 meaine i5 matrix characterizing spline representation mgeom column matrix geometric constraints example control point coordi nates transform second representation spline matrix mpinez need determine geometric constraint matrix mogeomz produces vector point function object charter three dimenstonal object representations pq g mopiyer geom p73 u maoigw2 maeone um geam spline vom ving mgcomz yeom moohine2 mypnet meco maa moacomi ith required transformation matrix converts first spline repre sentation second calculated myo ne ue sphnel nonuniform b spline characterized general spline trix rearrange knot sequence change nonuniform b spline b zier representation b zier matrix couid converted form following example calculates transformation matrix conversion periodic cubic b spline representation cubic b zier spline representa tion 31 030 3 3a mee 0 1 10 76 _ jo4a2 mla transformation matrix converting cubic bezier representa tion periodic cubic b spline representation 2 6 moe 2 moet nn 2 6 aa 771 13 displaying spline curves surfaces display spline curve surface must determine coordinate positions curve surface project pixel positions display device means must evaluate parametric polynomial spline functions cer tain increments range functions several methods use calculate positions range spline curve surface horner rule simplest method evaluating polynomial brute force calcu lation term succession horner rule performs calculations successive factoring requires one multiplication one addition step polynomial degree n n steps example suppose cubic spline representation coor dinate positions expressed x u aye bw ou dy 78 similar expressions z coordinates particular value pa rameter u evaluate polynomial following factored order x u cau bu clu 79 calculation x value requires three multiplications three additions determination coordinate position x z along cubic spline curve requires nine multiplications nine additions additional factoring tricks applied reduce number compu tations required horner method especially higher order polynomials degree greater repeated determination coordinate positions range spline function computed much faster using forward differ ence calculations spline subdivision methods forward difference calculations fast method evaluating polynomial functions generate successive val ues recursively incrementing previously calculated values example xeey xe 80 thus know increment value x step get next value adding increment value step increment ax step called forward difference f divide total range u subintervals fixed size two successive x positions occur x x u xy x u yay uy k 81 us section 13 displaying spline curves surfaces chapter three dimensional object representations illustrate method suppose linear spline representation x u u b two successive x coordinate positions represented x ayy 82 xa au b subtracting two equations obtain forward difference ax case forward difference constant higher order polynomials forward difference polynomial function parameter u degree one less original polynomial cubic spline representation eq 78 two successive x coordinate positions polynomial representations xy ue bug cy dy ye uy bay cy 83 forward difference evaluates ax 3a 854 69 84 quadratic function parameter u since ax polynomial function u use incremental procedure obtain successive values ax ax ax atx 85 second forward difference linear function x 67m 53 86 repeating process write xy atx bay 87 third forward ditference constant bx 88 equations 80 85 87 88 provide incremental forward differ ence calculation points along cubic curve starting step size obtain initial values x coordinate tirst two forward differ ences xo axy a8 89 x 89 2b initia values computed calculation successive x coordinate position requires three additions apply forward difference methods determine positions along spline curves degree n successive coordinate position x evaluated series 3n additions surfaces incremental calculations applied parameter u parameter v subdivision methods recursive spline subdivision procedures used repeatedly divide given curve section half increasing number control points step subdi vision methods useful displaying approximation spline curves since continue subdivision process control graph approximates curve path control point coordinates plotted curve positions application subdivision generate control points shaping curve thus could design general curve shape control points could apply subdivision procedure obtain additional control points added control points make fine adjustments small sections curve spline subdivision easily applied b zier curve section curve passes first last control points range parameter u always easy determine control points near enough curve path b zier subdivision applied spline representations following sequence operations convert spline representation use bezier representation apply b zier subdivision algorithm convert b zier representation back original spline representation shows first step recursive subdivision cubic b zier curve section positions along b zier curve described parametric point function p u u first subdivision step use halfway point p divide original curve two sections first sec tion described point function p section described p 2u forosus05 99 2u sus two new curve sections number control points original curve section also boundary conditions position parametric prs pro pr pp ty rg po py pro pr subdivision subdivision subdividing cubic b zier curve section two sections four control points section 13 displaying spline curves surfaces chapter slope two ends new curve section must match position three dimensiona object slope values original curve p u gives us four conditions representations curve section use determine control point positions first half curve four new control points pio po pi po py 91 piz po 2p po pis po 3p 3p2 ps second half curve obtain four control points pro po 3p 3p2 ps p21 f pi 2p ps 92 piz p2 py p23 ps efficient order computing new control points set add shift division operations pio po pi po py 5p p pi2 pin p2a ps 93 po py ps po r poa pan 4p pr pis pro steps repeated number times depenaing whether subdividing curve gain control points whether try ing locate approximate curve positions subdividing obtain set display points terminate subdivision procedure curve sections small enough one way determine check distances adjacent pairs control points section distances sufficiently small stop subdividing could stop subdividing set control points section nearly along straight line path subdivision methods applied b zier curves degree b zier polynomial degree n control points half curve first subdivision step r pur ck dp k n 94 pak gt cn kin dp c k c n k n binomial coefficients apply subdivision methods directly nonuniform b splines adding values knot vector general methods effi cient b zier subdivision 14 sweep representations solid modeling packages often provide number construction techniques sweep representations useful constructing three dimensional objects possess translational rotational symmetries represent ob jects specifying two dimensional shape sweep moves shape region space set two dimensional primitives circles rectangles provided sweep representations menu options methods obtaining two dimensional figures include closed spline curve constructions cross sectional slices solid objects illustrates translational sweep periodic spline curve defines object cross section perform translational pig py pus pru v u pp p b constructing solid translational sweep translating control paints periodic spline curve generates solid shown b whose surface described point function p u v section 14 sweep representations auda rotation pe opa plu po p constructing solid rotatianal sweep rotating control points periodic spline curve given rotation axis generates solid shown b whose surface described point function p u v sweep moving control points py p set distance along straight line path perpendicular plane cross section intervals along path replicate cross sectional shape draw set connecting lines direction sweep obtain wireframe representation shown fig 53 b example object design using rotational sweep given time periodic spline cross section rotated axis rotation specified plane cross section produce wireframe representa tion shown b axis chosen rotational sweep use rotation axis perpendicular plane spline cross section fig 54 generate two dimensional shape cross section shown figure depth using one three dimensional object generate another general specify sweep constrictions using path rota tional sweeps move along circular path angular disfance noncircular paths specify curve function describ ing path distance travel along path addition vary shape size cross section along sweep path could vary orientation cross section relative sweep path move shape region space another technique solid modeling combine volumes occupied overlapping three dimensional objects using set operations modeling method called constructive solid geometry csg creates new volume ap plying union intersectian difference operation two specified volumes figures 55 56 show examples forming new shapes using set operations block pyramid placed adjacent specifying union operation obtain combined object shown b shows block cylinder overlapping vol umes using intersection operation obtain resulting solid fig b difference operation get solid shown c csg application starts initial set three dimensional objects primitives blocks pyramids cylinders cones spheres closed spline surfaces primitives provided csg package menu se lections primitives could formed using sweep methods spline constructions modeling procedures create new three dimen sional shape using csg methods first select two primitives drag position region space select operation union inter section difference combining volumes two primitives new object addition primitives use form ob jects continue construct new shapes using combinations primitives objects created step final shape object designed procedure represented binary tree example tree represen tation csg object given ray casting methods commonly used implement constructive solid geometry operations objects described boundary representations apply ray casting constructing composite objects world coordinates xy plane corresponding pixel plane video monitor plane referred firing plane since fire ray pixel posi tion objects combined determine surface intersections along ray path sort intersection points accord ing distance firing plane surface limits composite ob ject determined specified set operation example ray casting determination surface limits csg object given shows yz cross sections two primitives path pixel ray per pendicular firing plane union operation new volume combined interior regions occupied either primitives intersec tion operation new volume interior region common primitives b c two overlapping objects b wedge shaped csg object formed intersection operation c csg object formed difference operation subtracting overlapping volume cylinder block volume section 15 constructive sofid geometry methods si combining two objects union operation produces single composite solid object b firing plane implementing csg operations using ray casting firing plane x ae determining object volume along ray path small area firing plane csg object csg tree representation object wy obj obj al pixe ray cperation surface limits union ny intersection c firing difference b plane obj obj zz fa b determining surface limits along pixel ray difference operation subtracts volume one primitive primitive defined local modeling coordinates composite shape formed specifying modeling transforma tion matrices would place two primitives overlapping position world coordinates inverse modeling matrices used transform pixel rays modeling coordinates surface intersection calculations carried individual primitives surface intersec tions two objects sorted used determine composite object limits according specified set operation procedure repeated pair objects combined csg tree particular object csg object designed ray casting used determine physica properties volume mass determine volume object divide firing plane number small squares shown approximate volume v object crass sectional slice area along path ray square position pas v ay dz 95 az depth object along ray position f object internal holes az sum distances pairs intersection points along ray total volume csg object calculated v vv 96 given density function p x object approximate mass along ray position j px yy 2d2 97 one dimensional integral often approximated without actually carrying integration depending form density function total mass csg object approximated 98 em physical properties center mass moment inertia obtained similar calculations improve approximate calculations values physical properties taking finer subdivisions firing plane object shapes represeined octrees implement set op erations csg procedures scanning tree structure describing contents spatial octants procedure described following section searches octants suboctants unit cube locate regions occupied two objects combined hierarchical tree structures called octrees used represent solid objects graphics systems medical imaging applications require dis plays object cross sections commonly use octree representations tree structure organized node corresponds region three dimen sional space representation solids takes advantage spatial coherence reduce storage requirements three dimensional objects also provides convenient representation storing information object interiors octree encoding procedure three dimensional space exten sion encoding scheme two dimensional space called quadtree encod ing quadtrees generated successively dividing two dimensional region usually square quadrants node quadtree four data ele ments one quadrants region pixels within quadrant color homogeneous quadrant corresponding data element node stores color addition flag set data ele ment indicate quadrant homogeneous suppose pixels quad rant found red color code red placed data element node otherwise quadrant said heterogeneous quadrant divided quadrants corresponding data element node flags quadrant heterogeneous stores pointer next node quadtree algorithm generating quadtree tests pixel intensity values sets quadtree nodes accordingly quadrant original space section 16 octrees chapter three dimensional object representations quadrant quadrant quadran quadrant _ data elements representative quadtree node region two dimensional space region two dimensional space divided intu numbered quadrants associated quadtree node four data elements single color specification quadtree one node heterogeneous region space successive subdivisions quadrants continues quadrants homogeneous shows quadtree representation region containing one area solid color different uniform color specified areas region quadtree encodings provide considerable savings storage large color areas exist region space since single color area repre sented one node area containing pixels quadtree repre sentation contains levels node quadtree four immediate descendants octree encoding scheme divides regions af three dimensional space usually cubes octants stores eight data elements node tree individual elements three dimensional space called vol ume elements voxels voxels octant type 1 3 quadtree representation region ot two dimensional space region two dimensional space two levels quadrant divisions associated quadtree representation 3 quadtree representation region containing one foreground color pixel solid background type value stored corresponding data element node empty gions space represented voxel type void heterogeneous octant subdivided octants corresponding data element node points next node octree procedures generating octrees similar quadtrees voxels octant tested octant subdivisions con tinue region space contains homogeneous octants node ir octree zero eight immediate descendants algorithms generating octrees strictured accept definitions objects form polygon mesh curved surface patches solid geometry constructions using minimum maximum coordinate values object define box parallelepiped around object region three dimensional space containing object tested octant octant generate octree representation octree representation established solid object vari ous manipulation routines applied solid algorithm perform ing set operations applied two octree representations gion space union operation new octree constructed combined regions input objects similarly intersection differ sss dhbboeoe data elements representative octree node aegion three dimensional space region three dimensional space divided numbered octants associated octree node eight data elements section 16 octrees w nn chapter three dimensional object representations ence operations perforined looking regions overlap two oc trees new octree formed either storing octants two objects overlap region occupied one object three dimensonal octree rotations accomplished applying trans formations occupied octants visible surface identification carried searching octants front back first object detected visible information transferred quadtree representation display representation scheme similar octree encoding except divide space two partitions instead eight step binary space parti tioning bsp tree subdivide scene two sections step plane position orientation octree encoding scene subdivided step three mutually perpendicular planes aligned cartesian coordinate planes adaptive subdivision space bsp trees provide efficient partitioning since position orient cutting planes suit spatial distribution objects reduce depth tree representation scene compared octree thus reduce time search tree ad dition bsp trees useful identifying visible surfaces space parti tioning ray tracing algorithms object representations considered previous sections used euclidean geometry methods object shapes described equa tions methods adequate describing manufactured objects smooth surfaces regular shapes natural objects moun tains clouds irregular fragmented features euclidean methods realistically model objects natural objects realistically de scribed fractal geometry methods procedures rather equations used model objects might expect procedurally defined objects characteristics quite different objects described equations fractal geometry representations objects commonly applied many fields de scribe explain features natural phenomena computer graphics use fractal methods generate displays natural objects visualizations various mathematical physical systems fractal object two basic characteristics infinite detail every point certain self similarity object parts overall features object self similarity properties object take different forms de pending choice fractal representation describe fractal object witha procedure specifies repeated operation producing detail ob ject subparts natural objects represented procedures theoretically repeat infinite number times graphics displays natural objects course generated witha finite number af steps zoom continuous euclidean shape matter campli cated eventually get zoomed view smoath zoom distant mountain closer view closer yat ragged appearance mountain outline different levels magnification fractal object continue see much detail magnification original view mountain outlined sky continues jagged shape view closer closer position fig 65 near mountain smaller detail individual ledges boulders becomes apparent moving even closer see outlines rocks stones grains sand step outline reveals twists turns took grains sand put microscope would see detail repeated molecular level similar shapes describe coastlines edges plants clouds zooming graphics display fractal object obtained selecting smaller window repeating fractal procedures generate detail new window consequence infinite detail fractal object definite size consider detail size objec tends infinity coordinate extents object remain bound within finite region space describe amount variation object detail number called fractal dimension unlike euclidean dimension number necessarily integer fractal dimension object sometimes referred fractional dimension basis name fractal fractal methods proven useful modeling wide variety natural phenomena graphics applications fractal representations used model terrain clouds water trees plants feathers fur various surface textures make pretty patterns disciplines fractal pat terns found distribution stars river islands moon craters rain fields stock market variations music traffic flow urban prop erty utilization boundaries convergence regions numerical analysis techniques fractal generation procedures fractal object generated repeatedly applying specified transformation function points within region space py xg yo i8 selected initial point iteration transformation function f generates successive levels detail calculations p fcp p f p p f p 99 section 18 fractal geometry methods chapter three dimensional obyect representations general transformation function applied specified point set could apply transformation function initial set primitives straight lines curves color areas surfaces solid objects also use either deterministic random generation procedures iteration transformation function may defined terms geometric transformations scaling translation rotation set nonlinear coordinate trans formations decision parameters although fractal objects definition contain infinite detail apply transformation function finite number cf times therefore objects dis play actually finite dimensions procedural representation approaches true fractal number transformations increased produce detail amount detail included final graphical display ob ject depends number iterations performed resolution dis play system display detail variations smaller size pixel see object detail zoom selected sections peat transformation function iterations classification fractals self similar fractals parts scaled versions entire object starting initial shape construct object subparts apply scaling parameter overall shape use scaling factor sub parts use different scaling factors different scaled parts object also apply random variations scaled subparts fractal said statistically self similar parts statistical properties statistically self similar fractals commonly used mode trees shrubs plants self affine fractals parts formed different scaling para meters sy different coordinate directions also include ran dom variations obtain statistically self affine fractals terrain water clouds typically modeled statistically self affine fractal construction methods invariant fractal sets formed nonlinear transformations class fractals includes selj squaring fractals mandelbrot set formed squaring functions complex space and_ self inverse fractals formed inversion procedures fractal dimension detail variation fractal object described number called fractal dimension measure roughness fragmentation object jagged looking objects larger fractal dimensions set iterative procedures generate fractal objects using given value fractal dimension procedures may able determine fractal dimension properties constructed object although gen eral fractal dimension difficult calculate expression fractal dimension self similar fractal constructed single scalar factor obtained analogy subdivision eu clidean object shows relationships scaling factor number subparts n subdivision unit straight line segment square cube unit line segment divided two equal length subparts similarly square b divided four equal area subparts cube c divided eight equal volume subparts objects relationship k hi j de n e ns la ales f oo aga agen b b fern vv vy n ns3 subdividing objects euclidean dimensions dp b dy c de using scaling factor number subparts scaling factor f analogy euclid ean objects fractal dimension self similar objects obtained ns 709 solving expression fractal similarity dimension _ inn udy self similar fractal constructed different scaling factors different parts fractal similarity dimension obtained implicit relationship qs 1012 scaling factor subpart number k considered subdivision simple shapes straight line rec tangle box complicated shapes including curved lines ob jects nonplanar surfaces determining structure properties subparts difficult general abject shapes use topological cover section 18 fractal geometry methods chapter three dimensional object representations box covering irregularly shaped object ing methods approximate object subparts simple shapes subdivided curve example approximated straight line sections subdi vided polygon could approximated small squares rectangles covering shapes circles spheres cylinders also used ap proximate features object divided number smaller parts cov ering methods commonly used mathematics determine geometric prop erties length area volume object summing properties set smaller covering objects also use covering methods determine fractal dimension objects topological covering concepts originally used extend meaning geometric properties nonstandard shapes extension covering meth ods using circles spheres led notion hausdorff besicovitch dimension fractional dimension hausdorff besicovitch dimension used fractal dimension objects general difficult evaluate commonly fractal dimension object estimated box covering meth ods using rectangles parallelepipeds illustrates notion box covering area inside large irregular boundary approxi mated sum areas small covering rectangles apply box covering methods first determining coordinate extents object subdivide object number small boxes using given scaling factors number boxes takes cover object called box dimension n related fractal dimension object statistically self similar objects single scaling factor cover object squares cubes count number covering boxes use eq 101 estimate fractal dimension self affine objects cover object rectangular boxes since different directions scaled differently case number boxes used affine transformation para meters estimate fractal dimension fractal dimension object always greater corresponding euclidean dimension topological dimension simply least num ber parameters needed specify object euclidean curve one dimen sional euclidean surface two dimensional euclidean solid three di mensional fractal curve lies completely within two dimensional plane fractal dimension greater euclidean dimension curve closer smoother fractal curve peano curve curve completely fills finite region two dimensional space curve self intersects area could covered infinite number times fractal curves used model natural object boundaries shorelines spatial fractal curves lie completely within single plane also fractal dimension greater greater without self intersecting curve fills volume space dimension self intersecting space curve fractal dimension fractal surfaces typically dimension within range surface fills volume space overlapping coverage volume terrain clouds water typically modeled fractal surfaces dimension fractal solid usually range self overlapping object fractal solids used example model cloud properties water vapor density temperature within region space sectian 18 fractal geomerry methods fo _ generator ny initiator initiator generator koch curve geometric construction deterministic self similar fractals geometrically construct deterministic nonrandom self similar fractal start given geometric shape called initiatar subparts initiator replaced pattern called generator example use initiator generator shown construct snowflake pattern koch curve shown straight line segment initiator replaced four equal length line seg ments step scaling factor fractal dimension 2619 also length line segment initiator increases aye e di first three iterations generation koch curve snowflake filling peano curve segment length segment length segment length va yp length length length length side koch curve increases factor step line segment lengths reduced factor segment segment segment length f length length 129 500 b c vigure 717 self similar curve constructions associated fractal dimensions oe tnd ee e e oe e segment segment segment length length length 631 333 333 generators wit multiple disjoint parts factor step length fractal curve tends infinity detail added tu curve examples self similar fractal curve constructions shown examples illustrate jagged appearance objects higher fractal dimensions also use generators multiple disjoint components exam ples compound generators shown using random variations compound generators model various natural objects com pound parts island distributions along coastlines shows example self similar construction using multi ple scaling factors fractal dimension object determined eq 102 example self similar fractal construction tor surface scale regular tetrahedron shown factor place scaled section 18 fractal geometry methods front face scated copy tetrahedron b scaling tetrahedron factor positioning scaled version one face original tetrahedron produces fractal surface b object original four surfaces tetrahedron face original tetrahedron converted smaller faces original face area increased factor fractal dimension surface in6 indicates fairly fragmented surface another way create self similar fractal objects punch holes given initiator instead adding surface area shows examples fractal objects created way geometric construction statistically self similar fractals one way introduce randomness geometric construction self similar fractal choose generator randomly step set predefined shapes another way generate random self similar objects compute coordinate displacements randomly example cre ate random snowflake pattern selecting random midpoint displacement distance step self similar tiree dimensional fractals formed generators subtract subparts initiator courtesy john c hart washington state university modified snowflake pattern using random midpoint displacement displays trees plants constructed similar geometric methods shows self similar construction fern figure branch scaled version total object b shows fully rendered fern twist applied branch another example method shown random scaling parameters branching directions used model vein patterns leaf set fractal objects created model scene plac ing several transformed instances fractal objects together il lustrates instancing simple fractal tree fractal forest dis layed model gnarled contorted shapes trees apply twisting functions well scaling create random self similar branches b self similar constructions fern courtesy peter oppenheimer computer ha graphics lab new york institute technology fighre 78 random self similar construction vein branching fall leaf boundary leaf limit vein growth courtesy peter oppenheimer computer graphics lab new york institute technology modeling scene using multiple object instancing fractal leaves attached tree several instances tree used form grove grass modeled multiple instances green cones courtesy john c hart washington state university technique illustrated starting tapered cylinder left figure apply transformations produce succession left right spiral helix random twisting pattern tree modeled random twists shown tree bark display mod eled using bump mapping fractal brownian variations bump patterns discussed following section fractal forest created multiple instances leaves pine needles grass tree bark courtesy john c hart washington state university modeling tree branches spiral helical random twists courtesy peter oppentteimer computer graphics lab new york institute technology example brownian motion random walk xy plane tree branches modeled random squiggles courtesy peter oppenheimer computer graphics lab new york institute technology affine fractal construction methods obtain highly realistic representations terrain natural objects using affine fractal methods model object features fractional brownian mo tion extension standard brownian motion form random walk describes erratic zigzag movement particles gas otner fluid illustrates random walk path xy plane starting given position generate straight line segment random direction random length move endpoint first line segment repeat process procedure repeated number line seg ments calculate statistical properties line path time interval fractional brownian motion obtained adding additional parameter statistical distribution describing brownian motion addi tional parameter sets fractal dimension motion path single fractional brownian path used model fractal curve two dimensional array random fractional brownian elevations brownian motion planet observed surface fractional brownian motion pianet added craters foreground courtesy r v voss b b mandelbrot adapted fractal geometry nature benoit b mandelbrot new york w h freeman co ground plane grid model surface mountain connecting el evations form set polygon patches random elevations generated surface sphere model mountains valleys oceans planet brownian motion used create elevation variations planet surface elevations color coded lowest eleva tions painted blue oceans highest elevations white snow mountains fractional brownian motion used create terrain fea tures foreground craters created random diameters ran dom positions using affine fractal prc cedures closely describe distribu tion observed craters river islands rain patterns similar systems objects adjusting fractal dimension fractional brownian motion calcu lations vary ruggedness terrain features values fractal di mension neighborhood 15 produce realistic mountain features higher values close used create unusual looking extrater restrial landscapes also scale calculated elevations deepen val leys increase height mountain peaks examples terrain fea tures modeled fractal procedures given scene modeled fractal clouds fractal mountain shown random midpoint displacement methods fractional brownian motion calculations time consuming eleva tion coordinates terrain ground plane calculated fourier series sums cosine sine terms fast fourier transform fft methods typically used still slow process generate fractal moun tain scenes therefore faster random midpoint displacement methods similar random displacement methods used geometric constructions developed approximate fractional brownian motion representations terrain natural phenomena methods originally used generate animation frames science fiction films involving unusual terrain planet features midpoint displacement methods commonly used many ap plications including television advertising animations although random midpoint displacement methods faster frac tional brownian motion calculations produce less realistic looking terrain features illustrates midpoint displacement method generat ing random walk path xy plane starting straight line segment calculate displaced value midposition line average endpoint values plus random offset yet lua b r 103 approximate fractional brownian motion choose value r gaussian distribution mean variance proportional lb al h fractal dimension another way obtain tandom offset take r sr b parameter selected surface toughness factor r asa gaussian random value mean variance table lookups used obtain gaussian values process repeated calculating displaced value midposition half subdivided line continue subdivision subdivided line sec tions less preset value step value random vari section 18 fractal geometry methods cj variations terrain features modeled fractional brownian motion courtesy r v voss b b mandelbrot adapted fractal geometry nature benoit b mandelbrot new york w h freeman co b c ken musgrave benoit b mandelbrot mathematics computer science yale university scene modeled fractal clouds mountains courtesy ken musgrave benoit b mandelbrot mathematics computer science yale university b vib yta yta ymid b x b b x random midpoint displacement straight line segment able r decreases since proportional width b line section subdivided shows fractal curve obtained method terrain features generated applying random midpoint displace ment procedures rectangular ground plane begin assign ing elevation z value four corners b c ground plane divide ground plane midpoint edge obtain five new grid positions e f gh elevations midpositions b b ground plane hpoenne wee f f cy cy tb rectangular ground plane subdivided four equal grid sections b first step random midpoint displacement procedure calculate terrain elevations section 18 fractal geometry methods x b random walk path generated straight line segment four iterations random midpoint displacement procedure chapter three dimensiona object representations eight surface patches formed ground plane first step random midpoint displacement procedure generating terrain features e f g h ground plane edges calculated average eleva tion nearest two vertices plus random offset example elevation z midposition e cal ulated using vertices b elevation midposi tion f calculated using vertices b c z yp random values r obtained gaussian distribution mean variance proportional grid separation raised 2h power h fractal dimension surface could also calculate random offsets product surface roughness factor times grid separation times table lookup value gaussian value mean variance elevation z ground plane midposition calculated using positions e g positions f h alternatively could calculate z using assigned elevations four ground plane corners zm 2p process repeated four new grid sections step grid separation becomes smaller selected value triangular surface patches formed elevations generated shows eight surface patches formed first subdivision step level recursion triangles successively subdivided smaller planar patches subdivision process completed patches ren dered according position light sources values illumina tion parameters selected color surface texture terrain random midpoint displacement method applied generate components scene besides terrain instance could use methods obtain surface features water waves cloud patterns ground plane controlling terrain topography one way control placement peaks valleys fractal terrain scene modeled midpoint displacement method constrain calculated ele vations certain intervals different regions ground plane ac complish setting set control surfaces ground plane illus trated calculate random elevation midpoint grid position ground plane depends difference control elevation average elevation calculated position procedure constrains elevations within preset interval control surface ele vations control surfaces ground plane control surfaces used model existing terrain features rocky mountains region constructing plane facets using ele vations contour plot particular region could set elevations vertices control polygons design terrain features also control surfaces shape planes easiest deal could use spherical surfaces curve shaj use random midpoint displacement method calculate grid eleva tions select random values gaussian distribution mean standard deviation functions control elevations one way set values make proportional differ ence calculated average elevation predefined control eleva tion grid position example grid position e set mean standard deviation 2p oe land zc control elevation ground plane position e 1isa preset scaling factor small values say produce tighter conformity terrain envelope larger values allow greater fluctuations terrain height determine values control elevations plane control sur face first calculate plane parameters b c ground plane position x elevation plane containing control polygon calculated zc ax c incremental methods used calculate control elevations posi tions ground plane grid efficiently carry calculations first subdivide ground plane mesh xy positions shown polygon control surface projected onto ground plane determine grid positions within projection control poly gon using procedures similar scan line area filling scan line ground plane mesh crosses polygon edges calcu late scan line intersections determine grid positions interior projection control polygon calculations control elevations grid positions performed incrementally inj axca c ayb c 104 projection triangular control x surface onto ground plane grid section 18 fractal geometry methods representations composite scene modeled random midpoint displacement method planar control surfaces ground plane surface features terrain water clouds modeled rendered separately combined form composite picture courtesy eng kiat koh information technology institute republic singapore ax ay grid spacing x directions procedure particularly fast parallel vector methods applied process control plane grid positions shows scene constructed using control plar es structure surfaces terrain water clouds ground plane surface render ing algorithms applied smooth polygon edges pro vide appropriate surface colors self squaring fractals another method generating fractal objects repeatedly apply transfor mation function points complex space two dimensions complex num ber represented z x iy x real numbers three dimensional four dimensional space points represented quatemnions complex squaring function f z one involves calcu lation z use self squaring functions generate fractal shapes p depending initial position selected iteration repeated appli cation self squaring function produce one three possible results fig 94 transformed position diverge infinity transformed position converge finite limit point called tractor transformed position remains boundary object example nonfractal squaring operation f z z complex plane transforms points according relation unit circle possible outcomes self squaring transformation f z complex plane depending position selected initial position e attractor julia set point z whose magnitude zi greater transformed sequence positions tend infinity point z transformed toward coordinate origin points circle z remain circle functions boundary points move toward infinity tend toward finite limit fractal boundary fracta object called julia set general locate fractal boundaries testing behavior selected positions selected position either diverges infinity converges attractor point try another nearby position repeat process eventually locate position fractal boundary iteration squaring transformation generates fractal shape simple transforma tions complex plane quicker method locating positions fractal curve use inverse transformation function initial point chosen inside outside curve converge position frac tal curve function rich fractals squaring transformation z f z az z 103 assigned constant complex value function use inverse method locate fractal curve first rearrange terms obtain quadratic equation zt27 aa 106 inverse transformation quadratic formula z fl sft vi 47a 107 using complex arithmetic operations solve equation real imaginary parts z locating fractal boundary inverse self squaring function unit circle complex plane nonfractal complex squaring function f z moves points inside circle toward origin points outside circle moved farther away circle initia point circle remains circle chapter three dimensional object x z x v representations im yo im idiser discr diser retain 108 discriminant quadratic formula discr initial values x say calculated discarded begin plot fractal curve also since function yields two possible transformed x positions randomly choose either plus minus sign step iteration long im discr whenever im discr two possible positions second fourth quadrants case x must opposite signs following procedure gives implementation self squaring function two example curves plotted include math h include values h include graphics h typedef struct float x complex float lambdamagsq discrmag complex discr static firstpoint true arstpoint compute divided lambda ry ry pet wo ra rt e met a4 il af x x ow roe l f f dp eres nur ek ns two fractal curves generated inverse function f z az z procedure sel fsquare 3and b curve plotted 000 points static complex fouroverlambda void calculatepoint complex lambda complex lamodamagsq lambda x lamb x lambda ambda fouroverlambda x lambda x lambdamagsq yi fouroverlambda lambda lambdamagsq firstpoin false discr x z x fouroverlambda x z fourover lambda diser z x fouroverlambda z fouroverlambda x discrmag sqrt discr x discr x diser discr update z checking avoid sqrt negative number discrmag discr x z x else zz x sqrt discrmag discr x discrmag discr x g qo else z sqrt discrmag discr x por half points use negative root placing point quad rant random maxint z k k z z imaginary part discriminant negative point lie quadrant reverse sign x discr z x z x pinish calculation real part z ze x x void selfsquare complex lambda complex z int count int k skip first points fcr k k l0 k calculatepoint lambda z k k count k calculatepoint lambda z scale point fit window draw ppoint z x window_width window_height z wwindow_height _i three dimensional plot variables x self squaring func tion f z az z al given cross sectional slice plot fractal curve complex plane famous fractal shape obtained mandelbrot set set complex values z diverge squaring transforma tion 109 k first select point z complex plane compute trans formed position z z next step square transformed position add original z value repeat procedure determine function f z az plotted three dimensions normalized values plotted vertical axis courtesy alan norton 1bm research whether transformation diverging boundary convergence region complex plane fractal implement transformation 109 first choose window com plex plane positions window mapped color coded pixel posi tions selected screen viewport pixel colors chosen ac cording rate divergence corresponding point complex plane transformation 109 magnitude complex number greater quickly diverge self squaring operation therefore set loop repeat squaring operations either magnitude complex number exceeds reached preset number itera tions maximum number iterations usually set value although lower values used speed calculations lower settings iteration limit however tend lose de tail along boundary julia set convergence region end loop select color value according number iterations executed loop example color pixel black iteration count viewport imaginary window n mapping positions complex plane color coded pixel positions ona video monitor maximum value color pixel red iteration count near color values chosen according value iteration count within interval maximum value choosing different color mappings generate variety dramatic displays mandel brot set one choice color coding set shown algorithm displaying mandelbrot set given following procedure major part set contained within following region complex plane 25 z 75 25 im 25 explore details along boundary set choosing successively smaller window regions zoom selected areas display shows color coded display mandelbrot set series zooms illustrate features remarkable set section 18 fractat geometry methods zooming mandelbrot set starting display mandelbrot set zoom selected regions b f white box outline shows window area selected successive zoom courtesy brian evans vanderbilt university include graphics h typedef struct flcat yomplex j comp ex complexsquare lomplex c complex csq csq x esq return csq q xo int iterate complex cinit int maxiteri complex z int cnt quit z z 77 wnile z x x ty z ent maxiter complexsquare zz z x zinit x z zinit ontt return cnt void mandelbrot int nx int ny int maxiter float realmin float realmax float im gmin float imagmax float realinc realmax realmin nx float imaginc imagmax imagmin ny complex z int x yi int cont x c x realmin x nx x z x realinc z ysimagmin ry yt z simagiinc ent iterate z maxiter af cnt maxiter setcolor black else setcolor cnt ppoint x complex function transformations eq 105 extended produce fractal surfaces fractal solids methods generating objects use quaternion representations appendix transforming points three dimensional four dimensional space quaternion four components one real part three imaginary parts represented extension concept number complex plane q stiat jb ke 710 wherei j k real partsisalsoreferred toas scalar part quater nion imaginary terms called quaternion vector part v b c using rules quaternion multiplication addition discussed ap pendix apply self squaring functions iteration methods generate surfaces fractal objects instead fractal curves basic procedure start position inside fractal object generate successive points position exterior diverging point identified previous inte rior point retained surface point neighbors surface point tested determine whether inside converging outside diver rging inside point connects outside point surface point way procedure threads way along fractal boundary without gen erating points far surface four dimensional fractals generated three dimensional slices projected onto two dimensional surface video monitor procedures generating self squaring fractals four dimensional space require considerable computation time evaluating iteration function testing points point surface represented small cube giv ing inner outer limits surface output programs three dimensional projections fractal typically contain million ver tices surface cubes display fractal objects performed applying illumination models determine lighting color surface cube hidden surface methods applied visible surfaces ob jects displayed figures 101 102 show examples self squaring four dimensional fractals projections three dimensions self inverse fractals various geometric inversion transformations used create fractal shapes start initial set points repeatedly apply nonlinear inversion operations transform initial points fractal example consider two dimensiona inversion transformation respect circle radius r center position py x5 yo point p outside circle inverted position p inside circle fig 103 transformation p pxp p 111 section 18 fractal geometry methods three dimensional projections four dimensional fractals generated self squaring quaternion function f q aq q 475 9061i b 57 courtesy alan norton ibm research chapter three dimensional object representations three dimensional surface projection four dimensional object generated self squaring quaternion function f q q courtesy alan norton ibm research inverting point p position p inside circle radius r reciprocally trasformation inverts point inside circle point side circle p p lie straight line passing circle cen ter po coordinates two points p x p write eq 111 ce xp yp yp pf also since two points lie along line passing circle center x x9 x x9 therefore transformed coordi nate values px xx ry yo x _ x xp h mo x xo 112 illustrates inversion points along another circle bound ary long circle inverted pass p transform another circle circle circumference passes pp circle _ originat circle inverted circle inversion circle respect another circle transforms straight line conversely points along straight line passing p invert circle thus straight lines invariant inversion transformation also invariant transformation circles thogonal reference circle tangents two circles perpen dicular intersection points create various fractal shapes inversion transformation starting set circles repeatedly applying transformation using different reference circles similarly apply circle inversion set straight lines similar inversion methods developed objects generalize procedure spheres planes shapes three di mensional space number procedural methads developed generating ob ject details shape grammars sets production rules applied initial object add layers detail harmonious original shape transformations applied alter geometry shape object transformation rules applied add surface color surface texture detail given set production rules shape designer experiment applying different rules step transformation given initial ob ject final structure shows four geometric substitution rules altering triangle shapes geometry transformations rules b rule rule four geometric substitution mules subdividing altering shape equilateral triangle chapter10 written algorithmically system based input picture drawn three dimensional object production rule editor rule described graphically show representations ing initial final shapes implementations set mathemat ica programming language graphics capability application geometric substitutions given fig 106 obtained applying four rules succession starting initial triangle shows another shape created triangle substitution rules b c equilateral triangle converted shape b using substitution mules fig 105 rule used convert b shape c turn transformed using tule copyright andrew glassner xerox parc palo alto research center design created geometric substitution rules altering triangle shapes copyright andrew glassner xerox parc palo alto research center ts design created geometric substitution rules altering prism shapes initial shape design representation rubik snake copyright andrew glassner xerox parc palo alto research center three dimensional shape surface features transformed similar operations shows results geometric substitutions applied polyhedra initial shape objects shown icosahe dron polyhedron faces geometric substitutions applied plane faces icosahedron resulting polygon vertices projected surface enclosing sphere another example using production rules describe shape objects l grammars graftals rules provide method describing plants _ instance topology tree described trunk attached branches leaves tree modeled rules provide particu lar connection branches leaves individual branches geometrical description given placing object structures particular coordinate positions shows scene containing various plants trees con structed commercial plant generator package procedures software constructing plants based botanical laws designs created surface sphere using triangle substitution tules applied plane faces icosahedron followed projections sphere surface copyright andrew classner xerox parc palo alto research center realistic scenery generated tdi amap software package generate varieties plants trees using procedures based botanical laws courtesy thomson digital image 20 particle systems method modeling natural objects irregularly shaped objects exhibit fluid like properties particle systems method particularly good describing objects change time flowing billowing spatter ing expanding objects characteristics include clouds smoke fire fireworks waterfalls water spray clumps grass example particle sys tems used model planet explosion expanding wall fire due genesis bomb motion picture star trek wrath khan random processes used generate objects within defined region space vary parameters time af random time ob ject deleted lifetime particle path surface characteris tics may color coded displayed particle shapes small spheres ellipsoids boxes shapes size shape particles may vary randomly time also properties particle transparency color movement vary randomly applications particle motion may controlled specified forces gravity field particle moves path plotted displayed particular color example fireworks pattern displayed randomly generating particles within spherical region space allowing move radially section 21 partical systems modeling fireworks particle system particles traveling radially outward center sphere outward particle paths color coded red yel low instance simulate temperature exploding particles simi larly realistic displays grass clumps modeled trajectory par ticles shot ground fall back earth gravity case particle paths originate within tapered cylinder might color coded green yellow illustrates particle system simulation waterfall water particles fall fixed elevation deflected obstacle splash ground different colors used distinguish particle modeling clump grass firing particles upward within tapered cylinder particle paths parabolas due downward force gravity simulation behavior waterfall hitting stone circle water particles deflected stone splash ground courtesy brooks l howard department computer scrence university manchester chapter three dimensional object representations paths stage example animation simulating disintegration object shown object left disintegrates par ticle distribution right composite scene formed variety repre sentations given scene modeled using particle system grass fractal mountains texture mapping surface rendering pro cedures object disintegrating cloud particles courtesy autodesk inc scene entitled road point reyes showing particle system grass fractal mountains texture mapped surfaces courtesy pixar copyright pixar nonrigid object rope piece cloth soft rubber ball represented physically based modeling methods describe behavior object terms interaction external internal forces accu rate discription shape terry cloth towel drapped back chair obtained considering effect chair fabric loops cloth interaction cloth threads common method modeling nonrigid object approximate ob ject network point nodes flexible connections nodes one simple type connection spring shows section two dimensional spring network could used approximate behavior sheet rubber similar spring networks set three dimensions model rubber ball block jello homogeneous object use identical springs throughout network want object different properties different directions use different spring properties differ ent directions external forces applied tc spring network amount stretching compression individual springs depends value set spring constant k also called force constant spring horizontal displacement x node position influence force f illustrated spring overstretched closely approximate amount displacement x equilibrium position using hooke law fo f kx ifo t73 f equal opposite restoring force spring stretched node relationship holds also horizontal compression spring amount x similar relationships displacements force compo nents z directions objects completely flexible return original configuration external forces removed want model putty deformable object need modify spring characteristics springs return original shape external forces moved another set applied forces deform object ir way k unstretched pagsiton f external force f pulling ore end spring end rigidly fixed figure hed lo two dimensional spring network constructed identical spring constants k chapter three dimensional object representations instead using springs also model connections nodes elastic materials minimize strain energy functions determine ob ject shape influence external forces method provides better model cloth various energy functions devised describe behavior different cloth materials model nonrigid object first set external forces acting object consider propagation forces throughout network representing object leads set simultaneous equations must solve determine displacement nodes throughout network shows banana peel modeled spring network scene shows examples cloth modeling using energy functions texture mapped pattern one cloth adjusting parameters network using energy function calculations different kinds cloth mod eled illustrates models cotton wool polyester cotton mate rials draped table physically based modeling methods also applied animations accurately describe motion paths past animations often specified using spline paths kinematics motion parameters based modeling flexible behavior banana peel spring network copyright david laidlaw john snyder adam woodbury alan barr computer graphics lab california institute technology modeling flexible behavior cloth draped furniture using energy function minimization copyright gene greger david e breen design research center rensselaer polytechnic institute iba ud modeling characteristics cotton b wool c polyester cotton using energy function minimization copyright david e breen donald h house design research center rensselaer polytechnic institute position velocity physically based modeling describes motion using dynam ical equations involving forces accelerations animation descriptions based equations dynamics produce realistic motions based equations kinematics use graphical methods aid scientific engineering analysis commonly referred scientific visualization involves visualization data sets processes may difficult impossible analyze without graphical methods example visualization techniques needed deal output high volume data sources supercomputers satellite spacecraft scanners radio astronomy telescopes medical scanners mil lions data points often generated numerical solutions computer simulations observational equipment difficult determine trends relationships simply scanning raw data similarly visualization techniques useful analyzing processes occur long time period observed directly quantum mechanical phenomena special relativity effects produced objects traveling near speed light scientific visualization uses methods computer graphics image pro cessing computer vision areas visually display enhance nipulate information allow better understanding data similar methods employed commerce industry nonscientific areas sometimes ferred business visualization data sets classified according spatial distribution according data type two dimensional data sets values distributed surface three dimensional data sets values distributed interior cube sphere region space data types include scalars vectors tensors multivariate data visual representations scalar fields scalar quantity one single value scalar data sets contain values may distributed time well spatial positions also data section 22 visuatization data sets chapter three dimensional object representations values may functions scalar parameters examples physical scalar quantities energy density mass temperature pressure charge resis tance reflectivity frequency water content common method visualizing scalar data set use graphs charts show distribution data values function parameters position time data distributed surface could plot data values vertical bars rising surface interpolate data values display smooth surface pseudo color methods also used distinguish different values scalar data set color coding techniques combined graph chart methods color code scalar data set choose range colors map range data values color range example blue could assigned lowest scalar value red could assigned highest value gives example color coded surface plot color coding data set tricky color combina tions lead misinterpretations data contour plots used display isolines lines constant scalar value data set distributed surface isolines spaced convenient interval show range variation data values region space typical application contour plot elevations ground plane usually contouring methods applied set data values distributed regular grid regular grids equally spaced grid lines data values known grid intersections numerical solutions computer simulations usually set produce data distributions regu lar grid observed data sets often irregularly spaced contouring meth ods devised various kinds nonregular grids often nonregu lar data distributions converted regular grids two dimensional contouring algorithm traces isolines cell cell within grid check ing four corners grid cells determine cell edges crossed financial surface plot showing stock growth potential october stock market crash red indicates high returrs plot shows low growth stocks performed better crash courtesy eng kiat koh information technology institute republic singapore rn nn nn ee ee _ rt regular two dimensional grid yt data values intersection ee _ wa grid lines x grid lines constant ax spacing grid lines constant ay vo ett ea mettre ne nee spacing spacing x c wee co directions may ax particular isoline isolines usually plotted straight line sections across cell illustrated sometimes isolines plotted spline curves spline fitting lead inconsistencies misinterpretation data set example two spline isolines could cross curved isoline paths might true indicator data trends since data values known cell corners contouring packages allow interactive adjustment iso lines researcher correct inconsistencies example three overlap ping color coded contour plots xy plane given fig 125 shows contour lines color coding irregularly shaped space three dimensional scalar data fields take cross sectional slices display two dimensional data distributions slices could ei ther color code data values slice could display isolines visual ization packages typically provide slicer routine allows cross sections color coded contour plots three data sets within region xy plane courtesy national center supercomputing applications university mlinois urbana champaign color coded contour plots surface apple core shaped region space courtesy greg nielson department computer science engineering arizona state university section 22 visualization data sets e path isoline across five grid cells cross sectional slices three dimensional data set courtesy spyglass inc b ebar taken angle shows display generated commercial slicer dicer package instead looking two dimensional cross sections plot one isesurfaces simply three dimensional contour plots fig two overlapping isosurfaces displayed outer surface made transparent view shape isosurfaces constructing isosurface similar plotting isolines except three dimensional grid cells need check values eight corners cell locate sections isosurface shows examples isosurface inter sections grid cells isosurfaces modeled triangle meshes sur face rendering algorithms applied display final shape isosurface generated set watet content values obtained numerical model thunderstorm courtesy bob withelmson department atmospheric sciences national center supercomputing applications university hlinois urbana champaign isosurface intersections grid cells modeled triangle patches volume rendering often somewhat like x ray picture method visualizing three dimensional data set interior informa tion data set projected display screen using ray casting meth ods introduced section 15 along ray path screen pixel fig 129 interior data values examined encoded display often data values grid positions averaged one value stored voxel data space data encoded display depends ap plication seismic data example often examined find maximum minimum values along ray values color coded give formation width interval minimum value medical ap plications data values opacity factors range tis sue bone layers bone layers completely opaque tissue somewhat transparent low opacity along ray opacity factors accu mulated either total greater equal ray exits back three dimensional data grid accumulated opacity value displayed pixel intensity level gray scale color figure 130 shows volume visualization medical data set describing struc ture dog heart volume visualization color coded plot dis tance maximum voxel value along pixel ray displayed data volume volume visualization regular cartesian data grid using ray casting examine interior data values volume visualization data set dog heart obtained eeee plotting color coded distance maximum voxel value pixel courtesy patrick moran clinton potter national center supercomputing applications university himois urbana champaign section 22 visualization data sets three dimensional object chapter representations visual representations vector fields vector quantity v three dimensional space three scalar values v v v one coordinate direction two dimensional vector two components v v another way describe vector quantity giving magnitude v direction unit vector u scalars vector quan tities may functions position time parameters examples physical vector quantities velocity acceleration force electric fields magnetic fields gravitational fields electric current one way visualize vector field plot data point small arrow shows magnitude direction vector method often used cross sectional slices since difficult see data trends three dimensional region cluttered overlapping ar rows magnitudes vector values shown varying lengths arrows make arrows size make arrows differ ent colors according selected color coding vector magnitudes arrow representation vector field cross sectional slices courtesy national center supercomputing applications university illinois urbana champaign also represent vector values plotting field lines streamlines field lines commonly used electric magnetic gravitational fields magnitude vector values indicated spacing field lines direction tangent field shown example streamline plot vector field shown streamlines displayed wide arrows particularly whirlpool vortex effect pre sent example given displays swirling airflow patterns inside thunderstorm animations fluid flow behavior vector field visualized tracking particles along flow direction ee hi ther field line representation lower vector data set section 22 visualization data sets visualizing airflow around cylinder hemispherical cap tilted slightly relative incoming direction airflow courtesy gerald yamasaki j huiltquist sam uselton nasa ames research center twisting airflow patterns visualized wide streamlines inside transparent isosurface plot thunderstorm courtesy bob withelmson department atmospheric sciences nafional center far supercomputing applications university hlinois urbana champaign airflow patterns visualized streamlines particle motion inside transparent isosurface plot thunderstorm rising sphere particles colored orange falling sphere particles blue courtesy bob wilhelmson department atmospheric sciences national center supercomputing applications university llinots urbana champaign example vector field visualization using streamlines particles shown sometimes magnitudes vector quantities displayed often done multiple quantities visualized single position directions vary much region space vector directions less interest visual representations tensor fields tensor quantity three dimensional space nine components represented matrix actually representation used sec ond order tensor higher order tensors occur applications particu larly general relativity examples physical second order tensors chapter three dimensional object representations stress strain material subjected external forces conductivity resis tivity electrical conductor metric tensor gives proper ties particular coordinate space stress tensor cartesian coordinates example represented gy ow oy op 114 ox ty oo tensor quantities frequently encountered anisotropic materials different properties different directions x xy xz elements conductivity tensor example describe contributions electric field components x z directions current x direction usually physical tensor quantities symmetric tensor six distinct values instance xy yx components stress tensor visualization schemes representing six components second order tensor quantity based devising shapes six parameters one graphical representation tensor shown three diagonal elements tensor used construct magnitude direction arrow three diagonal terms used set shape color elliptical disk instead trying visualize six components tensor quantity reduce tensor vector scalar using vector representation simply display vector representation diagonal elements tensor applying tensor contraction operations obtain scalar representa tion example stress strain tensors contracted generate scalar strain energy density plotted points material subject external forces visual representations multivariate data fields applications grid position region space may multiple data values mixture scalar vector even ten representing stress strain tensors elliptical disk rod surface stressed material courtesy bob haber national center supercomputing applications untversity ulinais urbana champaign representing stress strain tensors strain energy density plot visualization crack propagation surface stressed material courtesy bob haber national center supercomputing applications university illinois urbana champaign sor values example fluid flow problem may fluid velocity temperature density values three dimensional position thus five scalar values display position situation similar displaying tensor field method displaying multivariate data fields construct graphical objects sometimes referred glyphs multiple parts part glyph represents physical quantity size color part used display information scalar magnitudes give directional information vector field use wedge cone pointing shape glyph part representing vector example visualization mul tivariate data field using glyph structure selected grid positions shown ligure 138 one frame animated visualization multivariate data field using glyphs wedge shaped part glyph indicates direction vector quantity point courtesy natranal center supercomputing applications university hiunais lirbana champaign visualization data sets chapter three dimenstanal object representations summary many representations developed modeling wide variety ob jects might displayed graphics scene standard graphics objects represented surface mesh polygon facets polygon mesh represen tations tvpically derived representations surface functions quadrics used describe spheres smooth surfaces design applications use superquadrics splines blobby objects represent smooth surface shapes addition struction techniques csg sweep representations useful de signing compound object shapes built set simpler shapes interior well surface information stored octree representa tions descriptions natural objects trees clouds irregu larly shaped objects specified fractals shape grammars particle systems finally visualization techniques use graphic represcntations display numerical types data sets various types numerical data clude sealar vector tensor values also many scientific visualizations require methods representing multivariate data sets contain combination various data types references detailed discuss superquadrics contained barr information blobby object niodeling see blinn metaball mode discussed nishimura soft object model discussed wyville ww lle mcpheeters sources information parametric curve surface representations include bezie burt adelsor barsky kochanek bartels farouki hinds huitric nahas mortenson farin ravers adams octrees quadtrees cre discussed bys doctor yamaguchi kuni fujimura bs carlbom chakravarty vanderschel solic modeling references include casate staten requicha rassizrac information iractal representations see mandellrot 1982 fournier fussel carpenter noston peitgen richter peitgen saupe koh hearn barnsley skape grammars disc ussed glassner particle systems discussed reeves discussion physically based modeling given barzel general introduction visualization methods given ir hearn baker addi tonal intormation specific v sualization methods found sabin lorensen cline drebin carpenter hanrahan sabella lipson keeler frenkel nielson shriver rosenblum ntelson guidelines tor visual displays information given tute exercises hov set ap geomuetac data tables asin fig aun cube setup weanmetre data tables tora unit cube using cas vertex polygon tables bia single poivgon table compare two methods representing unit cube representation using three data tables esamate storage requirenrents tor gach 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 define efficient polygon representation cylinder justify choice repre sentation set procedure establishing polygon tables input set data points defining object devise routines checking data tables consistency com pleteness write program calculates parameters b c bd set three di mensional plane surfaces defining object given plane parameters b c surfaces object devise al gorithm determine whether specified point inside outside object would values parameters 8b c equation plane sur face altered coordinate reference changed right handed system lefi handed system sel algorithm converting specified sphere ellipsoid cylinder polygon mesh representation set algorithm converting specified superellipsoid polygon mesh rep resentation set algorithm converting metaball representation palygon mesh rep resentation write routine display two dimensional cardinal spline curve given input set contro points xy plane write routine display two dimensional kochanek bartels curve given input set control points xy plane determine quadratic b zier blending functions three contro points plot function label maximum minimum values determine b zier blending functions five control points plot function label maximum minimum values write efficient routine display two dimensional cubic b zier curves given set four control points xy plane write routine design two dimensional cubic b zier curve shapes first order piecewise continuity use interactive technique selecting control point positions xy plane section curve write routine design two dimensional cubic b zier curve shapes sec order piecewise continuity use interactive technique selecting control point positions xy plane section curve write routine display cubic b zier curve using subdivision method determine blending functions uniform periodic b spline curves determine blending functions uniform periodic b spline curves write program using forward differences calculate points along two dimen sional uniform periodic cubic b spline curve given input set control points write routine display specified conic xy plane using rational b zier spline representation write routine display specified conic xy plane using rational b spline representation develop algorithm calculating normal vector bezier surface point p u vv write program display specified quadratic curve using forward differences calculate points along curve path write program display specified cubic curve using forward differences lo calculate points along curve path derive expressions calculating forward differences specified quadratic curve exercises chaater three dimensianal object represertations 31 32 33 34 35 36 38 39 40 41 42 43 44 45 46 47 48 49 50 5t 52 derive expressions tor calculaung forward differences specified cubic curve set procedures ter generating description three dimensional object input parameters thai define object terms translational sweep develop procedures generating description three dimensiona object using input parameters define object terms rotational sweep devise algorithm tar generating solid objects cornbinations three dimen sional primitive shapes defined set surfaces using cunstructive solid geometsy methods develop algorithm performing constructive solid geametry modeling using primitive set solids defined octree structures develop algorithm encoding two dimensional scene quadiree represen tation set algorithm loading quadtree representation scene frame buffer display tne scene write routine convert polygon definition three dimensional object octree representation using random midpoint displacement method write routine create moun tain outline starting horizontal fine xy plane write routine calculate elevations ground plane using random mid point cisplacement method write program 2enerating iractal snowtlake koch curve given num ber iteratians write program generate fractal curve far specified number af iterations using one generators 72 fractal dimension vour curve write program generate fractal curves using self squaring function mz vis selected complex constant write program generate fractal curves using self squaring tunction fqx kz ti ro w write routine interactively select diflerent color combinatians displaying mandelbrot set write program interactively select ary rectangular egion mandelbrot set 200m selected region write routine implement point inversion eq 112 tor specified circle given point position devise set geometric substitution rules altering shape equilateral tri angle write program display stages conversion equilateral triangle another shape given set geometric substitulion rules write program model exploding firecracker xy plane using particle system devise algorithm modeling rectangle nonrigid body using identical springs four sides rectangle write routine visualize two dimensional scalar data set using pseudo color methods write routine visualize two dimensional scalar data set using contour lines write routine visualize two dimensional vecto data set using arrow repre sentation vector values make arrows length display ar rows different cclors represent different vector magnitudes chapter three dimensional geometric modeling transformations bie sce e coli thymidytate synthase wm jfm rms tren hg ered ethods geometric transformations object modeling three di mensions extended two dimensional methods including considerations z coordinate translate object specifying three dimensional translation vector determines much object moved three coordinate directions similarly scale object three coordinate scaling factors extension three dimensional rota tion less straightforward discussed two dimensional rotations xy plane needed consider rotations axes perpendicu lar xy plane three dimensional space select spatial ori entation rotation axis graphics packages handle three dimensional rotation composite three rotations one three cartesian axes alternatively user easily set general rotation matrix given orienta tion axis required rotation angle two dimensional case express geometric transformations matrix form sequence transfor mations represented single matrix formed concatenating trices individual transformations sequence three dimensional homogeneous coordinate representation point trans lated position p z position p x z trix operation x x efrfoor e ae 000 p p parameters f specifying translation distances coordinate direc tions x z assigned real values matrix representation eq equivalent three equations xosut yorytth th nn axis etx yz te ltt tl xaxis translating point translation axis vector ty axis ei yi z tait translating object z axis translation vector object translated three dimensions transforming defining points object object represented set polygon sur faces translate vertex surface redraw polygon facets new position obtain inverse translation matrix eq negating translaticn distances ty produces translation opposite di rection product translation matrix inverse produces iden tity matrix generate rotation transformation object must designate axis rotation object rotated amount angular rota tion unlike two dimensional applications transformations carried xy plane three dimensional rotation specified around line space easiest rotation axes handle parallel coor dinate axes also use combinations coordinate axis rotations along appropriate translations specify general rotation convention positive rotation angles produce counterclockwise rotations coordinate axis looking along positive half axis ward coordinate origin agrees earlier discussion rotation two dimensions positive rotations xy plane counter clockwise axes parallel z axis coordinate axes rotations two dimensional z axis rotation equations easily extended three di mensions section rotation chapter b three dimensional geometric modeling transformatons b positive rotation directions coordinate axes counterc ockwise looking toward origin positive io coordinate position axis x xcos ysin xsin ycos uil ze parameter specifies rotation angle homogeneous coordinate form three dimensional z axis rotation equations expressed x cos sing x sa wey _ sin cos oy es z 0 zz section pection ire rotation x rotation object z zz axis write compactly p r p illustrates rotation object z axis transformation equations rotations two coordinate axes obtained cyclic permutation coordinate parameters x z eqs use replacements kayla illustrated substituting permutations eqs get equations x axis rotation ycos zsin e z ysind z cost v x written homogeneous coordinate form x 0 x yo _ cos sine sin cos z 0 x sx x fy z figure cyclic permutation cartesian coordinate axes produce three sets coordinate axis rotation equations chapter ye three dimensional geometric modeling transtormations rotation object x x axis p r p 10 rotation object around x axis demonstrated fig cyclically permuting coordinates eqs give us transformation equations axis rotation zc0s x sing x zsin xcos gt yr matrix representation axis rotation x cos qo sin x _ eld z sind cosd z 0 p r p iyfet3 example axis rotation shown yy ba ae x axis rotation object inverse rotation matrix formed replacing rotation angle negative values rotation angles generate rotations clockwise direc tion identity matrix produced rotation matrix multiplied inverse since anly sine function affected change sign ro tation angle inverse matrix also obtained interchanging rows columns calculate inverse rotation matrix r evalu ating transpose r7 r method obtaining inverse matrix holds also composite rotation matrix general three dimensional rotations rotation matrix axis coincide coordinate axis set composite transformation involving combinations translations coordinate axes rotations obtain required composite matrix first setting transformation sequence moves selected rotation axis onto one coordinate axes set rotation matrix co ordinate axis specified rotation angle last step obtain inverse transformation sequence returns rotation axis original position special case object rotated axis par allel one coordinate axes attain desired rotation fol lowing transformation sequence translate object rotation axis coincides parallel coor dinate axis perform specified rotation axis translate object rotation axis moved back original po sition steps sequence illustrated coordinate position p object figure transformed sequence shown p r p composite matrix transformation r r form two dimensional transformation sequence rotation arbitrary pivot point object rotated axis parallel one coordinate axes need perform additional transformations case also need rotations align axis selected coordinate axis bring axis back original orientation given specifications rotation axis rotation angle accomplish required rotation five steps translate object rotation axis passes coordinate origin rotate object axis rotation coincides one caor dinate axes perform specified rotation coordinate axis section ratation chaper three dimensianal geometric modeling transformations qriginal position object tc rotate object angle l0lgz ilion axis r may z x n b translate rotation axis onto x axis id translate rotation axis original position sequence transformations rotating object axis parallel x axis apply inverse rotations bring rotation axis back ts original orien tation apply inverse translation bring rotation axis back original position transform rotation axis onto three coordinate axes z axis reasonable choice following discussion shows set transformation matrices getting rotation axis onto z axis returning rotation axis original position rotation axis defined two coordinate positions fig one coordinate point direction angles er direction cosines tween rotation axis two coordinate axes assume rotation axis defined two points illustrated direction ro tation counterclockwise looking along axis p p axis vector defined two points v p p phd xy y2 ty unit vector u defined along rotation axis vv u ti b c 13 pie p f x initial step positron translate step p origin rotate p onto axis x step step step ratate axis translate rotate original rotation axis object around orientation original z axis position five transformation steps obtaining composite matrix rotation arbitrary axis rotation axis projected onto z axis components b c unut vector u direction cosines rotation axis bo p22 ce bor 16 iv iv v rotation opposite direction clockwise viewing p p would reverse axis vector v unit vector u point p p first step transformation sequence desired rotation set translation matrix repositions rotation axis passes coordinate origin desired direction rotation accomplish moving point p origin rotation direction specified opposite direction would move p crigin translation matrix x 91 repositions rotation axis object shown section rotation axis rotation dashed line defined points p p direction unit axis vector u determined specified rotation direction translation rotation axis coordinate ongin rotation u around x axis xz plane accomplished rotating u projection u yz plane angle onto axis tb unit vector u rotated x axis bring xz plane rotated around axis align z axis b need transformations put rotation axis z axis use coordinate axis rotations accomplish alignment two steps number ways perform two steps first ro tate x axis transform vector u xz plane swing u around z axis using axis rotation two rotations illustrated one possible orientation vector u since rotation calculations involve sine cosine functions use standard vector operations appendix obtain elements two rotation matrices dot product operations allow us determine cosine terms vector cross products provide means obtaining sine terms establish transformation matrix rotation around x axis de termining values sine cosine rotation angle necessary get u xz plane rotation angle angle projection u yz plane positive z axis lf designate projection u yz plane vector u b c cgsine rotation angle determined dot product u unit vector u along z axls cosa ee lu fu thi gs magnitude vf u vb iff similarly determine sine cross product w u coordinate independent form cross product w xu u lu ju sine 269 cartesian form cross product gives us wxu u wie 2k equating right sides eqs 20 21 noting lu lu dsina h section rotation sing 22 ri determined values cosa sina terms com ponents vector u set matrix rotation u x axis 0 _ c b a2 rl ya cfd 0 matrix rotates unit vector u x axis xz plane next need determine form transformation matrix swing unit vector xz plane counterclockwise around axis onto positive axis orientation unit vector xz plane rotation x axis shown vector labeled u value x component since rotation x axis leaves x component un changed z component magnitude u vector u rotated onto z axis component u lies xz plane determine cosine rotation angle expres sions dot product unit vectors u u uw u cosb 24 fu lu rotation unit vector u since lu lu comparing coordinate independent form cross vector u rotation product xz plane axis positive rotation angle b wu xu uly lu sing 1f aligns u vector u cartesian form u xu uy 26 find sing 27 thus transformation matrix rotation af u axis qo _ r ad 2e 1 transformation matrices 17 23 28 aligned rotation axis positive axis specified rotation angle applied rotation z axis al chapter three dimensianal geometric modeling transformations q wosu uw local coordinate system rotation axis defined unit vector u al8 cos sind sind cos rc 29 1 complete required rotation abou given axis need trans form rotation axis back original position done applying inverse transformations 17 23 28 transformation matrix ratation arbitrary axis expressed composition seven individual transformations r tr mab ry 4a rlc8 rb ra 30 somewhat quicker perhaps less intuitive method obtaining composite rotation matrix r r take advantage form composite matrix sequence three dimensional rotations thoth r tm tm 31 tr tm 0 upper left submatrix matrix orthogonal means tows columns submatrix form set orthogonal unit vectors rotated matrix r onto x z axes respectively ry ry ry r r fa r ia farsa na ra pay 1 therefore consider local coordinate system defined rotation axis simply form matrix whose columns loca unit coordinate vec tors assuming rotation axis parallel coordinate axis form following local set unit vectors uj u ux uy 33 u xu u uy x uz express elements local unit vectors rotation axis uy jy ua uys uy ty wyay kya ur uy wap hea required composite matrix equal product r r uy uy may x2 uy win hy r se 35 wy uy wy 0 matrix transforms unit vectors uz u u onto x z axes spectively thus rotation axis aligned z axis since uy u rotations quaternions efficient method obtaining rotation specified axis use quaternion representation rotation transformation chapter dis cussed usefulness quaternions generating three dirnensional fractals using self squaring procedures quaternions useful also number computer graphics procedures including three dimensional rotation calcula tions require less storage space matrices simpler write quaternion procedures transformation sequences particularly important animations require complicated motion sequences motion interpolations two given positions object one way characterize quatemion appendix ordered pair consisting scalar part vector part q v also think quaternion higher order complex number one real part scalar part three complex parts elements vector v rotation axis passing coordinate origin performed first setting unit quaternion following scalar vector parts co85 v usin 36 u unit vector along selected rotation axis specified ro tation angle axis point position p rotated quaternion represented quaternion notation p w p coordinates point vector part p x z rotation point carried quaternion operation p qpq 37 q v inverse unit quaternion q scalar vec tor parts given eqs 36 transformation produces new quaternion scalar part equal p p 38 vector part calculated dot cross products section rotation ge x fa unit quaternion parameters u rotation specified axis chapter three dimensional geametnc madeling transformations po spt vip ey 2slv xp v vy x pl 39 parameters v rotation values given eqs 36 many computer graphics systems use ethcient hardware implementations vector calcula tions perform rapid three dimensional object rotations transformation 37 equivalent rotation axis passes coordinate origin sequence rotation trans formations eq 30 aligns rotation axis z axis rotates z returns rotation axis original position using definition quaternion multiplication given appendix designating components vector part g v b c evaluate terms eg 39 obtain elemen composite rotation matrix r ri r r r form 2b 2ab 2s 2ac 2sh mp9 2ab 2se 2a 2c 2hc 2sa 40 2ac 2sb 2he 2sa 2a 2b obtain complete general rotation equation 30 need include translations move rotation axis coordinate axis back ils orig inal position ri 14n example perform rotation axis setting unit quaternion parameters 2s g sine cos v sin quaternion vector elements b q c sin substitut ing values matrix 40 using following trigonometric identi ties ee sings 2sin cos sin sing get version z axis rotation matrix r transformation equation similarly substituting unit quaternion rotation values transformation equation 37 produces rotated coordinate values eqs matrix expression tor scaling transformation position p x z rel ative coordinate urigin de written ae ee le doubling size object transformation 42 also moves x object farther origin x x yyap ody 42 z 8s zz 1 p p 43 scaling parameters assigned positive values explicit expressions coordinate transformations scaling relative origin xx xs yy sy z 44 scaling object transformation 42 changes size object repositions object relative coordinate origin also transfor mation parameters equal relative dimensions object changed preserve original shape object uniform scaling result scaling object uniformly scaling parameter set shown scaling respect selected fixed position x z represented following sransformation sequence translate fixed point origin scale object relative coordinate origin using eq 42 translate fixed point back original position sequence transformations demonstrated matrix repre sentation arbitrary fixed point scaling expressed con catenation translate scale translatc transformations u sy x u sy ga z yu sgy sy ta xe yp 451 form inverse scaling matrix either eq 42 eq 45 placing scaling parameters reciprocals inverse xp yer zp fa e xp e ze ic xp ver ze x figure 1t scaling object relative selected fixed point equivalent sequence transformations shown chapter three dinensional geometric modeling transformations trix generates opposite scaling transformation concatenation scaling matrix inverse produces identity matrix addition translation rotation scaling various additional transformations often useful three dimensional graphics appiications two reflection shear reflections three dimensional reflection performed relative selected reflection axis respect selected reflection plane general three dimensional flection matrices set similarly two dimensions reflections rel ative given axis equivalent rotations axis reflections respect plane equivalent rotations four dimensional space reflection plane coordinate plane either xy xz yz think transformation conversion left handed right handed sys tems example reflection converts coordinate specifications right handed system left handed system vice versa shown fig 19 transformation changes sign z coordinates leaving x coordinate values unchanged matrix representation reflection points relative xy plane 0 rf 46 0 qo transformation matrices inverting x values defined similarly reflections relative yz plane xz plane respectively reflections planes obtained combination rotations cvordinate plane reflections reflection relative xy plane woe x x conversion coordinate specifications right handed left handed system carried reflection transformation 46 shears section omposite transformations shearing transformations used modify object shapes also use ful three dimensional viewing obtaining general projection transforma tions two dimensions discussed tranformations relative x axes produce distortions shapes objects three dimensions also generate shears relative z axis asan example three dimensional shearing following transformation produces z axis shear hi 4o clo co co oo parameters b assigned real values effect transforma tion matrix alter x coordinate values amount propor tional z value leaving z coordinate unchanged boundaries planes perpendicular z axis thus shifted amount propor tional z example effect shearing matrix unit cube shown shearing values shearing matrices axis axis defined similarly b woe composite transformations igure f120 unit cube sheared b transformation matrix two dimensional transformations form composite three dimen 47 witha b sional transformation multiplying matrix representations individ ual operations transformation sequence concatenation carried right left rightmost matrix first transformation ap plied object leftmost matrix las transformation follow ing program provides example implementing composite transformation sequence basic three dimensional geometric transformations combined produce single composite transformation applied coor dinate definition object include math h include ygraph ics h define pf typedef fioat matrixdxd 4a matrix4xd themmatrix void matrixdx4seridentity matirixdx4 mirj c r multiplies matrix times b putting result b void matrix4x4premultiply matrix4x4 matrix4x4 b int r matrix4 tmp r r r c c c cmp rjlc alr bid ci alr iitb te alr b c alr b c r r r c eva crt blrife tmelri ct veic translate3 float tx float ty float tz matrix4x4d matrix4xdsetidertity mf tx ty ml2 tz matrix4x4premultiply thematrix void scale3 float sx float sy float sz wcept center matrix4x4 matrix4xdsetidentity sx sx center x sy mfl sy center z sz sz center z matrix4x4premultiply thematrix void rotace jwept3 pl wept3 p2 float radianangle float lenatn sqrt p2 x pl x pz x pl x p2 pl p2 pl p2 z pl 2z p z pl z float cosazz cosf radianangle float sinaz sinf radianangle float sinaz p2 x pl x length float b simaz p2 pl length float c sina2 p2 z pl z length matrix4x4 translate3 pl x pl pl z matrix4x4setidentity im b b ctc l atb cosa2 c q ate cosa2 b jol b casa2 c j l ata e te l b e cosa2 atc cosa2 b btc cosa2 b b matrix4xdpremultiply thematrix translate3 pl x pl pl z void transformpsints3 int npts wcpt3 pts int k jj float tmp ik k npts k j j j thematrix j pts k thematrix j setwept3 pts k tmp tmp tmpiz void main int argc char argv wept3 pts 10 10 50 50 10 wept3 pl 10 p2 10 wept3 refpt 0 long windowid opengraphics argv setbackground white setcolor blue ppolyline3 pts matrix4x4setidentity thematrix rotate3 pl p2 pi scale3 75 75 refpt translate transformpoints3 pts setcolor red ppolyline3 pts sleep closegraphics windowid set matrices modeling transformations functions sim lar given chapter two dimensional transformations major difference specify rotations around coordinate axis functions translate translatevector matrixtranslate rotatex ithetax xmatrixrotate rotateyy ithetay ymatrixrotate rotatezz thetaz zmatrixrotate scale3 scalevector matrixscale tmp thematrix j pts k x thematrix j pts k chapter three dimensianal geometric modeling transformations functions produces transformation matrix used transform coordinate positions expressed homogeneous column vec tors parameter translatevector pointer list translation distances similarly parameter scalevector specifies three scaling para meters sy rotate scale matrices transform objects respect coordinate origin constrict composite transformations functions composematrix3 buildtransformarionmatrix3 composetransformrat 1onmatrix3 parameters similar two dimensional transformation functions setting composite matrices except specify three rotation angles order transformation sequence buildtransformationma trix3 composetransformationmatrix3 functions two dimensions scale rotate translate specified transformation matrix apply matrix specified points transformfoint inpoint matrix outpo nt addition set transformations hierarchical constructions using structures function setlocaltranstormation3 matrix type parameter matrix specifies elements transformation trix parameter type assigned one following three values pre concatenate postconcatenaty replace far discussed three dimensignal transformations operations move objects one position another within single reference frame many tines however interested switching coordinates one system anc ther general three dimensional viewing procedures exam ple involve initial transformation world coordinate descriptions view ing oordinate system viewing coordinates transformed device coor dinates modeung objects often described local modeling coordinate reference frame objects repositioned wortd coordi nate scene example tables chairs furniture defined local modeling coordinate system placed description room defined another reference frame transforming furniture coordinates roam coordinates room might transformed larger scene con structed world coordinates example use multiple coordinate systems hierarchical modeling three dimensional objects given figure illus trates simulation tractey movement tractor moves tractor coordi nate svstem front wheel coordinate system move world coordinate tractor yow zz world xe zz xt eront wheel system possible coordinate systems used simulating tractor movement wheel rotations described front wheel system turning tractor described rotation front wheel system tractor system wheel tractor reference frames move world coordinate system system front wheels rotate wheel system wheel system ro tates tractor system tractor turns three dimensiona objects scenes constructed using structure segment operations similar discussed chapter modeling transfor mation functions applied create hierarchical representation three di mensional objects define three dimensional object shapes local mod eling coordinates construct scene hierarchical representation instances individual objects transform object descriptions modeling coordinates world coordinates tu another system hierarchy example phigs structure hierarchy shown display generated phigs toolkit software developed university upper _tody ee sees esa pin ns ef displaying object hierarchy chin met using phigs toolkit package developed university manchester displayed object tree phigs structure courtesy l howard j g williams w hewitt department computer science university manchester united kingdom right leer _aren gt_em en section modcling coordinate transformations three dimensional modeling ball stick representation key amino acid residues interacting natural substrate thymidylate synthase modeled rendered julie newdull ucsf computer graphics lab b cad model showing individual engine components rendered ted malone fti 3d magic courtesy silican graphics inc manchester provide editor windows menus interface tools phigs applications shows two example applications three dimensional modeling coordinate descriptions objects transferred one system procedures used obtain two dimensional coordinate transformations need set transformation matrix brings two coordinate systems alignment first set translation brings new coordinate origin position coordinate origin fol lowed sequence rotations corresponding coordinate axes different scales used two coordinate systems scaling transformation may also necessary compensate differences coordinate intervals second coordinate system defined origin x9 yo zp arid unit axis vectors shown relative existing cartesian reference frame first construct translation matrix x9 next use unit axis vectors form coordinate rotation matrix transformation object description one coordinate system another ur r 48 uy wy 01 transforms unit vectors u uy u onto x z axes respec tively complete coordinate transformation sequence given composite matrix r matrix correctly transforms coordinate descriptions one cartesian system another even one system left handed right handed summary three dimensional transformations useful computer graphics applications clude geometric transformations within single coordinate system tranfor mations different coordinate systems basic geometric transforma tions translation rotation scaling two additional object transformations reflections shears transformations different coordinate systems common elements modeling viewing routines three dimensions transformation operations represented matrices two di mensional graphics methods composite transformation three dimensions obtained concatenating matrix representations individual compo nents overall transformation representations translation scaling straightforward extensions two dimensional transformation representations rotations however need general representations since objects rotated speci fied axis space three dimensional rotation represented combi nation basic rotations around x axes many graphics pack ages provide functions three rotations general however efficient set three dimensional rotation using either local rotation axis teference frame quaternion representation quaternions particularly use ful fast generation repeated rotations often required animation sequences reflections shears three dimensions carried relative teference axis space thus transformations also involved corresponding transformations two dimensions transforming object de scriptions one coordinate system another equivalent transforma tion brings two reference frames coincidence finally object model ing often requires hierarchical transformation structure ensures individual components object move harmony overall structure references additional techniques involving matrices modeling three dimensional transforma tions see glassner arvo kirk detailed discussion quater nion rotations given shoemake three dimensional phigs phigs trans formation functions discussed howard et al gaskins blake summary chapter three dimensional geometric modeling transformations exercises 10 14 12 13 14 15 prove muitiplication three dimensional transformation matrices follawing sequence operations commutative two successive translations b two successive scaling operations c two successive rotations one coordinate axes using either eq 30 q 41 prove two successive rotations given rotation axis js commutative evaluating terms eq 39 derive e ements general rotation matrix given eq 1t show rotation matrix 35 equal composite matrix r g8 rta prove quaternion rotation matrix eq 40 reduces matrix representa tion eg rotation axis coordinate axis prove fy 41 i6 equivalent general rotation transformation given eq 30 write procedure implement general rotation transformations using rotation matix write routine ta implement quaternion rotations fg 41 specified axis derive transturmation matrix scaling object sca ing factor sin direc tion defined direction angles b develop alganthm scaling object defined octree representation develop procedure animating object incrementally rotating specified axis js2 appropriate approximations uigonometric equations speed calculations reset object ts initial position com plete revolution axis devise procedure rotating object represented octree structure develop routine reflect object arbitrarily selected plane write program shear object respect three coordinate axes using input yalues shearing parameters develop procedure coaverting object definitior one coordinate reference coordinate system defined elative lirst system develop complete algorithm implementing procecures constructive sohd modeling combining three dimensional primitives generate new shapes initially prim tives combined form subassemblies subassem blies comb ned primil shapes form final assembly interactive input translation rotation parameters used po sition objects output algorithm ihe sequence af operatians needed produce final csg object chapter three dimensional viewing n two dimensional graphics applications viewing operations transfer posi tions world coordinate plane pixel positions plane output device using rectangular boundaries world coordinate win dow device viewport two dimensional package maps world scene device coordinates clips scene four boundaries view port three dimensional graphics applications situation bit volved since choices views generated first view object spatial position front back could generate view would see standing middle group objects inside single object building additionally three dimensional descriptions objects must pro jected onto flat viewing surface output device clipping boundaries enclose volume space whose shape depends type projection select chapter explore general operations needed produce views three dimensional scene also discuss specific viewing procedures provided packages phigs gl steps computer generation view three dimensional scene somewhat analogous processes involved taking photograph take snapshot first need position camera particular point space need decide camera orientation way point camera rotate around line sight set di rection picture finally snap shutter scene cropped size window aperture camera light visible sur photographing scene involves selection camera position zz orientation modeling coordinates cocrdinates transtormation world viewing viewing coordinates projection workstation coordinates transformation device coordinates general three dimensional transformation pipeline modeling coordinates final device coordinates faces projected onto camera film need keep mind however camera analogy carried far since flexibility many options generating views scene graphics package camera shows general processing steps modeling convert ing world coordinate description scene device coordinates scene modeled world coordinate positions converted viewing co ordinates viewing coordinate system used graphics packages refer ence specifying observer viewing position position projec tion plane think analogy camera film plane next projection operations performed convert viewing coordinate descrip tion scene coordinate positions projection plane mapped output device objects outside specified viewing limits clipped consideration remaining objects processed visible surface identification surface rendering procedures pro duce display within device viewport generating view object three dimensions similar photographing object walk around take picture angle various distances varying camera orientations whatever appears viewfinder projected onto flat film surface type size camera lens determines parts scene appear final picture ideas incorporated three dimensional graphics packages views scene generated given spatial position orientation aperture size camera specifying view plane choose particular view scene first establishing viewing coordi nate system also called view reference coordinate system shown view plane projection plane set perpendicular ww yn z py xp pr zo right handed viewing coordinate system axes x yp relative toa warld coordinate scene view plane n view plane b orientations view plane specified norma vector coordinates relative world origin position orients view plane gives orientation b specifying view vector twist angle viewing z axis think view plane film plane camera positioned onented particular shot scene world coordi nate positions scene transformed viewing coordinates viewing coordinates projected onto view plane establish viewing coordinate reference frame first pick world coordinate position called view reference point point ts origin viewing coordinate system view reference point often chosen close surface object scene could also choose point center object center group objects somewhere front scene displayed choose point near object think point position might want aim camera take picture object alternatively choose point distance scene could think camera position next select positive direction viewing z axis orien tation view plane specifying view plane normal vector n choose world coordinate position point establishes direction n relative either world origin viewing coordinate origin graphics packages gks phigs example orient n relative world coordinate origin shown view plane normal n di rected line segment world origin selected coordinate position words n simply specified world coordinate vector packages gl silicon graphics instance establish direction n using selected coordinate position look point relative view refer ence point viewing courdinate origin illustrates method defining direction n look point view reference point another possibility set left handed viewing system take n positive axis trom viewing origin look point di rection n nveded establish z direction magnitude irrelevant n normalized tu unit vector viewing calculations finally choose direction view bv specifying vector v called view vector vector used establish positive direction axis vector v also defined world coordinate vector packages specified fis angle z axis shown general crientation normal vector difficult least time consuming deternune direction v precisely perpen dicular n therefore viewing procedures typically adjust user defined ori entation vector v shown v projected plane perpendicular normal vector choose view vector v convenient direction long parallel n example con mee orientation view plane tora specified look poin p relative ta viewing coordinate origin py p ee ee sider interactive specification viewing reference coordinates using phigs view reference point often set center object viewed want view object angled direction shown simply choose v world vector vector projected plane perpendicular n establish axis much easier trying input vector exactly perpendicular n using vectors n v graphics package compute third vector u perpendicular n v define direction x axis di rection v adjusted perpendicular n u estab lish viewing direction see next section transformation world viewing coordinates computations conveniently car tied unit axis vectors also used obtain elements world viewing coordinate transformation matrix viewing system often described uvn system generally graphics packages allow users choose position view plane restrictions along z axis specifying view plane dis tance viewing origin view plane always parallel x plane projection objects view plane correspond view scene displayed output device gives examples view plane positioning set view plane distance value x plane uv plane af viewing coordinates becomes view plane projec tion transformation occasionally term uv plane used reference viewing plane matter positioned relation x plane use term uv plane mean x plane neces sarily view plane left handed viewing coordinates sometimes used graphics packages viewing direction positive z direction right handed viewing systems common orientation world reference frame allows graphics systems deal one coordinate orientation world viewing references follow convention phigs gl use right handed viewing system al gorithm development obtain series views scene keep view reference point fixed change direction n shown corresponds generating views move around viewing coordinate origin interac fiyure 10 view plane positioning along z axis na adjusted vote p n adjusting input position view vector v toa position perpendicular normal vector n desired yup direction choosing v along axis sets orientation view plane desired direction right handed viewing system defined unit vectors u v n chapter v three dimensiona viewing viewing scene different directions fixed view reference point tive applications normal vector n viewing parameter often changed changing direction n view scene di rection except along line v obtain either two possible views along line v would need change direction v want simulate camera motion scene keep n fixed move view reference point around yo po py n moving around scerie n vo changing position view reference point transtormation trom world viewing coordinates object descriptions projected view plane must trans ferred viewing coordinates conversion object descriptions world viewing coordinates equivalent transformation superimposes viewing reference frame onto world frame using basic geometric trans late rotate operations discussed section transformation sequence j translate view reference point origin world coordinate sys tem apply rotations align x z axes world x z axes respectively hf view reference point specified world position x yy zo point translated world origin matrix transformation x z 1 rotation sequence require three coordinate axis rotations de pending direction choose n general n aligned world coordinate axis superimpose viewing world systems transformation sequence r r r first rotate around world x axis bring z x z plane rotate around world axis align z z axes final rotation z axis align axes view reference system left handed reflection one viewing axes example z axis also necessary illus trates general sequence translate rotate transformations composite transformation matrix applied world coordinate descriptions trans fer viewing coordinates another method generating rotation transformation matrix cal culate unit uum vectors form composite rotation matrix directly dis aligning viewing system world coordinate axes using sequence translate rotate transformations section viewmg coordinales chapter cussed section given vectors n v unit vectors calculated three dimensional viewing n tnt ny mg m3 vxxn u tv xn iy u ven x u vy method also automatically adjusts direction v v perpendic ular n composite rotation matrix viewing transformation uy iy dv u9 d4 ny oo foc fc transforms u onto world x axis v onto axis n onto axis addition matrix automatically performs reflection necessary transform left handed viewing svstem onto right handed world system complete world viewing coordinate transformation matrix ob tained matrix product mwycye r transformation applied coordinate descriptions objects scene transfer viewing reference frame world coordinate descriptions objects scene converted viewing coordinates project three dimensional objects onto two dimensional view plane two basic projection methods parallel projection coordinate positions transformed view plane along parallel lines shown example perspective projection fig 15 object positions transformed view plane along lines con verge point called projection reference point center projection projected view object determined bv calculating intersection projection lines view plane view plane parallel projectian cf abject view plane view p plane projection reference point perspective projection object view plane parallel projection preserves relative proportions objects method used drafting produce scale drawings three dimensional ob jects accurate views various sides object obtained parallel projection give us realistic representation appearance three dimensiona object perspective projection hand produces realistic views preserve relative proportions projections distant objects smaller projections objects size closer projection plane parallel projections specify parallel projection projection vector defines di rection projection lines projection perpendicular view plane orthographic parallel projection otherwise oblique parallel projection illustraces two types parallel pro jections graphics packages gl silicon graphics workstations provide oblique projections package example parallel projection specified simply giving boundary edges rectangular par allelepiped projection reference point view plane tigure 16 perspective projection equal sized objects different distances view plane section projections vhapier hree pimens caal wew ing ortnographie proyction ablique projection fas th figure 17 orientation projection vector v produce orthographic projection oblique projection b orthographic projections often used produce front side top views object shown front side rear orthographic projections object called elevations top orthographic projection called plan view engineering architectural drawings commonly employ orthographic projections lengths anc angles accurately de picted measured drawings also form orthographic projections display one face object views called axonometric orthographic projections commonly used axonometric projection isometric projection gen erate isometric project aligning projection plane intersects coordinate axis object defined called principal axes distance fram origin shows isometric projection pian view side elevation view front elevation view fagyre 18 orthographte projections 1m object displaying plan clevation views isometric projection cube cube isometric projection obtained aligning projection vector cube diagonal eight positions one octant obtaining isometric view three principal axes foreshortened equally isometric projection relative proportions maintained case general axonometric projection scaling factors may different three principal directions transformation equations orthographic parallel projection straightforward view plane placed position z along z axis fig 20 point x viewing coordinates transformed projection coordinates pa original z coordinate value preserved depth information needed depth cueing visible surface determination procedures oblique projection obtained projecting points along parallel lines perpendicular projection plane applications packages oblique projection vector specified two angles shown point x z projected position x view plane ortho graphic projection coordinates plane x oblique projection line x z x makes angle line projection plane joins x x line length l angle horizontal direction projection plane express projection coordinates terms x l x z orthographic projection point onto viewing plane zz section projections chapter three dimensional viewing oblique projection coordirate position x z position x p view plane x x leosd lsing length l depends angle z coordinate point pro jected tana l thus tana rosy 2h l inverse tana also value l z write oblique projection equations x x cos yp sing transformation matrix producing parallel projection onto xy plane written leos lysing arate id parallel orthographic projection obtained l occurs projection angle oblique projections generated nonzero values ly projection matrix 10 structure similar z axis shear matrix fact effect projection matrix shear planes constant project onto view plane x coordinate values within plane constant z shifted amount proportional value plane angles distances anc parallel lines plane projected accurately effect shown back plane box sheared lapped front plane projection viewing surface edge box connecting front back planes projected line length l makes angle horizontal line projection plane common choices angle display combination view front side top front side bottom object two com monly used values tana tana first case views obtained called cavalier projections lines per pendicular projection plane projected change length exam ples cavalier projections cube given projection angle chosen tana resulting view called cabinet projection angle lines perpendicular viewing surface projected one half length cabinet projections appear realistic cavalier projections reduction length perpendiculars shows examples cabinet projections cube perspective projections obtain perspective projection three dimensional object transform points along projection lines meet projection reference point suppose set projection reference point position z along z axis oe po oa vr ta b original coordinete projection description object viewing plane figure 22 oblique projection box onto z plane tal ib cavalier projections cube onto view plane two values angle note depth cube projected equal width height section projections ta th cabinet projections cube onto view plane two values angle depth projected one half width height place view plane z shown write equations de scribing coordinate positions along perspective projection line parametric form xo x xu yo yrye 19 zv u parameter u takes values coordinate position x repre sents point along projection line u position p x z end line u projection reference point coordinates z view plane z z solve z equation parameter u position along projection line zip z ys pf 12 zprp z substituting value u equations x obtain per spective transformation equations p ix en ots lp vor zea 2p orp perspective projection point vi p coordinates x z plano position x yp 2p view plane e te zyep zope 13 vp 2e 2pm 2pm 2p z pisthe distance view plane projection refer ence point using three dimensional homogeneous coordinate representation write perspective projection transformation 13 matrix form xp 0 x yr ool 14 zy 2yg dy 2gzprp dp z h zoe jn representation homogeneous factor n er 15 p projection coordinates view plane calculated homo geneous coordinates x x h vy val 16 original z coordinate value would retained projection coordinates visible surface depth processing general projection reference point along z axis select coordinate position ypq zpry either side view plane projection reference point discuss generalization next section number special cases perspective transformation equations 13 view plane taken uv plane z projection coordinates anes r zpp 17 ac ye e z pee graphics packages projection reference point always taken viewing coordinate origin case projection coor ee dinates viewing plane 78 section projections chapter three dimensional viewing three dimensional object projected onto view plane using per spective transformation equations set parallel lines object parallel plane projected converging lines parallel lines parallel view plane projected parallel lines point set projected parallel lines appears converge called vanishing point set projected parallel lines separate vanishing point general scene number vanishing points depending many sets parallel lines scene vanishing point set lines parallel one princi pal axes object referred principal vanishing point control number principal vanishing points one two three orientation projection plane perspective projections accordingly classified one point two point three puint projections number principal vanish ing points projection determined number principal axes intersect ing view plane illustrates appearance one point two point perspective projections cube b view plane aligned parallel xy object plane object z axis intersected vanishing point ft coordinate ib wnt description ne poin perspective projection e raxis x axis vanishing vanishing point point two point perspective projection perspective views principal vanishing points cube various orientations view plane relative principal axes object orientation produces one point perspective projection z axis vanish ing point view shown c projection plane intersects x z axes axis resulting two point perspective projection contains x axis z axis vanishing points transit ormations camera analogy type lens used camera one factor de termines much scene caught film wide angle lens takes scene regular lens three dimensional viewing rectangu lar view window projection window view plane used effect edges view window parallel x axes window boundary positions specified viewing coordinates shown view window placed anywhere view plane given specification view window sel view volume using window boundaries objects within view volume appear generated display output device others clipped display size view volume depends size window shape view volume depends type projection used generate display case four sides volume planes pass edges window parallel projection four sides view volume form infinite parallelepiped perspective projection view volume pyramid apex projection reference point finite view volume obtained limiting extent volume direction done specifying positions one two additional boundary planes z boundary planes referred front plane back plane near plane far plane viewing volume front back planes parallel view plane specified positions zon planes must side projection reference point back plane must farther projection point front plane including front back planes produces view volume bounded six planes shown orthographic parallel projection six planes form rectangular parallelepiped oblique parallel projection produces oblique parallelepiped view volume perspective projection front back cupping planes truncate infinite pyramidal view volume form frustum front back clipping planes allow us eliminate parts scene viewing operations based depth pick parts scene would like view exclude objects front behind parl want look also perspective projection use front clipping plane take large objects close view plane project unrecognizable sections within view window similarly back clip ping plane used cut objects far projection reference point project small blots output device relative placement view plane front back clipping planes depends type view want tc generate limitations particu lar graphics package phigs view plane positioned anywhere along z axis except contain projection reference point view plane projection window xine yw frenre 27 window specification view plane minimum maximum coordinates given viewing reference system chapter three dimensional viewing xy plane zy window orthographic orthographic projection projection view volume view volume bb x plane zy window oblique projection oblique view volume projection e view volume view volume parallel projection b side top views view volume orthographic projection shawn c side top views oblique view volume shown projection reference point nt x plane xy plane window z window projaction reference point tb c examples perspective projection view valume various positions projection reference point parallelpiped section view volume view volumes general projection transformations back plane frustum view volume front plane parallel projection ta back sn plane sa projection reference front point plane perspective projection b view volumes bounded front back planes top bottom side planes front back planes parallel view plane positions zpon zac along z axis front back planes position relative view plane long projection reference point front back planes figure 31 illustrates possible arrangements front back planes relation view plane default view volume phigs formed unit cube using parallel projection z zpack view plane coincident back plane projection reference point position front plane orthographic paralle projections affected view plane position ing projection lines perpendicular view plane regardless back plane view plane back plane view plane _ view plane back piane _ front plane ch xy front plane front plane b possible arrangements front back clipping planes relative view plane window view plane view plane window projection projection reference reference point point ib changing shape oblique projection view volume moving window position projection vector v determined projection reference point window position location oblique projections may affected view plane positioning de pending projection direction specified phigs oblique projection direction parallel line projection reference point center window therefore moving position view plane moving projection reference point changes skewness sides view volume shown often view plane positioned view reference point front clipping plane generating parallel projection perspective effects depend positioning projection reference point relative view plane shown place projec view view view window window window _ ooh ao l ny vue z att il u projection reference point f vt projection projection reference reference point far bi window c changing perspective effects moving projection reference point away view plane window window ul ul projection projection reference reference point point b projected object size depends whether view plane positioned front object behind relative position projection reference point tion reference point close view plane perspective effects emphasized closer objects appear much larger distant objects size similarly move projection reference point farther view plane difference size near far objects decreases limit move projection reference point infinitely far view plane perspective projection approaches parallel projection projected size object perspective view also affected relative position object view plane view plane front object nearer projection reference point projected size smaller conversely object size increased project onto view plane back object view plane positioning perspective projection also depends whether want generate static view animation sequence static view scene view plane usually placed viewing coordinate ori gin convenient point scene easy adjust size window include al parts scene want view projection reference point positioned obtain amount perspective de sired animation sequence place projection reference point viewing coordinate origin put view plane front scene fig 35 placement simulates camera reference frame set field view lens angle adjusting size window relative distance view plane projection reference point move scene moving viewing reference frame projection reference point move view reference point section view volumes general projection transformations view volume fignre 37 regular parallelepiped view volume obtained shearing view volume scene motion window view plane view plane positioning simulate camera reference frame animation sequence general parallel projection transformations phigs direction parallel projection specified projection vec tor projection reference point center view window figure 36 shows general shape finite view volume given projection vec tor projection window view plane obtain oblique projection transformation shear operation converts view volume fig 36 regular parallelepiped shown elements shearing transformation needed generate view volume shown obtained considering shear transformation projection vector projection vector specified world coordinates must first transformed viewing coordinates using rotation matrix dis cussed section projection vector unaffected translation since simply direction fixed position graphics packages allow specification projection vector viewing coordinates apply shear directly input elements projection vector suppose elements projection vector viewing coordinates vp py py pa 19 need determine elements shear matrix align projection vector v view plane normal vector n transformation expressed window vv figure 36 oblique projection vector associated view volume 29 raue equivalent parallel projection matrix 10 represents z axis shear form mparattet 21 occ ooro oergra ooo explicit transformation equations 20 terms shear parameters b p ap p bp 22 values shear parameters ph ope 23 thus general parallel projection matrix terms ele ments projection vector p p p p 0 myaraiel 24 ooo matrix concatenated transformation r section produce transformation world coordinates parallel projection coordi nates orthographic parallel projection p p myanne iden tity matrix relate components projection vec tor parameters l section similar triangles see l cos _ px ps 25 lsind _ _py zz pz illustrates equivalence elements transformation matrices 24 eqs 25 z p opposite signs positions il lustrated section view volumes general projection transformations x51 vp relationship parallel projection vector v parameters z l general perspective projection transformations phigs programming standard projection reference point lo cated position viewing system except view plane front back clipping planes shows shape finite view volume arbitrary position projection reference point obtain general perspective projection transformation following two opera tions shear view volume centerline frustum perpendicu lar view plane scale view volume scaling factor depends z second step scaling view volume equivalent perspective trans formation discussed section shear operation align general perspective view volume pro frustum centerline view volume view plane xprae vero zoro general shape perspective view volume witha projection reference point axis frustum centerline ux ya iy pf z f ifs fa r uy view plane z z te vd c twi vd enter window shearing general perspective view volume center projection pep ypeo pep window jection window shown transformation effect shift ing positions lie along frustum centerline including window cen ter line perpendicular view plane projection reference point general position x vprp zerp e transformation involves combination 2z axis shear translation alyy pep 26 mohear oo oor shear parameters xpp xwapin xwmax torn 27 p yew yomn ylma zoey points within view volume transformed operation xe x az yy ft wz zpy 28 z projection reference point z axis xpj9 vprp converted position x onal view volume position x sheared frustum appiy scaling transformation produce regular parallelepiped transformation con version section view volumes general projection transformations chapter zz zz tr uj three dimensional viewing x x onl e zprp 2p 29 yon zap zprp 2pm homogeneous matrix representation pry aopen zyrp sup zoep zup ty pry yory2up zomp z zo pry op pry macaie 0 30 te tom orp zep 2pm 2vp therefore general perspective projection transformation ex pressed matrix form mperspective mycate mshea 31 complete transformation world coordinates perspective projection coordinates obtained right concatenating myerspenve composite viewing transformation r section section first explore general ideas involved three dimensional clipping considering clipping could performed using view vol ume clipping planes directly discuss efficient methods using malized view volumes homogeneous coordinates algorithm three dimensional clipping identifies saves surface segments within view volume display output device parts objects outside view volume discarded clipping three dimen sions accomplished using extensions two dimensional clipping meth ods instead clipping straight line window boundaries clip objects boundary planes view volume clip line segment view volume would need test relative position line using view volume boundary plane equations substituting line endpoint coordinates plane equation boundary turn could determine whether endpoint inside outside boundary endpoint x z line segment outside boundary plane ax cz b c plane parameters boundary similarly point inside boundary ar cz lines endpoints outside boundary plane discarded endpoints inside boundary planes saved intersection line boundary found using line equations along plane equation intersection coordinates x z values line satisfy plane equation ax cz clip polygon surface clip individual polygon edges first could test coordinate extents boundary view volume determine whether object completely inside completely outside boundary coordinate extents object inside boundaries save coordinate extents outside boundaries discard wise need apply intersection calculations could deter mining polygon edge intersection positions boundary planes view volume described previous paragraph two dimensional viewing projection operations take place fore view volume clipping clipping objects within view vol ume map interior specified projection window last step transform window contents two dimensional viewport specifies location display output device clipping two dimensions generally performed upright rec tangle dip window aligned x axes greatly sim plifies clipping calculations window boundary defined one coordinate value example intersections lines crossing left boundary window x coordinate equal left boundary view volume clipping boundaries planes whose orientations depend type projection projection window position projection reference point since front back clipping planes parallel view plane constant z coordinate value z coordinate intersec tions lines planes simply z coordinate corresponding plane four sides view volume arbitrary spatial ori entations find intersection line one view volume bound aries means must obtain equation plane containing boundary polygon process simplified convert view volume fore clipping rectangular parallelepiped words first perform projection transformation converts coordinate values view volume orthographic parallel coordinates carry clipping calculations clipping regular parallelepiped much simpler sur face perpendicular one coordinate axes seen top bottom view volume planes constant sides planes constant x front back planes constant z line cut ting top plane parallelepiped example intersection point whose coordinate value top plane case orthographic parallel projection view volume al ready rectangular parallelepiped seen section cblique pro jection view volumes converted rectangular parallelepiped shear ing operation perspective view volumes converted general combination shear scale transformation view volume object intersecting rectangular parallelepiped view volume section clipping modeling coordinates normalized view volumes shows expanded phigs transformation pipeline first step scene constructed transforming object descriptions modeling coordinates world coordinates next view mapping converts world de scriptions viewing coordinates projection stage viewing coordi nates transformed projection coordinates effectively converts view volume rectangular parallelepiped parallelepiped mapped unit cube normalized view volume called normalized projection coordinate system mapping normalized projection coordi nates accomplished transforming points within rectangular paral lelepiped position within specified three dimensional viewport occupies part unit cube finally workstation stage normalized projection coordinates converted device coordinates display normalized view volume region defined planes x x z z 32 similar transformation sequence used graphics packages indi vidual variations depending system gl package example maps rectangular parallelepiped interior cube boundary planes positions coordinate direction several advantages clipping unit cube instead original view volume even rectangular parallelepiped projection coordi nates first normalized view volume provides standard shape repre senting sized view volume separates viewing transformations workstation considerations unit cube mapped workstation size second clipping procedures simplified stan dardized unit clipping planes viewport planes additional clip ping planes specified within normalized space transforming modeling world viewing viewing transformatian coordinates transformation coordinates age ge normalized projection prajection normalization c canes transformation coordinates transformation projection coordinates device l workstation transformation coardinates eel frenre 42 expanded phigs transformation pipeline device coordinates third depth cueing visible surface determination simplified since z axis always points toward viewer projection refer ence point transformed z axis front faces objects normal vectors component along positive z direction back surfaces facing negative z direction mapping positions within rectangular view volume three dimen sional rectangular viewport accomplished combination scaling translation similar operations needed two dimensional window viewport mapping express three dimensional transformation matrix operations form 33 factors ratios dimensions viewport regu lar parallelepiped view volume x z directions xv imax xv min xwrin ymax yomin ywrrax yeni 34 20max 20min zack ztront wm yw nax peace wrinr f min zon mn hon xvinine inine ivinin parallelepiped section clipping view volume unit cube b dimensions view volume three dimensional viewport onan w maxe zy 3d viewport mon view volume boundaries established window limits 7w pin xweays yin ywmox positions zpont ana zpacx front back planes viewport boundaries set coordinate values x_n umax yomins ymax zwmine zupax additive translation factors k k k transforma tion ky xu pmin xwmnind k ymin ymindy k 20min 2front dy 35 viewport clipping lines polygon surfaces scene clipped viewport boundaries procedures similar used two dimensions except objects processed clipping planes instead clipping edges curved surfaces processed using defining equations surface boundary locating intersection lines parallelepiped planes two dimensional concept region codes extended three di mensions considering positions front back three dimensional viewport well positions left right volume two dimensional clipping used four digit binary region code identify position line endpoint relative viewport boundaries three dimen sional points need expand region code six bits point de scription scene assigned six bit region code identifies rela tive position point respect viewport line endpoint position x z assign bit positions region code right left bit ifx xv left bit xvmax right bit ify yv bit yupna bit5 z0_ front bit z 2v back example region code identifies point behind viewport region code indicates point within volume line segment immediately identified completely within viewport endpoints region code either endpoint line segment region cade perform logical operation two endpoint codes result operation nonzero line segment endpoints one six outside gions example nonzero value generated endpoints hind viewport endpoints viewport iden tify line segment completely inside completely outside volume test intersections bounding planes volume two dimensional line clipping use calculated intersection line viewport plane determine much line thrown away remaining part fine checked planes continue either line totally discarded section found inside volume equations three dimensional line segments conveniently expressed parametric form two dimensional parametric clipping methods cyrus beck liang barsky extended three dimensional scenes line segment endpoints p x p yz write parametric line equations x x x u osfuel ym wu z u 36 coordinates x z represent point line two endpoints u point p u puts us py find intersection line plane viewport substitute coordinate value plane appropriate parametric expression eq 36 solve u instance suppose testing line 2umin plane viewport 20min w mn 37 calculated value u range line segment intersect plane consideration point endpoints p p line calculated value u eq 37 interval calculate intersection x coordinates x n hae 2y way oh vl 38 either x range boundaries viewport line intersects front plane beyond boundaries volume line b fig 44 clipping homogeneous coordinates although discussed clipping procedures terms three dimen sional coordinates phigs packages actually represent coordinate posi tions homogeneous coordinates allows various transformations tepresented matrices concatenated efficiency viewing transformations complete homogeneous coordinate positions converted back three dimensional points coordinate position enters transformation pipeline con verted homogeneous coordinate representation x x z section clipping nex en side view two line segments clipped zu nip plane viewport line eq 37 produces value u outside range line b eqs 38 produce intersection coordinates outside range yup yrax various transformations applied obtain final homogeneous point xb ay m2 aya aye x h ay ax ary 39 zy ax ay ay z h aa 4qn gn ay homogeneous parameter h may fact real value clipping performed homogeneous coordinates clipped ho mogeneous positions converted nonhomogeneous coordinates three dimensional normalized projection coordinates vet 40 course problem magnitude parameter h small value normally occur transformations car ried properly final stage transformation pipeline normal ized point transformed three dimensional device coordinate point xy position plotted device z component used depth informa tion processing setting clipping procedures homogeneous coordinates allows hard ware viewing implementations use single procedure parallel perspective projection transformations objects viewed parallel projection could correctly clipped three dimensional normalized coordinates pro vided value altered operations perspective projections general produce homogeneous parameter longer value converting sheared frustum rectangular parallelepiped change value homogeneous parameter must clip homoge neous coordinates sure clipping carried correctly also ratio nal spline representations set homogeneous coordinates arbitrary values homogeneous parameter including h negative values homogeneous parameter also generated perspective projections coordinate positions behind projection reference point occur applications might want move inside building object view interior determine homogeneous viewport clipping boundaries note homogeneous coordinate position x inside viewport sat isfies inequalities xvnin waa ymin ym zumin s2vepax 41 2h h thus homogeneous clipping limits wxvmin sx_ sma ayvmin vn shyvmax zin sz sanz avenax sx_ savg hyp max sv_ shyv pine nz pax sz haw ifh 42 clipping carried procedures similar discussed pre vious section avoid applying sets inequalities 42 simply negate coordinates point h use clipping inequalities h graphics processes implemented hardware typically view ing visible surface identification shacing algorithms available graph ics chip sets employing vlsi large scale integration circuitry techniques hardware systems designed transform clip project objects output device either three dimensional two dimensional applications illustrates arrangement components graphics chip set implement viewing operations discussed chapter chips organized pipeline accomplishing geometric transformations coordinate system transformations projections clipping four initial chips provided matrix operations involving scaling translation rotation transformations needed converting world coordinates projection coor dinates next six chips performs clipping one viewport boundaries four chips used two dimensional applications two needed clipping front back planes three dimensional viewport last two chips pipeline convert viewport coordinates output device coordinates components implementation vis ible surface identification surface shading algorithms added set provide complete three dimensional graphics system section hardware implementations world coordinate object descriptions transformation operations conversion device coordinates hardware implementation three dimensional viewing operations using chips coordinate transformations clipping operations specialized hardware implementations developed include hardware systems processing octree representations display ing three dimensional scenes using ray tracing algorithms chapter several procedures usually provided three dimensional graphics library enable application program set parameters viewing transforma tions course number different methods structuring procedures wwe discuss phigs functions three dimensional view ing parameters specified world coordinates elements matrix transforming world coordinate descriptions viewing reference frame calculated using function evaluatevieworientationmatrix3 x0 yo xn yn zn xv yv 2v error viewmatrix function creates viewmatrix input coordinates defining view ing system discussed section parameters x0 y0 specify origin view reference point viewing system world coordinate vector xn yn zn defines normal view plane direction positive z viewing axis world coordinate vector xv yv zv gives elements view vector projection vector perpendicular xn yn zn estab lishes direction positive axis viewing system integer error code generated parameter error input values specified correctly example error generated set xv yv zv parallel x yn zn specify second viewing coordinate system redefine coordinate parameters invoke evaluatevieworientationma trix3 new matrix designation way set number world viewing coordinate matrix transformations matrix projmatrix transforming viewing coordinates normal ized projection coordinates created function evaluateviewmappingmatrix3 xwmin xwmax ywmnin ywmax xvmin xvmax yvmin yvmax zvmin zvmax projtype xprojref yprojkef zprojref zview zback zfront error projmatrix window limits view plane given viewing coordinates parame ters xwmin xwmax ywmin ywmax limits three dimensional viewport within unit cube set normalized coordinates xvmin xvmax yvmin yvmax zyvmin zvmax parameter projtype used choose projec tion type either parallel perspective coordinate position xprojref yproj ref zprojref sets projection reference point point used cen ter projection projtype set perspective otherwise point center view plane window define parallel projection vector posi tion view plane along viewing z axis set parameter zview po sitions along viewing z axis front back planes view volume given parameters zfront zback error parameter turns integer error code indicating erroneous input data number pro jection matrix transformations created function obtain various three dimensional views projections particular combination viewing projection matrices selected specified workstation setviewrepresentation3 ws viewindex viewmatrix projmatrix xclipmin xclipmax yelipmin yclipmax zclipmin zclipmax clipxy clipback clipfroent parameter ws used select workstation parameters viewmatrix projmatrix select combination viewing projection matrices used concatenation matrices placed workstation view table referenced integer value assigned parameter viewindex limits given normalized projection coordinates clipping scene set parameters xclipmin xclipmax yclipmin yclipmax zclipmin zclipmax limits set values usually set limits viewport values clip noclip assigned parameters cl ipxy clipfront clipback turn clipping routines xy planes front back planes view volume defined clipping limits section three dimensionat viewing functions several times convenient bypass clipping rou tines initial constructions scene disable clipping trial placements objects displayed quickly also eliminate one clipping planes know objects inside planes view tables set select particular view represen tation workstation function setviewindex viewindex view index number identifies set viewing transformation parameters applied subsequently specified output primitives active workstations finally use workstation transformation functions select sec tions projection window display different workstations oper ations similar discussed two dimensional viewing except window viewport regions aia three dimensional regions window function selects region unit cube viewport function selects dis play region output device limits normalized projection cvordinates window set setworkstationwindow3 ws xwswindmin xwswindmax ywswindmin ywswindmax zwswindmin zwswindmax limits device coordinates viewport set setworkstationviewport3 ws xwsvportmin xwsvportmax ywsvportmin ywsvportmax zwsvportmin zwsvportmax shows example interactive selection viewing parameters phigs viewing pipeline using phigs toolkit software software developed university manchester provide interface phigs viewing editor windows menus interface tools applications composite methods used create display con sisting multiple views using different camera orientations shows using phigs toolkit developed university manchester interactively control parameters viewing pipeline courtesy l j howard g williams w hewit department computer science university manchester united kingdom wide angle view virtual reality display generated seven sections slightly different viewing direction cauriesy national center supercomputing applications university illinois urbana chamrpaign wide angle perspective display produced virtual reality environment wide viewing angle attained generating seven views scene viewing position slight shifts viewing direction summary viewing procedures three dimensional scenes follow general approach used two dimensional viewing first create world coordinate scene definitions objects modeling coordinates set viewing coordinate reference frame transfer object descriptions world coordinates viewing coordinates finally viewing coordinate descriptions transformed device coordinates unlike two dimensional viewing however three dimensional viewing quires projection routines transform object descriptions viewing plane fore transformation device coordinates also three dimensional viewing operations involve spatial parameters use camera analogy describe three dimensional viewing parameters include camera position orientation viewing coordinate reference frame established view reference point view plane normal vector n view vector v view plane position established along viewing z axis object descrip tions projected plane either perspective projection parallel projec tion methods used transfer object descriptions view plane parallel projections either orthographic oblique specified projection vector orthographic parallel projections display one face object called axonometric projections isometric view object obtained axonometric projection foreshortens principal axis amount commonly used oblique projections cavalier projection cabinet projection perspective projections objects ob tained projection lines meet projection reference point objects three dimensional scenes clipped view volume top bottom sides view volume formed planes paral lel projection lines pass view plane window edges front back planes used create closed view volume parallel pro jection view volume parallelepiped perspective projection view volume frustum objects clipped three dimensional viewing testing object coordinates bounding planes view volume clip ping generally carried graphics packages homogeneous coordinates summary viewing transformations complete homogeneous co ordinates converted three dimensional cartesian coordinates references additional information three dimensional viewing clipping operations phigs phigs see howard et al gaskins blake discussions three dimensional clipping viewing algorithms found blinn newell cyrus beck riesenfeld liang barsky arvo blinn exercises 10 11 12 13 14 15 16 17 write procedure implement evaluatevieworientationmatrix3 func tion using eqs write routines implement set viewrepresentation3 set viewindex functions write procedure transform vertices polyhedron projection coordinates using parallel projection specified projection vector write procedure obtain different parallel projection views polyhedron first applying specified rotation write procedure perform one point perspective projection object write procedure perform two point perspective projection object develop routine perform three point perspective projection object write routine convert perspective projection frustum regular paral lelepiped extend sutherland hodgman polygon clipping algorithm clip three dimen sional planes regular parallelepiped devise algorithm clip objects scene defined frustum compare operations needed algorithm needed algorithm clips regular parallelepiped modify two dimensional liang barsky tine clipping algorithm clip three di mensional lines specified regular parallelepiped modify two dimensional liang barsky line clipping algorithm clip given polyhedron specified regular parallelepiped set algorithm clipping polyhedron parallelepiped write routine perform clipping homogeneous coordinates using clipping procedure orthographic parallel projections write program perform complete viewing transformation world coordinates device co ordinates using clipping procedure write program perform complete viewing trans formation world coordinates device coordinates specified parallel projection vector write program perform steps viewing pipeline perspective trans formation chapter visible surface detection methods major consideration generation realistic graphics displays identifying parts scene visible chosen viewing position many approaches take solve problem nu merous algorithms devised efficient identification visible objects different types applications methods require memary volve processing time apply special types objects de ciding upon method particular application depend factors complexity scene type objects displayed available equipment whether static animated displays generated various algo rithms referred visible surface detection methods sometimes methods also referred hidden surface elimination methods although subtle differences identifying visible surfaces eliminat ing hidden surfaces wireframe displays example may want actually eliminate hidden surfaces rather display dashed boundaries way retain information shape chapter explore commonly used methods detecting visi ble surfaces three dimensional scene algorithms visible surface detection algorithms broadly classified according whether deal object definitions directly projected images two approaches called object space methods image space methods spectively object space method compares objects parts objects within scene definition determine surfaces whole label visible image space algorithm visibility decided point point pixel position projection plane visible surface algo rithms use image space methods although object space methods used ef fectively locate visible surfaces cases line display algorithms hand generally use object space methods identify visible lines wire frame displays many image space visible surface algorithms adapted easily visible line detection although major differences basic approach taken var ious visible surface detection algorithms use sorting coherence meth ods improve performance sorting used facilitate depth comparisons ordering individual surfaces scene according distance view plane coherence methods used take advantage regularities scene individual scan line expected contain intervals runs con stant pixel intensities scan line patterns often change little one line next animation frames contain changes vicinity moving ob jects constant relationships often established objects surfaces scene fast simple object space method identifying back faces polyhe dron based inside outside tests discussed chapter point x inside polygon surface plane parameters b c ax cz inside point along line sight surface polygon must back face inside face see front viewing position simplify test considering normal vector n toa polygon surface cartesian components b c general v vector viewing direction eye camera position shown polygon back face v n furthermore object descriptions converted projection coordinates viewing direction parallel viewing z axis v v v n v c need consider sign c z component normal vector n right handed viewing system viewing direction along nega tive z axis polygon back face c also see face whose normal component c since viewing direction grazing polygon thus general label polygon back face mal vector z component value c 33 n abc vector viewing direction back face normal vector n polyhedron section back face detection view concave polyhedron one face partially hidden faces n b c polygon surface plane parameter c oina right handed viewing coordinate system vv identified back face viewing direction along negative axis similar methods used packages employ left handed view ing system packages plane parameters b c calculated polygon vertex coordinates specified clockwise direction instead counterclockwise direction used right handed system inequality remains valid test inside points also back faces normal vectors point away viewing position identified c viewing direction along positive z axis examining parameter c different planes defining object immediately identify back faces single convex polyhedron pyramid test identifies hidden surfaces ob ject since surface either completely visible completely hidden also scene contains nonoverlapping convex polyhedra hidden surfaces identified back face method objects concave polyhedron tests need carried determine whether additional faces tally partly obscured faces general scene expected contain overlapping objects along line sight need determine obscured objects partially completely hidden objects general back face removal expected eliminate half polygon surfaces scene visibility tests commonly used image space approach detecting visible surfaces depth buffer method compares surface depths pixel position projection plane procedure also referred z buffer method since object depth usually measured view plane along z axis viewing system surface scene processed separately one point time across surface method usually applied scenes containing polygon surfaces depth values computed quickly method easy implement method applied nonplanar sur faces object descriptions converted projection coordinates x position polygon surface corresponds orthographic projection point x view plane therefore pixel position x view plane object depths compared comparing z values shows three surfaces varying distances along orthographic projection line position x view plane taken x plane surface closest position surface intensity value x saved implement depth buffer algorithm normalized coordinates z values range back clipping plane front clip view plane position x surface smallest depth view plane visible position ok ping plane value z set either unit cube largest value stored system implied name method two buffer areas required depth buffer used store depth values x position surfaces processed refresh buffer stores intensity values position ini tially positions depth buffer set minimum depth fresh buffer initialized background intensity surface listed polygon tables processed one scan line time calculating depth z value x pixel position calculated depth compared value previously stored depth buffer position calculated depth greater value stored depth buffer new depth value stored surface intensity position determined placed xy location refresh buffer summarize steps depth buffer algorithm follows initialize depth buffer refresh buffer buffer posi tions x depth x refresh x lbackgnd previously stored values depth buffer determine visibility calculate depth z x position polygon ifz depth x set depth z refresh x jun xy lpackgna value background intensity qu x projected intensity value surface pixel position x surfaces processed depth buffer contains depth values visible surfaces refresh buffer contains position polygon surface compare depth values corresponding intensity values surfaces depth values surface position x calculated plane equation surface _ ax c zz section depth butfer method axis x x4 yaxis position x scan line next position across line coordinates x position immediately next line coordinates iy 1d scan line adjacent horizontal positions across line differ vertical value adjacent scan line differs depth posi tion x determined z depth z next position x along scan line obtained eq agw cc 03 n il n ratio c constant surface succeeding depth values across scan line obtained preceding values single addition scan line start calculating depth left edge polygon intersects scan line depth values successive position across scan line calculated eq first determine coordinate extents polygon process surface topmost scan line bottom scan line shown fig starting top vertex recursively calculate x positions left edge polygon x x slope edge depth values edge obtained recursively zz b cc processing vertical edge slope infinite recursive calculations reduce tu goszt ol alternate approach use midpoint method bresenham type al gorithm determining x values left edges scan line also method applied curved surfaces determining depth intensity values surface projection point polygon surfaces depth buffer method easy implement requires sorting surfaces scene require avail ability second buffer addition refresh buffer system resolu top scan tine scan lire left edge intersection bottom scan line scan lines intersecting polygon surface tion section buffer method scan line scan line xx intersection positions successive scan lines along left polygon edge example would require million positions depth buffer position containing enough bits represent number depth increments needed one way reduce storage requirements process one sec tion scene time using smaller depth buffer view section processed buffer reused next section extension ethod f ideas depth buffer method buffer method end alphabet z buffer z represents depth buffer method developed tepresents antialiased area averaged accumulation buffer method lucasfilm implementation surface rendering system called reyes acronym renders everything ever saw drawback depth buffer method find one visible surface pixel position words deals opaque surfaces accumulate intensity values one surface necessary transparent surfaces displayed buffer method ex pands dept list surfaces ation pi h buffer position buffer reference linked thus one surface intensity taken consider xel position object edges antialiased position buffer two fields depth field stores positive negative real number intensity field stores surface intensity information pointer value background opaque surface foreground transparent oo surface viewing opaque surface transparent surface requires multiple surface intensity contributions pixel positions flo gea depth intensiry depth intensity field field field field b organization buffer pixel position single surface overlap corresponding pixel area b multiple surface overlap depth field positive number stored position depth single surface overlapping corresponding pixel area intensity field stores rgb components surface color point percent pixel coverage illustrated depth field negative indicates multiple surface contributions pixel intensity intensity field stores pointer linked list sur face data b data surface linked list includes rgb intensity components opacity parameter percent transparency depth percent area coverage surface identifier surface rendering parameters pointer next surface buffer constructed using methods similar depth buffer algorithm scan lines prucessed determine surface overlaps pixels across individual scanlines surfaces subdivided polygon mesh clipped pixel boundaries using opacity factors percent surface overlaps calculate intensity pixel av erage contributions overlapping surfaces image space method removing hidden surfaces extension scan line algorithm filling polygon interiors instead filling one surface deal multiple surfaces scan line processed ail polygon surfaces intersecting line examined determine visible across scan line depth calculations made overlapping surface determine nearest view plane visible surface determined intensity value position entered refresh buffer assume tables set various surfaces discussed chapter include edge table polvgon table edge table contains coordinate endpoints line scene inverse slope line pointers polygon table identify surfaces bounded line polygon table contains coefficients plane equation sur face intensity information surfaces possibly pointers edge table facilitate search surfaces crossing given scan line set active list edges information edge table active list con tain edges cross current scan line sorted order increasing x addition define flag surface set indicate whether position along scan line inside outside surface scan lines processed left right leftmost boundary surface surface flag turned rightmost boundary tumed illustrates scan line method locating visible portions surfaces pixel positions along line active list scan line contains information edge table edges ab bc eh fg positions along scan line edges ab bc flag surtace therefore depth calculations necessary intensity information sur face entered polygon table refresh buffer similarly tween edges eh fg flag surface positions along scan line intersect surfaces intensity values areas set background intensity background intensity loaded buffer initialization routine scan lines active edge list contains edges ad eh bc fg along scan line edge ad edge eh flag surface edges eh bc flags surfaces interval depth calculations must made using plane coefficients two surfaces example depth surface assumed less s2 intensities surface loaded refresh buffer boundary bc encountered flag surface goes intensities surface s2 stored edge fg passed take advantage coherence along scan lines pass one scan line next scan line active list edges scan line since changes occurred line intersections unneces sary make depth calculations edges eh bc two sur scan lines crossing projection two surfaces view plane dashed lines indicate boundaries hidden surfaces section scan line method intersecting cyclically overlapping surfaces alternately obscure one another subdividing line subdividing faces must orientation determined scan line intensi ties surface entered without calculations number overlapping polygon surfaces processed scan line method flags surfaces set indicate whether position inside outside depth calculations performed surfaces overlap coherence methods used need careful keep track surface section visible scan line works surfaces cut otherwise cyclically overlap lf kind cyclic overlap present scene divide surfaces eliminate overlaps dashed lines figure indicate planes could subdi vided form two distinct surfaces cyclic overlaps eliminated using image space object space operations depth sorting method performs following basic functions surfaces sorted order decreasing depth surfaces scan converted order starting surface greatest depth sorting operations carried image object space scan conversion polygon surfaces performed image space method solving hiddew surface problem often referred painter algorithm creating oil painting artist first paints back ground colors next distant objects added nearer objects forth final step foreground objects painted canvas background objects painted canvas layer paint covers previous layer using similar technique first sort surfaces according distance view plane intensity values farthest surface entered refresh buffer taking succeeding surface turn decreasing depth order paint sur face intensities onto frame buffer intensities previously processed surfaces painting polygon surfaces onto frame buffer according depth carried several steps assuming viewing along z direction surfaces ordered first pass according smallest z value surface surface greatest depth compared sur faces list determine whether overlaps depth depth overlaps occur scan converted shows two surfaces overlap xy plane depth overlap process peated next surface list long overlaps occur sur face processed depth order ail scan converted depth overlap detected point list need make additional comparisons determine whether surfaces reordered make following tests surface overlaps one tests true reordering necessary surface tests listed order increasing difficulty bounding rectangles xy plane two surfaces da lap surface completely behind overlapping surface relative view ing position overlapping surface completely front relative viewing position projections two surfaces onto view plane overlap perform tests order listed proceed next overlapping surface soon find one tests true overlapping surfaces pass least one tests none behind reordering necessary anc scan converted test performed two parts first check overlap x direc tion check overlap direction either directions show overlap two planes obscure one example two two surfaces depth overlap section depth sorting method surfaces overlap z direction x direction shown fig 13 perform tests inside outside polygon test substitute coordinates vertices plane equation overlapping surface check sign result plane equations set outside surface toward viewing position hind vertices inside similarly completely front vertices outside shows overlap ping surface completely front surface completely inside test true tests failed try test checking intersections bounding edges two surfaces using line equations xy plane demonstrated two surfaces may may intersect even though coordinate extents overlap x z directions four tests fail particular overlapping surface inter change surfaces sorted list example two surfaces lt xun xinax x min x mac fryure 13 two surfaces depth overlap overlap x direction x surface sis completely behind inside overlapping surface zz _ ss _ x overlapping surface completely front outside surface completely z behind two surfaces overlapping bounding rectangles xy plane would reordered procedure given point still know certain found farthest surface view plane illustrates situation would first inter change since obscures part need interchange get three surfaces correct depth order therefore need repeat testing process surface reordered list possible algorithm outlined get infinite loop two surfaces alternately obscure sit uations algorithm would continually reshuffle positions overlap ping surfaces avoid loops flag surface ordered farther depth position moved attempt made switch surface second time divide two parts eliminate cyclic overlap original surface replaced twe new surfaces continue processing binary space partitioning bsp tree efficient method determining object visibility painting surfaces onto screen back front painter algorithm bsp tree particularly useful view reference point changes objects scene fixed positions applying bsp tree visibility testing involves identifying surfaces inside outside partitioning plane step space sub division relative viewing direction illustrates basic con cept algorithm plane p first partition space two sets objects one set objects behind back plane p relative view ing direction set front p since one object intersected plane p divide object two separate objects labeled b ob jects c front p objects b 2d behind p next parti tion space plane construct binary tree representation shown b tree objects represented terminal nodes front objects left branches back objects right branches zy surface greater depth obscures surface three surfaces entered sorted surface list order shauld reordered chapter visible surface detection methods pp p p _ oe front pack von back region space partitioned c b two planes p form ty bsp tree representation b objects described polygon facets chose partitioning planes coincide polygon planes polygon equations used identify inside outside polygons tree constructed one partitioning plane polygon face polygon intersected partition ing plane split nto two parts bsp tree complete process tree selecting surfaces display order back front fore ground objects painted background objects fast hardware imple mentations sonstructing processing bsp trees used systems technique hidden surface removal essentially image space method object space operations used accomplish depth ordering surfaces area subdivision method takes advantage area coherence ina scene lo cating view areas represent part single surface apply method successively dividing total viewing area smaller smaller rectangles smail area projection part single visible surface surface implement method need establish tests tnat quickly iden tify area part single surface tell us area complex alyze easily starting total view apply tests determine whether subdivide total area smaller rectangles tests indicate view sufficiently complex subdivide next apply tests smaller areas subdividing tests indicate visibility section single surface still uncertain continue process subdivisions area subdivision method easily analyzed belonging single surface reduced size single pixel easy way successively divide area four equal parts step shown approach similar used constructing quadtree viewing area resolution could subdivided ten times way subarea reduced point tests determine visibility single surface within specified area made comparing surfaces boundary area four pos sible relationships surface specified area boundary describe relative surface characteristics following way surrounding surface one completely encloses area overlapping surface one partly inside partly outside area inside surface one completely inside area dividing square area outside surface one completely outside area equal sized quadrants step tests determining surface visibility within area stated p terms four classifications subdivisions specified area needed one following conditions true surfaces outside surfaces respect area one inside overlapping surrounding surface area surrounding surface obscures surfaces within area bound aries test carried checking bounding rectangles surfaces area boundaries test also use bounding rectangles xy plane identify inside surface types surfaces bounding rec tangles used initial check single bounding rectangle intersects area way additional checks used determine whether sur face surrounding overlapping outside single inside overlapping surrounding surface identified pixel intensities transferred appropriate area within frame buffer one method implementing test order surfaces according minimum depth view plane surrounding surface compute maximum depth within area consideration maxi surrounding overlapping inside outside surtece surface surface surtece possible relationships polygon surfaces rectangular area lange within specified area surrounding surrounding surface surface u ko te maximum depth obscures x surfaces minimum depth beyond zax zi area mum depth one surrounding surfaces closer view plane minimum depth surfaces within area test satisfied figure 22 shows example conditions method another method carrying test require depth sorting use plane equations calculate depth values four vertices area surrounding overlapping inside surfaces calculated depths one surrounding surfaces less calculated depths surfaces test true area filled intensity values surrounding surface situations methods implementing test fail iden tify correctly surrounding surface obscures surfaces testing could carried identify single surface covers area faster subdivide area continue complex testing outside surrounding surfaces identified area remain outside surrounding surfaces subdivisions area furthermore inside overlapping surfaces expected elimi nated subdivision process continues areas become easier alyze limiting case subdivision size pixel produced simply calculate depth relevant surface point transfer intensity nearest surface frame buffer area subdivided using boundary surface view plane variation basic subdivision process could subdivide areas along surface boundaries instead dividing half surfaces sorted according minimum depth use surface small est depth value subdivide given area illustrates method subdividing areas projection boundary surface used parti tion original area subdivisions surface sur rounding surface visibility tests applied determine whether subdividing necessary general fewer subdivisions quired using approach processing needed subdivide areas analyze relation surfaces subdivision boundaries octree representation used viewing volume hidden surface elimination accomplished projecting octree nodes onto viewing surface front back order front face region space side toward viewer formed octants surfaces front octants visible viewer surfaces toward rear front octants back octants may hidden front surfaces back surfaces eliminated viewing direction given processing data elements octree nodes order results depth first traversal octree nodes representing oc tants entire region visited nodes representing octants similarly nodes front four suboctants actant visited nodes four back suboctants traversal oc tree continues order octant subdivision color value encountered octree node pixel area frame buffer corresponding node assigned color value values previously stored area way front colors loaded buffer nothing loaded area void node found completely obscured eliminated processing subtrees accessed different views objects represented octrees obtained apply ing transformations octree representation reorient object according oo numbered octants objects octants region obscure objects back octants viewing viewing direction direction shown section octree methods octants space quadrants tha view plane octant divisions region space corresponding quadrant plane view selected assume octree representation always set octants region form front face method displaying octree first map octree onto quadtree visible areas traversing octree nodes front back recursive proce dure quadtree representation visible surfaces loaded frame buffer depicts octants region space corre sponding quadrants view plane contributions quadrant come octants color values quadrant obtained surfaces octants values two quadrants generated pair octants aligned quadrants recursive processing octree nodes demonstrated following proce dure accepts octree description creates quadtree representation visible surfaces region cases front back octant must considered determining correct color values quadrant front octant homogeneously filled color process back octant heterogeneous regions procedure recursively called pass ing new arguments child heterogeneous octant newly created quadtree node front empty rear octant processed otherwise two recursive calls made one rear octant one front octant typedef enum solid mixed status define empty typedef struct toctree int id status status union int color struct toctree children data octree typedef struct tquadtree int id status status union int color struct tquadtree children data quadtree int nquadtree void octreetoquadtree octree otree quadtree qtree octree front back quadtree newquadtree int otree status solid qtree status solid qtree data color otree data color return qtree status mixed fill quad quadtree front otree data children back otree data children newquadtree quadtree malloc sizeof quadtree newquadtree id nquadtree newquadtree status solid qtree data children newquadtree front status solid front data color empty qfree data children data color front data color else back status solid back data color empty qtree data children data color back data color else qtree data children data color empty else back node mixed newquadtree status mixed octreetoquadtree back newquadtree else front node mixed newquadtree status mixed octreetoquadtree back newquadtree octreetoquadtree front newquadtree consider line sight pixel position view plane scene determine objects scene inter sect line calculating ray surface intersections identify visi ble surface one whose intersection point closest pixel visibil ity detection scheme uses ray casting procedures introduced section 15 ray casting visibility detection tool based geometric optics methods trace paths light rays since infinite number light rays scene interested rays pass ray along line sight pixel position scene section 10 ray casting method chapter visible surface detection methods pixel positions trace light ray paths backward pixels scene ray casting approach effective visibility detection method scenes curved surfaces particularly spheres think ray casting variation depth buffer method sec tion depth buffer algorithm process surfaces one time calculate depth values projection points surface calculated surface depths compared previously stored depths determine visi ble surfaces pixel ray casting process pixels one time cal culate depths surfaces along projection path pixel ray casting special case ray tracing algorithms section trace multiple ray paths pick global reflection refraction contributions multiple objects scene ray casting follow ray pixel nearest object efficient ray surface intersection calculations developed common objects particularly spheres discuss intersection methods detail chapter effective methods determining visibility objects curved surfaces clude ray casting octree methods ray casting calculate ray surface intersections locate smallest intersection distance along pixel ray octrees representation established input defini tion objects visible surfaces identified processing pro cedures special considerations need given different kinds curved surfaces also approximate curved surface set plane polygon sur faces list surfaces replace curved surface polygon mesh use one hidden surface methods previously discussed objects spheres efficient well accu rate use ray casting curved surface equation curved surface representations represent surface implicit equation form f x z parametric representation appendix spline surfaces instance normally described parametric equations cases useful ob tain explicit surface equation example height function xy ground plane z fix many objects interest spheres ellipsoids cylinders cones quadratic representations surfaces commonly used model molecu lar structures roller bearings rings shafts sean line ray casting algorithms often involve numerical approxima tion techniques solve surface equation intersection point scan line pixel ray various techniques including parallel calculations fast hardware implementations developed solving curved sur face equations commonly used objects surface contour plots many applications mathematics physical sciences engineering fields useful display surface function set contour lines show surface shape surface may described equation data tables topographic data elevations population density explicit functional representation plot visible surface contour lines eliminate contour sections hidden visible parts surface obtain xy plot functional surface write surface representa tion form fx curve xy plane platted values z within selected range using specified interval az starting largest value z plot curves front back eliminate hidden sections draw curve sections screen mapping xy range function xy pixel screen range unit steps taken x corresponding value x value determined eq given value z one way identify visible curve sections surface maintain list yam ypu values previously calculated pixel x coordinates screen step one pixel x position next check calculated value stored range yin yas next pixel yrin youx point surface visible plot calcu lated value outside stored bounds pixel point visible plot point reset bounds pixel similar procedures used project contour plot onto xz yz plane shows example surface contour plot color coded contour lines similar methods used discrete set data points determin ing isosurface lines example discrete set z values n n grid xy values determine path line constant surface using contour methods discussed section 21 selected con tour line projected onto view plane displayed straight line color coded surface contour plot courtesy los alamos national laboratory section 11 curved surfaces ib hidden line sections dashed fora line passes behind surface b penetrates surface segments lines drawn display device front back depth order eliminate contour sections pass behind previously drawn visible contour lines outline object displayed visibility tests applied surface edges visible edge sections displayed hidden edge sections either eliminated displayed differently visible edges ex ample hidden edges could drawn dashed lines could use depth cue ing decrease intensity lines linear function distance view plane procedures determining visibility object edges referred wireframe visibility methods also called visible line detection methods hidden line detection methods special wireframe visibility proce dures developed visible surface methods discussed preceding sections also used test edge visibility direct approach identifying visible lines scene compare line surface process involved sifnilar clipping lines arbitrary window shapes except want determine sections lines hidden surfaces line depth values com pared surfaces determine line sections visible use coherence methods identify hidden line segments without actually testing coordinate position line intersections projection surface boundary greater depth surface points line segment intersections completely hidden usual situation scene also possible lines surfaces inter secting line greater depth one boundary intersection less depth surface boundary intersection line must penetrate surface interior b case calculate tersection point line surface using plane equation display visible sections visible surface methods readily adapted wireframe visibility testing using back face method could identify back surfaces object display boundaries visible surfaces depth sort ing surfaces painted refresh buffer surface interiors background color boundaries foreground color process ing surfaces back front hidden lines erased nearer sur faces area subdivision method adapted hidden line removal dis playing boundaries visible surfaces scan line methods used display visible lines setting points along scan line coincide boundaries visible surfaces visible surface method uses scan conver sion modified edge visibility detection method similar way often three dimensional graphics packages accommodate several visible surface detection procedures particularly back face depth buffer methods particular function invoked procedure name back face depthbuf fer general programming standards gks phigs visibility methods implementation dependent table available methods listed installation particular visibility detection method selected hidden line hidden surface removal hlhsr function sethlhsridentifier visibilitypunctionindex parameter visibilityfunctionindex assigned integer code identify visibility method applied subsequently specified output primi tives summary give summary visibility detection methods discussed chapter comparison effectiveness back face detection fast ef fective initial screening eliminate many polygons visibility tests single convex polyhedron back face detection eliminates hidden surfaces general back face detection completely identify hid den surfaces involved visibility detection schemes correctly produce list visible surfaces fast simple technique identifying visible surfaces depth buffer z buffer method procedure requires two buffers one pixel intensities one depth visible surface pixel view plane fast incremental methods used scan surface scene calcu late surface depths surface processed two buffers updated improvement depth buffer approach buffer provides addi tional information displaying antialiased transparent surfaces visi ble surface detection schemes include scan line method depth sorting method painter algorithm bsp tree method area subdivision octree methods ray casting visibility detection methods also used displaying three dimensional line drawings curved surfaces display contour plots wireframe displays polyhedrons search various edge sections surfaces scene visible view plane effectiveness visible surface detection method depends characteristics particular application surfaces scene spread z direction little depth overlap depth sorting bsp tree method often best choice scenes surfaces fairly well sepa rated horizontally scan line area subdivision method used efficiently locate visible surfaces general rule depth sorting bsp tree method highly effective approach scenes surfaces scenes usually surfaces overlap depth scan line method also performs well scene contains small number surfaces either scan line depth sorting bsp tree method used effectively scenes several thousand polygon surfaces scenes contain thousand surfaces depth buffer method octree approach performs best depth buffer method nearly constant processing time independent number surfaces scene size surface areas decreases number surfaces scene increases therefore depth buffer method ex hibits relatively low performance simple scenes relatively high perfor summary mance complex scenes bsp trees useful multiple views generated using different view reference points octree representations used system hidden surface elimi nation process fast simple integer additions subtractions used process need perform sorting intersection calcu lations another advantage octrees store surfaces entire solid region object available display makes octree representation useful obtaining cross sectional slices solids scene contains curved surface representations use octree ray casting methods identify visible parts scene ray casting methods integral part ray tracing algorithms allow scenes displayed global illumination effects possible combine implement different visible surface detec tion methods various ways addition visibility detection algorithms often implemented hardware special systems utilizing parallel processing employed increase efficiency methods special hardware sys tems used processing speed especially important consideration generation animated views flight simulators references additional sources information visibility algorithms include elber cohen franklin kankanhalli glassner naylor amanatides thibault segal exercises develop procedure based back face detection technique identifying visible faces convex polyhedron different colored surfaces assume object defined right handed viewing system xy plane viewing surface implement back face detection procedure using orthographic parallel projection view visible faces convex polyhedron assume parts object front view plane provide mapping onto screen viewport display implement back face detection procedure using perspective projection view visible faces convex polyhedron assume parts object front view plane provide mapping onto screen viewport display write program produce animation convex polyhedron object rotated incrementally axis passes object parallel view plane assume object lies completely front view plane use orthographic parallel projection map views successively onto view plane implement depth buffer method display visible surfaces given polyhe dron storage requirements depth buffer determined definition objects displayed tmplement depth buffer method display visible surfaces scene contain ing number polyhedrons set efficient methods storing processing various objects scene implement buffer algorithm display scene containing opaque transparent surfaces optional feature algorithm may extended clude antialiasing 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 develop program implement scan line algorithm displaying visible surfaces given polyhedron use polygon edge tables store definition object use coherence techniques evaluate points along scan lines write program implement scan line algorithm scene containing several polyhedrons use polygon edge tables store definition object use coherence techniques evaluate points along scan lines set program display visible surfaces convex polyhedron using painter algorithm surfaces sorted depth painted screen back front write program uses depth sorting method display visible surfaces given object plane faces develop depth sorting program display visible surfaces scene containing several polyhedrons write program display visible surfaces convex polyhedron using bsp tree method give examples situations two methods discussed test area subdivision algorithm fail identify correctly surrounding surface ob scures surfaces develop algorithm would test given plane surface rectangular area decide whether surrounding overlapping inside outside surface develop algorithm generating quadtree representation visible sur faces object applying area subdivision tests determine values quadtree elements set algorithm load given quadtree representation object frame buffer display write program system display octree representation object hidden surfaces removed devise algorithm viewing single sphere using ray casting method discuss antialiasing methods incorporated various hidden sur face elimination algorithms write routine produce surface contour plot given surface function f x develop algorithm detecting visible line sections scene comparing line scene surface discuss wireframe displays might generated various visible surface detection methods discussed chapter set procedure generating wireframe display polyhedron hid den edges object drawn dashed lines exercises chapter ilumination models surface rendering methods r ealistic displays scene obtained generating perspective projec tions objects applying natural lighting effects visible sur faces illumination model also called lighting model sometimes ferred shading model used calculate intensity light see given point surface object surface rendering algo rithm uses intensity calculations illumination model determine light intensity projected pixel positions various surfaces scene surface rendering performed applying illumination model every visible surface point rendering accomplished interpolating tensities across surfaces small set illumination model calculations scan line image space algorithms typically use interpolation schemes ray tracing algorithms invoke illumination model pixel position times surface rendering procedures termed surface shading methods avoid confusion refer model calculating light intensity single sur face point ilumination model lighting model use term surface rendering mean procedure applying lighting model obtain pixel intensilies projected surface positions scene photorealism computer graphics involves two elements accurate graphi cal representations objects good physical descriptions lighting ef fects scene lighting effects include light reflections transparency surface texture shadows modeling colors lighting effects see object com plex process involving principles physics psychology fundamen tally lighting effects described models consider interaction electromagnetic energy object surfaces light reaches eyes trig gers perception precesses determine actually see scene phys ical illumination models involve number factors object type object position relative light sources objects light source condi tions set scene objects constructed opaque materials jess transparent addition shiny dull sur faces variety surface texture patterns light sources varying shapes colors positions used provide illumination ef fects scene given parameters optical properties surfaces relative positions surfaces scene color positions light sources position orientation viewing plane illumination mod els calculate intensity projected particular surface point ina specified viewing direction mjumination models computer graphics often loosely derived physical laws describe surface light intensities minimize intensity cal chapter numination models surface rendering methods light source reflecting surface light viewed opaque nonluminous surface general combination reflected light light source reflections light reflections surfaces ne n diverging ray paths froma paint light source culations packages use empirical models based simplified photometric calculations accurate models radiosity algorithm calculate light intensities considering propagation radiant energy surfaces light sources scene following sections first take look basic illumination models often used graphics packages discuss accurate time consuming methods calculating sur face intensities explore various surface rendering algorithms ap plying lighting models obtain appropriate shading visible sur faces scene view opaque nonluminous object see reflected light surfaces object total reflected light sum contributions light sources reflecting surfaces scene thus surface directly exposed light source may still visible nearby objects illuminated sometimes light sources referred light emitting sources reflecting surfaces walls room termed light flecting sources use term light source mean object emitting radiant energy light bulb sun luminous object general light source light reflec tor example plastic globe light bulb inside emits reflects light surface globe emitted light globe may illumi nate objects vicinity simplest model light emitter point source rays source follow radially diverging paths source position shown light source model reasonable approximation sources whose dimensions smal compared size objects scene sources sun sufficiently far scene accurately modeled point sources nearby source long fluorescent light accurately modeled distributed light source case illumi nation effects approximated realistically point source area source small compared surfaces scene accu rate model distributed source one considers accumulated illu mination effects points surface source light incident opaque surface part reflected part absorbed amount incident light reflected surface depends type material shiny materials reflect incident light dull sur faces absorb incident light similarly illuminated transparent object illuminated distributed light source surface incident light reflected transmitted material surfaces rough grainy tend scatter reflected light al di rections scattered light called diffuse reflection rough matte sur face produces primarily diffuse reflections surface appears equally bright viewing directions illustrates diffuse light scattering surface call color object color diffuse flection incident light blue object illuminated white light source example reflects blue component white light totally absorbs components blue object viewed red tight appears black since incident light absorbed addition diffuse reflection light sources create highlights bright spots called specular reflection highlighting effect pronounced shiny surfaces dul surfaces illustration specular reflection shown discuss simplified methods calculating light intensities empiri cal models described section provide simple fast methods calculat ing surface intensity given point produce reasonably good results scenes lighting calculations based optical properties sur faces background lighting conditions light source specifications optical parameters used set surface properties glossy matte opaque transparent controls amount reflection absorption incident light light sources considered point sources specified coordinate position intensity value color ambient light surface exposed directly light source still visible nearby objects illuminated basic illumination model set gen eral level brightness scene simple way model combina tion light reflections various surfaces produce uniform illumination called ambient light background light ambient light spatial di rectional characteristics amount ambient light incident object constant surfaces directions set level ambient light scene parameter surface illuminated constant value resulting reflected light constant surface independent viewing direction spatial orientation surface intensity reflected light surface depends optical properties surface much incident energy reflected much absorbed diffuse reflection ambient light reflection approximation global diffuse lighting effects diffuse reflections constant surface scene independent viewing direction fractional amount incident light diffusely section basic illumination models diffuse reflections surface specular reflection superimposed diffuse reflection vectors chapter illumination models surface rendering methods b surface perpendicular direction incident light illuminated equal sized surface oblique angle b incoming light direction radiant energy surface area da direction relative surface normal direction flected set surface parameter k diffuse reflection coeffi cient diffuse reflectivity parameter k assigned constant value terval according reflecting properties want surface want highly reflective surface set value ky near produces bright surface intensity reflected light near incident light simulate surface absorbs incident light set flectivity value near actually parameter k function surface color time assume k constant surface exposed ambient light express intensity diffuse reflection point surface tambaitt kale since ambient light produces flat uninteresting shading surface fig 19 b scenes rarely rendered ambient light alone least one light source included scene often point source viewing position model diffuse reflections illumination point source similar way assume diffuse reflections surface scattered equal intensity directions independent viewing direc tion surfaces sometimes referred ideal diffuse reflectors also called lambertian reflectors since radiated light energy point surface governed lambert cosine law law states radiant energy small surface area da direction dy relative surface normal proportional cos light intensity though depends radiant energy per projected area perpendicular direction da cosdy thus lambertian reflection intensity light viewing directions discuss photometry concepts terms radiant energy greater detail section even though equal light scattering directions perfect diffuse reflector brightness surface depend orientation surface relative light source surface oriented perpendicular direction incident light appears brighter surface tilted oblique angle direction incoming light easily seen holding white sheet paper smooth cardboard parallel nearby window slowly rotating sheet away window direction angle tween surface normal incoming light direction increases less incident light falls surface shown figure shows beam light rays incident two equal area plane surface patches different spa tial orientations relative incident light direction distant source par acos illuminated area projected perpendicular path incoming light rays incident allel incoming rays denote angle incidence incoming light direction surface normal projected area surface patch perpendicular light direction proportional cos thus amount illumination number incident light rays cutting across projected surface patch depends cos incoming light source perpendicular surface particular point point fully illu minated angle illumination moves away surface normal brightness point drops j intensity point light source diffuse reflection equation point surface written lag kal cos surface illuminated point source angle incidence range cos interval cos negative light source behind surface n unit normal vector surface l unit direction vector point light source position surface cos n land diffuse reflection equation single point source illumination tain kal n l reflections point source illumination calculated world coordinates viewing coordinates shearing perspective transformations ap plied transformations may transform orientation normal vectors longer perpendicular surfaces represent transforma tion procedures maintaining proper orientation surface normals discussed chapter illustrates application eq positions sur face sphere using various values parameter kz pro jected pixel position surface assigned intensity calculated diffuse reflection equation point ight source renderings figure illustrate single point source lighting lighting effects might expect see shined small light object completely darkened room general scenes however expect background light ing effects addition illumination effects produced direct light source combine ambient point source intensity calculations ob tain expression total diffuse reflection addition many graphics packages introduce ambient reflection coefficient k modify ambient light intensity surface simply provides us additional pa rameter adjust light conditions scene using parameter k write total diffuse reflection equation tay kyla kyln l lf light n source angle incidence unit light source direction vector l unit surface normal n chapter iilumination models surface rendering methods kd ka 2 8 diffuse reflections spherical surface illuminated point light source values diffuse reflectivity coefficient interval ks1 diffuse reflections spherical surface illuminated ambient light single point source values k k interval k k depend surface material properties assigned val ues range shows sphere displayed surface intensitities calculated eq values parameters k ky specular reflection phong model look illuminated shiny surface polished metal apple person forehead see highlight bright spot certain viewing di rections phenomenon called specular reflection result total near total reflection incident light concentrated region around specular reflection angle shows specular reflection direction point illuminated surface specular reflection angle equals angle incident light two angles measured opposite sides unit normal surface vector n figure use r represent unit vector direc tion ideal specular reflection l represent unit vector directed toward point light source v unit vector pointing viewer sur face position angle viewing anyle relative specular reflection di rection r ideal reflector perfect mirror incident light reflected specular reflection direction case would see reflected light vectors v r coincide objects ideal reflectors exhibit specular reflections finite range viewing positions around vector r shiny surfaces narrow specu lar reflection range dull surfaces wider reflection range empirical model calculating specular reflection range developed phong bui tuong called phong specular reflection model simply phong model sets intensity specular reflection proportional cos angle assigned values range cos varies value assigned specular reflection parameter n determined type sur face want display shiny surface modeled large value n say smaller values used duller sur faces perfect reflector n infinite rough surface chalk cinderblock n would assigned value near figures 13 14 show effect n angular range expect see specular flections intensity specular reflection depends material properties surface angle incidence well factors polar ization color incident light approximately model monachro matic specular intensity variations using specular reflection coefficient wo surface shows general variation w range materials general w tends increase angle incidence increases wc incident light reflected variation specular intensity angle incidence described fresnel laws reflection using spectral reflection function w write phong specular refiection model fooee wcb cos j intensity light source viewing angle relative specular reflection direction r oa shiny surface oull surface large small n modeling specular reflections shaded area parameter specular reflection angle equals angle incidence 5at beer co ra cost 8 06 4 2 l oo 3ar 45 qo 45 oo cos db oo cast cos os 2 nt td l oa ce qo plots cos several values specular parameter seen transparent materials glass exhibit ap preciable specular reflections approaches percent incident light glass surface reflected range reflected intensity less percent incident intensity many opaque materials specular reflection nearly constant incidence gles case reasonably model reflected light effects replacing w constant specular reflection coefficient k simply set k equal value range surface since v r unit vectcrs viewing specular reflection direc tions calculate value cos dot product v r assuming specular reflection coefficient constant determine intensity specular reflection surface point calculation lpec keliv ry silver approximate variation specular reflection coefficient function angle incidence different materials dielectric glass vector r expression calculated terms vectors l n seen projection l onto direction normal vector ob tained dot product n l therefore diagram r l n l n specular reflection vector obtained r n dl n l illustrates specular reflections various values k n un sphere illuminated single point light source somewhat simplified phong model obtained using halfway vector h l v calculate range specular reflections replace v r phong model dot product n h simply replaces empir ical cos calculation empirical cosa calculation halfway vector obtained l v h tl vl cole ra ey attrition toms os spherical surface varying specular parameter values single light source section basic tllumination models calculation vector r considering projections onto direction normal vector n halfway vector h along bisector angle land v illumination models surface chapter rendering methods viewer light source sufficiently far surface v l constant surface thus h also constant surface points nonplanar surfaces n h requires less computation v r since calculation r surface point involves variable vector n given light source viewer positions vector h orientation di rection surface would produce maximum specular reflection viewing direction reason h sometimes referred surface ori entation direction maximum highlights also vector v coplanar vectors l r thus n angle value v l n coplanar depending spatial relationship three vectors combined diffuse specular reflections multiple light sources single point light source mode combined diffuse specular reflections point illuminated surface tat topec kl kyl l kd n hy illustrates surface lighting effect wioduced various terms eq place one point sour scene obtain light flection surface point summing vontributions individual sources kl kqn l k n 10 trl ensure pixel intensity exceed maximum allowable value apply type normalization procedure simple approach set maximum magnitude term intensity equation cal culated term exceeds maximum simply set maximum value way compensate intensity overflow normalize individual terms dividing magnitude largest term compli cated procedure first calculate pixel intensities scene cal culated intensities scaled onto allowable intensitv range warn model far considered point light sources warn model provides method simulating studio lighting effects controlling light intensity dif ferent directions light sources modeled points reflecting surface using phong model surface points intensity different directions con trolled selecting values phong exponent addition light controls barn doors ane spotlighting used studio photographers sim ulated warn model flaps used control amount light emitted source various directions two flaps provided x z directions spotlights used control amount light emitted within cone apex point source position warn model implemented c id wireframe scene displayed ambient lighting b surface object assigned different color using ambient light diffuse reflections due single source k surfaces obtain lighting effects shown c using ambient light diffuse specular reflections due single light source obtain lighting effects shown phigs illustrates lighting effects produced model intensity attenuation radiant energy point light source travels space amplitude attenuated factor distance light traveled means surface close light source small receives higher inci dent intensity source distant surface large therefore pro duce realistic lighting effects illumination mode take intensity attenuation account otherwise illuminating surfaces intensity matter far might light source two par allel surfaces optical parameters overlap would indistin guishable two surfaces would displayed one surface chapter illumination models surface rendering methods studio lighting effects produced warn model using five light sources illuminate chevrolet camaro courtesy david r warm general motors research laboratories simple point source illumination model however always produce realistic pictures use factor attenuate intensities factor produces much intensity variations small pro duces little variation large real scenes usually illuminated point light sources illumination model sim ple accurately describe real lighting effects graphics packages compensated problems using inverse linear quadratic functions attenuate intensities example general inverse quadratic attenuation function set f tad ad 11 user fiddle coefficients a9 obtain variety lighting effects scene value constant term ay adjusted prevent f becoming large small also values coefficients attenuation function optical surface parameters scene adjusted prevent calculations reflected intensities ex ceeding maximum allowable value effective method limiting intensity values single light source used illuminate scene mul tiple light source illumination methods described preceding section effective limiting intensity range given set attenuation coefficients limit magnitude attenuation function calculation fa min pv ad vad 12 using function write basic illumination model kd fd hk n l n hy 13 l distance light traveled light source light reflections surface black nylon cushion modeled woven cloth patterns rendered using monte carlo ray tracing methods courtesy stephen h westin program computer graphics comell university color considerations graphics displays realistic scenes color illumination model described far considers monochromatic lighting effects incor porate color need write intensity equation function color properties light sources object surfaces rgb description color scene expressed terms red green blue components specify rgb components light source intensities surface colors illumination model calculates rgb components reflected light one way set surface colors speci fying reflectivity coefficients three element vectors diffuse reflection coefficient vector example would rgb components kag kac kag uf want object blue surface select nonzero value range blue reflectivity component k g red green reflec tivity components set zero kyg kig nonzero red green com ponents incident light absorbed blue component flected intensity calculation example reduces single expression ip kyplig fi liplkas n l k p n hy 14 l surfaces typically illuminated white light sources general set surface color reflected light nonzero values three rgb components calculated intensity levels color component used adjust corresponding electron gun rgb monitor original specular reflection model phong set parameter k con stant value independent surface color produces specular reflections color incident light usually white gives sur face plastic appearance nonplastic material color specular flection function surface properties may different color incident light color diffuse reflections approxi mate specular effects surfaces making specular reflection coeffi cient color dependent eq 14 illustrates color reflections matte surface figs 22 23 show color reflections metal light reflections teapot teflectance parameters set simulate brushed aluminum surfaces rendered using monte carlo ray tracing methods courtesy stephen h westin program computer graphics cornell university section basic iiumination models chapter wumination models surface rendering methods light reflections trombones reflectance parameters set simulate shiny brass surfaces courtesy softimage inc surfaces light reflections object surfaces due multiple colored light sources shown another method setting surface color specify components diffuse specular color vectors surface retaining reflectivity coefficients single valued constants rgb color representation stance components two surface color vectors denoted s4a sac sag sg s5c blue component reflected light calcu lated ig kesaales fild ligdkysaa n l k g n h 15 approach provides somewhat greater flexibility since surface color parame ters set independently reflectivity values color representations besides rgb used describe colors scene sometimes convenient use color model three components color specification discuss color models detail next chapter simply represent component color specifi cation spectral wavelength intensity calculations ex pressed ksaalen fadmyilkasaln l k n h 16 imd transparency transparent surface general produces reflected transmitted light relative contribution transmitted light depends degree trans light reflections due multiple light sources various colors courtesy sun microsystems parency surface whether light sources illuminated surfaces behind transparent surface illustrates intensity contributions surface lighting transparent object transparent surface modeled intensity equations must modified include contributions light passing surface cases transmitted light generated reflecting objects back surface reflected light objects passes transparent surface contributes total surface intensity diffuse specular transmission take place surfaces transparent object diffuse effects important partially transparent sur face frosted glass modeled light passing materials scattered blurred image background objects obtained diffuse fractions generated decreasing intensity refracted light spreading intensity contributions point refracting surface onto fi nite area manipulations time comsuming lighting models employ specular effects realistic transparency effects modeled consideririg light refraction light incident upon transparent surface part reflected part refracted speed light different different materi als path refracted light different incident light direction refracted light specified angle refraction function index refraction material direction incident light index refraction material defined ratio speed light vacuum speed light material angle refraction calculated angle incidence index refraction n incident material usually air index refraction refracting material according snell law 17 sin sin h ray traced view transparent glass surface showing light transmission objects behind glass light reflection glass surface courtesy eric haines 3d eye tc incident light transparent object light emission transparent surface general combination reflected transmitted light light n source l teflection direction tefraction direction reflection direction r refraction direction fora ray light incident upon surface index refraction incident fight refraction light glass object emerging refracted ray travels along path parallel incident light path dashed line background object p transparent ae object projection plane intensity background object point p combined reflected intensity surface transparent object along perpendicular projection line dashed actually index refraction material function wave length incident light different color components light ray refracted different angles applications use average index refraction different materials modeled scene index refraction air approximately crown glass using values eq 17 angle incidence yields angle refraction illustrates changes path direc tion light ray refracted glass object overall effect fraction shift incident light parallel path since calculations trigonometric functions eq 17 time consuming refraction effects could modeled simply shifting path incident light small amount snell law diagram obtain unit transmission vector refraction direction r ir cos cos fl 18 n unit surface normal l unit vector direction light source transmission vector used locate intersections fraction path objects behind transparent surface including refraction ef fects scene produce highly realistic displays determination fraction paths object intersections requires considerable computation scan line image space methods model light transmission approximations reduce processing time return topic refraction discussion ray tracing algorithms section simpler procedure modeling transparent objects ignore path shifts altogether effect approach assumes change index refraction one material another angle refraction always angle incidence method speeds calculation tensities produce reasonable transparency effects thin polygon sur faces combine transmitted intensity ian surface background object reflected intensity iq transparent surface using transparency coefficient k assign parameter k value specify much background light transmit ted total surface intensity calculated k lea kilerans term k opacity factor highly transparent objects assign k value near nearly opaque objects transmit little light background objects set k value near materials opacity near also possible allow k function position surface different parts object transmit less background intensity according values assigned k transparency effects often implemented modified depth buffer z buffer algorithms simple way process opaque objects first determine depths visible opaque surfaces depth positions transparent objects compared values previously strored depth buffer transparent surface visible reflected intensity calcu lated combined opaque surface intensity previously stored frame buffer method modified produce accurate displays using additional storage depth parameters transparent ow incident light froma distant source objects modeled shadow regions surfaces allows depth values transparent surfaces compared well depth values opaque surfaces visible transpar ent surfaces rendered combining surface intensities visible opaque surfaces behind accurate displays transparency antialiasing obtained buffer algorithm pixel position surface patches overlapping surfaces saved sorted depth order intensities transparent opaque surface patches overlap depth combined proper vis ibility order produce final averaged intensity pixel discussed chapter depth sorting visibility algorithm modified handle transparency first sorting surfaces depth order determining whether visible surface transparent find visible transparent surface reflected surface intensity combin surface intensity objects behind obtain pixel intensity projected surface point shadows hidden surface methods used locate areas light sources produce shadows applying hidden surface method light source view position determine surface sections seen light source shadow areas determined shadow areas jisht sources shadows could treated surface patterns stored pattern arrays illustrates generation shading pat terns two objects table distant light source shadow areas figure surfaces visible position light source scene shows shadow effects produced multiple light sources shadow patterns generated hidden surface method valid selected viewing position long light source positions changed surfaces visible view position shaded according light ing model combined texture patterns display shadow areas ambient light iniensity combine ambient light specified surface textures values intensitv calculated illumination model must converted one allowable intersitv levels particular graphics system use section displaying light intensities rendering methods systems capable displaying several intensity levels others capa ble two levels pixel first case convert inten sities lighting model one available levels storage frame buffer bilevel systems convert intensities halftone pat terns discussed next section assigning intensity levels first consider grayscale values video monitor distributed range distribution corresponds per ception equal intensity intervals perceive relative light intensities way perceive relative sound intensities logarithmic scale means ratio two intensities ratio two tensities perceive difference pair intensities example perceive difference intensities 20 22 difference 80 88 therefore display n successive intensity levels equal perceived brightness intensity levels monitor spaced ratio successive intensities constant h_k hobble 20 food ba denote lowest level displayed monitor highest j intermediate intensity expressed terms jy rly 21 calculate value r given values j n particular sys tem substituting k preceding expression since va r 22 thus calculation eq 21 rewritten e 23 example ip system n r four intensity values lowest intensity value ij depends characteristics monitor typically range 005 around 025 saw chapter black region displayed monitor always intensity value due reflected light screen phosphors black white monitor bits per pixel 01 ratio successive inten sities approximately r 0182 approximate values intensities system 0100 0102 0104 0106 0107 0109 9821 0000 color system set intensity levels component color model using rgb model example relate blue compo nent intensity level k lowest attainable blue value eq 21 cee intensity typical monitor response curve showing displayed screen 0 intensity asa function normalized electron gun voltage normalized electron gun voltage igy r ilpo 24 un tg 25 tho n number intensity levels similar expressions hold color components gamma correction video lookup tables another problem associated display calculated intensities non linearity display devices illumination models produce linear range inten sities rgb color 25 25 25 obtained lighting model represents one half intensity color usually calculated intensi ties stored image file integer values one byte three rgb components intensity file also linear pixel value one half intensity pixel value video monitor however nonlinear device set voltages electron gun proportional linear pixel values displayed intensities shifted according monitor response curve shown correct monitor nonlinearities graphics systems use video lookup table adjusts linear pixel values monitor response curve described exponential function l av 26 parameter displayed intensity parameter v input voltage val ues parameters depend characteristics monitor used graphics system thus want display particular intensity value j correct voltage value produce intensity pvr 27 section displaying light intensities normalized elect gun valtage pt 0 pixel intensity value video lookup correction curve mapping pixel intensities electron gun voltages using gamma correction values pixel intensity monitor voltages normalized interval calculation referred gamma correction intensity monitor gamma values typically national television system com mittee ntsc signal standard shows gamma correction curve using ntsc gamma value equation 27 used set video lookup table converts integer pixel values image file values control electron gun voltages combine gamma correction logarithmic intensity mapping produce lookup table contains conversions input intensity value illumination model first locate nearest intensity j table values created eq 20 eq 23 alternatively could deter mine level number intensity value calculation k round log 28 q compute intensity value level using eq 23 intensity value ji calculate electron gun voltage l vr v 29 values v placed lookup tables values k would stored frame buffer pixel positions particular system lookup table computed values v stored directly frame buffer com bined conversion logarithmic intensity scale followed calculation v using eq 29 also sometimes referred gamma correction continuous tone photograph printed b two intensity levels c four intensity levels eight intensity levels video amplifiers monitor designed convert linear input pixel values electron gun voltages combine two intensity con version processes case gamuma correction built hardware logarithmic values j must precomputed stored frame buffer color table displaying continuous tone images high quality computer graphics systems generally provide intensity levels color component acceptable displays obtained many ap plications fewer levels four level system provides minimum shading ca pability continuous tone images photorealistic images gener ated systems capable intensity levels per pixel shows continuous tone photograph displayed various intensity levels small number intensity levels used reproduce continuous tone image borders different intensity regions called contours clearly visible two level reproduction features photograph barely identifiable using four intensity levels begin identify original shading patterns contouring effects glaring eight intensity levels contouring effects still obvious begin better indication original shading intensity levels contouring effects diminish reproductions close original reproductions continuous tone images using intensity levels show subtle differences original enlarged section photograph reproduced halftoning method showing tones represented varying size dots output device limited intensity range create apparent increase number available intensities incorporating multiple pixel po sitions display intensity value view small region con sisting several pixel positions eyes tend integrate average fine detail overall intensity bilevel monitors printers particular take advantage visual effect produce pictures appear dis played multiple intensity values continuous tone photographs reproduced publication newspa pers magazines books printing process called halftoning produced pictures called halftones black white photograph intensity area reproduced series black circles white background diameter circle proportional darkness required tensity region darker regions printed larger circles lighter regions printed smaller circles white area shows en larged section gray scale halftone reproduction color halftones printed using dots various sizes colors shown book maga zine halftones printed high quality paper using approximately cir cles varying diameter per centimeter newspapers use lower quality paper lower resolution dots per centimeter halftone approximations computer graphics halftone reproductions approximated using rectangu lar pixel regions called halftone patterns pixel patterns number intensity color halftone dot patterns top half clock color halftone enlarged factor b factor c section halftone patterns dithering techniques 1 o421 06 08 os pixel grid used display five intensity evels bilevel system intensity values would mapped grid listed pixel pattern oc o42i o8sl 3by pixel grid used display intensities bilevel system intensity values would mapped grid listed pixel pattern levels display method depends many pixels clude rectangular grids many levels system display pixels grid ona bilevel system represent intensity levels shows one way set pixel patterns represent five tensity levels could used bilevel system pattern pixels turned pattern one pixel turned pattern tour pixels turned intensity value scene mapped particular pattern ac cording range listed grid shown figure pattern used pattern pattern used pixel grids bilevel system display intensity lev els one way set pixel patterns levels shown pixel positions chosen level patterns approximate creasing circle sizes used halftone reproductions pixel posi tions near center grid far lower intensity levels expand ward intensity level increases pixel grid size represent pixel patterns various possible intensities mask pixel position numbers example following mask used generate nine grid patterns intensity levels shown chapter illumination models surface rendering methods 5 30 display particular intensity level number k turn pixel whose position number less equal k although use pixel patterns increases number intensities displayed reduce resolution displayed picture factor n along x axes screen area stance reduced area containing intensity points grid patterns patterns would reduce area intensity positions along side another problem pixel grids subgrid patterns become apparent grid size increases grid size used without distorting tensity variations depends size displayed pixel therefore systems lower resolution fewer pixels per centimeter must satisfied fewer intensity levels hand high quality displays require least intensity levels means need pixel grids achieve res olution equivalent halftones books magazines must display dots per centimeter thus need able display x dots per centimeter devices example high quality film recorders able dis play resolution pixel grid patterns halftone approximations must also constructed minimize contouring visual effects present original scene contouring minimized evolving successive grid pattern previous pattern form pattern level k adding posi tion grid pattern level k thus pixel position one grid level higher levels figs 36 37 minimize troduction visual effects avoiding symmetrical patterns pixel grid instance third intensity level zero would better repre sented pattern symmetrical arrange ments b symmetrical patterns figure would produce vertical horizontal diagonal streaks large area shaded intensity level hard copy output devices film recorders print ers isolated pixels effectly reproduced therefore grid pattern single pixel one isolated pixels avoided ta pixel grid pattern preferred patterns b representing third intensity level halttone grid patterns isolated pixels effectively reproduced hard copy devices intensity levels obtained halftone approximations using pixel grids four level system halftone approximations also used increase number inten sity options systems capable displaying two intensities per pixel example system display four intensity levels per pixel use pixel grids extend available intensity levels four grid patterns zero represent several levels since pixel position display three intensity values zero fig ure 40 shows one way assign pixel intensities obtain distinct levels intensity levels individual pixels labeled levels system labeled similarly use pixel grid patterns increase number intensi ties displayed color system example suppose three bit per pixel rgb system gives one bit per color gun monitor providing eight colors including black white using pixel grid pat terns phosphor dots used represent particular color value shown three rgb colors four phos phor dots pattern allows five possible settings per color gives us total different color combinations dithering techniques term dithering used various contexts primarily refers techniques approximating halftones without reducing resolution pixel grid patterns term also applied halftone approximation methods using pixel grids sometimes used refer color halftone approximations random values added pixel intensities break contours often ferred dither noise various algorithms used generate ran rgb pixel grid pattern chapter iumination models surface rendering methods dom distributions effect add noise entire picture tends soften intensity boundaries ordered dither methods generate intensity variations one one map ping points scene display pixels obtain n intensity levels set ann n dither matrix whose elements distinct positive integers range n example generate four intensity levels pr lo 31 generate nine intensity levels dy 32 98 matrix elements order pixel mask set ting pixel grids respectively bilevel system determine display intensity values comparing input intensities matrix elements input intensity first scaled range n inten sity applied screen position x calculate row column num bers dither matrix xmoda j ymodn 33 f dif turn pixel position x otherwise pixel turned elements dither matrix assigned accordance guide lines discussed pixel grids want minimize added visual effect displayed scene order dither produces constant intensity areas identical generated pixel grid patterns values matrix elements correspond grid mask variations pixel grid displays occur boundaries intensity levels typically number intensity levels taken multiple higher order dither matrices obtained lower order matrices recurrence relation ad dia du 4dyyy dx1 2u _ nf2 34 4dy d2 4day da2 u yr assuming n parameter u unity matrix elements example specified eq 31 recurrence relation 34 yields 5 p hol 4 35 10 another method mapping picture n points display area pixels error diffusion error input intensity value displayed pixel intensity level given position dispersed diffused pixel positions right current pixel position starting matrix intensity values obtained scanning photograph want construct array pixel intensity values area screen first scanning across rows left right top bot tom determining nearest available pixel intensity level element error value stored matrix displayed tensity level pixel position distributed neighboring elements using following simplified algorithm g j n j determine available intensity level closest value ls err miyat err miny mia bert ity mini ty ert morijes mister ert elements matrix assigned intensity level values map matrix area display device printer video moni tor course disperse error past last matrix column j last matrix row bilevel system available intensity levels parameters distributing error chosen satisfy following relationship bty 8s1 36 one choice error diffusion parameters produces fairly good sults b 16 16 16 16 illustrates error distribution using parameter values error diffusion sometimes produces ghosts picture repeating echoing certain parts picture partic ularly facial features hairlines nose outlines ghosting column j ra row qo nn 7t ti 16 i6 row fraction intensity error distributed neighboring pixel positions using error diffusion scheme section haiftone patterns dithering techniques chapter ss itlumination models surface rendering methods 48 32 15 31 58 21 50 61 13 38 54 26 44 2z 35 41 11 one possible distribution scheme w 63 dividing intensity array dot diffusion classes numbered duced choosing values error diffusion parameters sum value less rescaling matrix values dispersion errors one way rescale multiply elements add another method improving picture quality alternate scanning matrix rows right left left right variation error diffusion method dot diffusion method n array intensity values divided classes numbered shown error matrix value displayed intensity distributed neighboring matrix elements larger class number distribution class numbers based minimiz ing number elements completely surrounded elements lower class number since would tend direct errors surrounding elements one position section consider application illumination model ren dering standard graphics objects formed polygon surfaces ob jects usually polygon mesh approximations curved surface objects may also polyhedra curved surface approximations scan line algorithms typically apply lighting model obtain polygon surface ren dering one two ways polygon rendered witha single intensity intensity obtained point surface using interpola tion scheme constant intensity shading fast simple method rendering object polygon surfaces con stant intensity shading also called flat shading method single inten sity calculated polygon points surface polygon displayed intensity value constant shading useful quickly displaying general appearance curved surface general flat shading polygon facets provides accurate rendering object following assumptions valid object polyhedron 1s approximation object curved surface section polygon rendering methods normal vector vertex v calculated average surface normais polygon sharing vertex light sources illuminating object sufficiently far surface n l attenuation function constarit surface viewing position sufficiently far surface v r con stant surface even conditions true still reasonably approximate surface lighting effects using small polygon facets flat shading calculate intensity facet say center polygon gouraud shading intensity interpolation scheme developed gouraud generally ferred gouraud shading renders polygon surface linearly interpolat ing intensity values across surface intensity values polygon matched values adjacent polygons along common edges thus eliminating intensity discontinuities occur flat shading polygon surface rendered gouraud shading performing following calculations determine average unit normal vector polygon vertex apply illumination model vertex calculate vertex intensity linearly interpolate vertex intensities surface polygon polygon vertex obtain normal vector averaging surface normals polygons sharing vertex illustrated thus vertex position v obtain unit vertex normal calculation ny k l ny ne k vertex normals determine intensity vertices lighting model demonstrates next step interpolating intensities along polygon edges scan line intensity intersection scan line polygon edge linearly interpolated intensities edge end points example polygon edge endpoint vertices positions intersected scan line point fast method ob taining intensity point interpolate intensities using vertical displacement scan line 37 gouraud shading intensity point linearly interpolated intensities vertices intensity point linearly interpolated intensities vertices interior point p assigned intensity value linearly interpolated x intensities positions scan line b41 38 yi ye mh similarly intensity right intersection scan line point interpo lated intensity values vertices bounding intensities established scan line interior point point p interpolated bounding intensities points _ ne ey 39 xx xe x5 x4q incremental calculations used obtain successive edge intensity values scan lines obtain successive intensities along scan line shown intensity edge position x interpolated po po boy 40 yi ya y2 obtain intensity along edge next scan line r honk 41 ye scan lines x ox4 incremental interpolation intensity values along polygon edge successive scan lines polygon mesh approximation object rendered flat shading b gouraud shading c similar calculations used obtain intensities successive horizontal pixel positions along scan line surfaces rendered color intensity color com ponent calculated vertices gouraud shading combined hidden surface algorithm fill visible polygons along scan line example object shaded gouraud method appears gouraud shading remeves intensity discontinuities associated constant shading model deficiencies highlights surface sometimes displayed anomalous shapes linear intensity interpolation cause bright dark intensity streaks called mach bands ap pear surface effects reduced dividing surface greater number polygon faces using methods phong shad ing require calculations phong shading accurate method rendering polygon surface interpolate normal vectors apply illumination model surface point method developed phong bui tuong called phong shading normal vector interpolation shading displays realistic highlights surface greatly reduces mach band effect polygon surface rendered using phong shading carrying fol lowing steps e determine average unit normal vector polygon vertex linearly imterpolate vertex normals surface polygon apply illumination model along scan line calculate projected pixel intensities surface points interpolation surface normals along polygon edge two vertices illustrated normal vector n scan line intersection point along edge vertices obtained vertically inter polating edge endpoint normals chapter mumination models surface rendering methods n n scan line interpolation surface normals n along polygon edge n 4y bon 42 mi y2 incremental methods used evaluate normals scan lines along individual scan line pixel position along scan line illumina tion model applied determine surface intensity point intensity calculations using approximated normal vector point along scan line produce accurate results direct interpolation intensities gouraud shading trade however phong shading requires considerably calculations fast phong shading surface rendering phong shading speeded using approxima tions illumination model calculations normal vectors fast phong shad ing approximates intensity calculations using taylor series expansion triangular surface patches since phong shading interpolates normal vectors vertex normals express surface normal n point x triangle n ax c 43 vectors b c determined frum three vertex equations n ax c k 44 x denoting vertex position omitting reflectivity attenuation parameters write cal culation light source diffuse reflection surface point x l n tau tnt _ l ax il ax cl 45 _ lt aix l tl il ay c rewrite expression form ax c dx exy fy gx thy 46 laut parameters b c used represent various dot products example l 47 finally express denominator eq 46 taylor series expansion retain terms second degree x yields dag tyx taxy t3y trav ty 48 function parameters b c forth using forward differences evaluate eq 48 two addi tions pixel position x initial forward difference parameters evaluated although fast phong shading reduces phong shading calculations still takes approximately twice long render surface fast phong shading gouraud shading normal phong shading using forward differences takes six seven times longer gouraud shading fast phong shading diffuse reflection extended include specu lar reflections calculations similar diffuse reflections used evaluate specular terms n h basic illumination model ad dition generalize algorithm include polygons triangles finite viewing positions section 15 introduced notion ray casting ray sent pixel position locate surface intersections object modeling using constructive solid geometry methods also discussed use ray casting method determining visible surfaces scene section 10 ray tracing extension basic idea instead merely looking visible surface pixel continue bounce ray around scene illustrated collecting intensity contributions provides simple power ful rendering technique obtaining global reflection transmission effects basic ray tracing algorithm also provides visible surface detection shadow effects transparency multiple light source illumination many ex tensions basic algorithm developed produce photorealistic displays ray traced displays highly realistic particularly shiny ob jects require considerable computation time generate example global reflection transmission effects possible ray tracing shown section ray tracing methods chapter illumination models surface rendering methods pixel positions projection projection plane reference point tracing ray projection reference point pixel position multiple reflections transmissions basic ray tracing algorithm first set coordinate system pixel positions designated xy plane scene description given reference frame center projection determine ray path passes center screen pixel position illumination effects accumulated along ray path assigned pixel rendering approach based prin ciples geometric optics light rays surfaces scene emanate directions pass pixel positions projection plane since infinite number ray paths determine contributions particular pixel tracing light path backward pixel scene first consider basic ray tracing algorithm one ray per pixel equivalent viewing scene pinhole camera gee sah _ ray traced scene showing global reflection transmission illumination effects object pe ag surfaces courtesy evans ar sutheriand _ pixel screen area ae centered viewing coordinate origin nn ee projection reference point ray tracing coordinate reference frame pixel ray test surface scene determine tersected ray surface intersected calculate distance pixel tu surtace intersection point smallest calculated intersection dis tance identifies visible surface pixel reflect ray visible surface along specular path angle refiection equals angle inci dence surface ts transparent also send ray surface refraction direction reflection refraction rays referred secondary rus procedure repeated secondary ray objects tested tersection nearest surface along secondary ray path used recur sively produce next generation reflection refraction paths rays pixel ricochet scene successively intersected surface added toa binary ray tracing tree shown use left branches tree represent reflection paths right branches represent transmission paths maximum depth ray tracing trees set user option determined amount storage available path tree terminated reaches preset maximum ray strikes light source intensity assigned pixel determined accumulating tensity contributions starting bottom terminal nodes ray tracing tree surface intensity node tree attenuated distance parent surface next node tree added intensity parent surface pixel intensity sum attenuated intensities reat node ray tree surfaces intersected pixel ray ray tracing tree emply pixel assigned intensity value back ground pixel ray intersects nonreflecting light source pixel signed intensity source although light sources usuallv placed bevand path initial rays shows surface intersected ray unit vectors needed reflected light intensity calculations unit vector u direc bon rav path n unit surface normal r unit reflection vector l unit vector pomting light source h unit vector halfway tween v opposite u l path along l referred shadow ray object intersects shadow ray surface point light section ray tracing methods inumination models surface rendering methods projection reference point reflection refraction ray paths scene screen pixel b binary ray tracing tree paths shown source surface shadow respect source ambient light surface calculated k diffuse reflection due source proportional kan l specular reflection component proportional k h n discussed section specular reflection direction secondary ray path r depends surface normal incorning ray direction r u qu n n 49 transparent surface also need obtain intensity contributions light transmitted material locate source con tribution tracing secondary ray along transmission direction shown unit transmission vector obtained vectors u n bu cos ecos n 50 n r reflected light ray source incoming ray unit vectors surface object intersected incoming ray along direction u refracted tay path incoming ray refracted ray path transparent material parameters indices refraction incident material refracting material respectively angle refraction calculated snell law _ cos ji cos 51 ray surface intersection calculations ray described initial position py unit direction vector u illustrated coordinates point p along ray distance po computed ray equation p pyt su 52 initailly p set position pixel projection plane could chosen projection reference point unit vector u initially ob section ray tracing methods illumination models surface chaoter rendering methods describing ray initial x position vector py unit direction z vector u tained position pixel ray passes projec tion reference point p p u ip pl 53 pou porp intersected surface vectors py u updated secondary rays ray surface intersection point secondary rays reflection direction u r transmission direction locate surface intersections simultaneously solve ray equation surface equation individ ual objects scene simplest objects lo ray trace spheres sphere radius r center position p point p surface must satisfy sphere equation ip p r2 54 substituting ray equation 52 p su p r 55 let ap p py expand dot product obtain quadratic equa tion ray intersecting sphere radius r centered position p section ray tracing methads sphereflake rendered ray tracing using spheres light sources courtesy eric haines sd eye inc u ap ap r2 56 whose solution u ap v u apy ap 57 discriminant negative ray intersect sphere otherwise surface intersection coordinates obtained ray equation 52 using smaller two values eq 57 small spheres far initial ray position eq 57 sus ceptible roundoff errors ri ap could lose r term precision error ap avoid cases rearranging calculation distance u ap v7 ap u ap ul 58 shows snowflake pattern shiny spheres rendered ray trac ing display global surface reflections polyhedra require processing spheres locate surface intersec tions reason often better initial intersection test bounding volume example shows polyhedron bounded sphere ray intersect sphere need testing polyhedron ray intersect sphere first locate front faces test u n 59 n surface normal face polyhedron satisifies equality 59 solve plane equation n p 60 surface position p also satisfies ray equation 52 n b c chapter ilumination models surface rendering methods polyhedron enclosed bounding sphere fourth plane parameter position p plane ray path n py su 61 distance initial ray position plane _d n py n u 62 gives us position infinite plane contains polygon face position may inside polygon boundaries need perform inside outside test chapter determine whether ray tersected face polyhedron perform test face satisfying inequality 59 smallest distance inside point identifies inter sected face polyhedron intersection positions eq 62 side points ray intersect object similar procedures used calculate ray surface intersection positions objects quadric spline surfaces combine ray equation surface definition solve parameter many cases numerical root finding methods incremental calculations used locate intersection plane intersection point la polygon figure j4 ray intersection plane polygon section ray tracing methods ray traced scene showing global reflection surface texture patterns courtesy sun microsystems points surface shows ray traced scene containing multiple objects texture patterns reducing object intersection calculations ray surface intersection calculations account much percent processing time ray tracer scene many objects pro cessing time ray spent checking objects visible along ray path therefore several methods developed reducing pro cessing time spent intersection calculations one method reducing intersection calculations enclose groups adjacent objects within bounding volume sphere box fig test ray intersections bounding volume ray intersect bounding object eliminate intersection tests enclosed surfaces approach extended include hierarchy bounding volumes enclose several bounding volumes within larger volume carry intersection tests hierarchically first test outer bounding volume necessary test smaller inner bounding volumes space subdivision methods another way reduce intersection calculations use space subdivision meth ods enclose scene within cube successively subdivide cube subregion cell contains preset maximum num ber surfaces example could require cell contain one surface parallel arid vector processing capabilities available maximum number surfaces per cell determined size vector _ bounding sphere group objects enclosed within bounding sphere chapter ilurnination models surace rendering methods ray intersection cube enclosing objects scene registers number processors space subdivision cube stored octree binary partition tree addition perform uniform subdivision dividing cube eight equal size octants step perform adaptive subdivision subdivide regions cube containing objects trace rays individual cells cube performing tersection tests within cells containing surfaces first object surface intersected ray visible surface ray trade cell size number surfaces per cell set maximum number surfaces per cell low cell size become small much sav ings reduced intersection tests goes cell traversal processing illustrates intersection pixel ray front face cube enclosing scene calculate intersection paint front face cube determine initial cell intersection checking inter section coordinates cell boundary positions need process ray cells determining entry exit points cell traversed ray intersect object surface exit cube enclosing scene given ray direction u ray entry position p cell potential exit faces un 63 normal vectors cell faces aligned coordi nates axes n ray traversal subregion cell cube enclosing scene need check sign component u determine three candidate exit planes exit position candidate plane obtained ray equation pours pin 64 distance along ray p pau substituting ray equa tion plane equation cell face ni pots 65 solve ray distance candidate exit face n p nou 66 select smallest calculation simplified norma vec tors n aligned coordinate axes example candidate normal vector plane xx x 67 u u uy u x value right boundary face cell various modifications made cell traversal procedures speed processing one possibility take trial exit plane k one perpen dicular direction largest component u sector trial plane tig 64 containing p determines true exit plane intersec tion point p u sector trial plane true exit plane done intersection point sector true exit plane top plane simply need calculate exit point top boundary cell simi larly sector identifies bottom plane true exit plane sectors identify true exit plane left right cell planes respectively trial exit point falls sector need carry two additional intersection calculations identify true exit plane implementation methods parallel vector machines provides improvements perfor mance scene ray traced using space subdivision methods without space subdivision ray tracing calculations took times longer eliminating polygons also speeded processing scene containing spheres polygbns algorithm executed times faster basic ray tracer illustrates another ray traced scene using spatial subdivision parallel processing methods image rodin thinker ray traced million rays seconds scene shown rendered light buffer technique form spatial partitioning cube centered point light source side cube partitioned grid squares sorted list ob jects visible light square maintained ray tracer speed processing shadow rays determine surface illumina tion effects square shadow ray computed shadow ray processed list objects square section ray tracing methods sectors trial exit plane chapter rendering methods intersection testa ray tracing programs also reduced direc nlumination models surface tional subdivision procedures considering sectors contain bundle rays within sector sort surfaces depth order ray needs test objects within sector contains ray antialiased ray tracing two basic techniques antialiasing ray tracing algorithms supersampling adaptive sampling sampling ray tracing extension sampling methods discussed chapter supersampling adaptive sampling parallel ray traced scene containing spheres polygon surfaces ray tracing algorithm used rays per pixel tree depth spatial subdivision methods processed scene times faster basic ray tracing algorithm alliant fx courtesy lee hian quek information technology institute republic singapore _ aimed se sd ers lineal ail mil aie leni nan aca ray traced scene took seconds render kendall square research ksr1 parallel computer processors rodin thinker modeled primitives two light sources one primary ray per pixel used obtain global illumination effects 675 rays processed courtesy keates r j hubbold department computer science university manchester tb room scene illuminated light sources rendered using ray tracing light buffer technique process shadow rays closeup b part room shown illustrates global illumination effects room modeled polygons spheres cylinders quadrics rendering time minutes vax 780 compared minutes without using light buffers courtesy eric haines donald p greenberg program computer graphics cornell university sector fora bundle rays directional subdivision space rays sector need test surfaces within sector depth order pixel treated finite square area instead single point supersampling uses multiple evenly spaced rays samples pixel area adaptive sam pling uses unevenly spaced rays regions pixel area example rays used near object edges obtain better estimate pixel tensities another method sampling randomly distribute rays pixel area discuss approach next section multiple rays rendering methods subdividing pixel nine subpixels one ray subpixel corner ray positions centered subpixel areas pixel pasitions projection plane projection reference point supersampling four rays per pixel one pixel comer per pixel used intensities pixel rays averaged produce overall pixel intensity illustrates simple supersampling procedure one ray generated corner pixel intensities four rays approximately equal small object lies four rays divide pixel area subpixels repeat process example pixel divided nine subpixels using rays one sub pixel corner adaptive sampling used subdivide subpixels nearly equal intensity rays subtend small object subdivision process continued subpixel approximately equal intensity rays upper bound say reached num ber rays per pixel cover picture book rendered adaptive subdivision ray tracing using rayshade version macintosh ii extended light source used provide realistic soft shadows nearly million primary rays generated million shadow rays million reflection rays wood grain marble surface patterns generated using solid texturing methods noise function total rendering time extended light source hours image stereo pair shown generated hours using point light source instead passing rays pixel corners generate rays subpixel centers approach weight rays ac cording one sampling schemes discussed chapter another method antialiasing displayed scenes treat pixel ray cone shown one ray generated per pixel ray finite cross section determine percent pixel area coverage objects calculate intersection pixel cone object surface sphere requires finding intersection two circles polyhedron must find intersection circle polygon distributed ray tracing stochastic sampling method randomly distributes rays according various parameters illumination model mlumination parameters projection reference point pixel ray cone clude pixel area reflection refraction directions camera lens area time aliasing effects thus replaced low level noise improves picture quality allows accurate modeling surface gloss translucency fi nite camera apertures finite light sources motion blur displays moving objects distributed ray tracing also referred distribution ray tracing essen tially provides monte carlo evaluation multiple integrals occur accurate description surface lighting pixel sampling accomplished randomly distributing number rays pixel surface choosing ray positions completely random however result rays clustering together small region pixel area leaving parts pixel unsampled better approximation light distribution pixel area obtained using technique called jittering regular subpixel grid usually done initially dividing pixel area unit square subareas shown generating random jitter position subarea random ray positions obtained jittering center coordinates subarea small amounts assigned values interval choose ray po sition cell center coordinates x jitter position x integer codes randomly assigned rays table lookup used obtain values parameters reflection angle time etc explained following discussion subpixel ray processed scene determine intensity contribution ray ray intensities averaged produce overall pixel inten sity subpixel intensities vary much pixel subdivided model camera lens effects set lens assigned focal length f front projection plane distribute subpixel rays lens area suming rays per pixel subdivide lens area zones ray sent zone corresponding assigned code ray po sition within zone set jittered position zone center ray projected scene jittered zone position focal point lens locate focal point ray distance f lens along line center subpixel lens center shown objects near focal plane projected sharp images objects front back focal plane blurred obtain better displays focus objects increase number subpixel rays ray reflections surface intersection points distributed spec ular reflection direction r according assigned ray codes section ray tracing methods pixel sampling using subpixel areas jittered ray position center coordinates subarea incoming n ray distributing subpixel rays reflection direction r transmission direction distributing subpixel rays direction camera lens focal length f maximum spread r divided angular zones ray flected jittered position zone center corresponding integer code use phong model cos determine maximum reflection spread material transparent refracted rays distributed transmission direction similar manner extended light sources handled distributing number shadow rays area light source demonstrated light source divided zones shadow rays assigned jitter directions various zones additionally zones weighted according intensity light source within zone size projected zone area onto object surface shadow rays sent zones higher weights shadow rays blocked opaque objects surface light source penumbra generated surface point illus trates regions umbra penumbra surface partially shielded light source create motion blur distributing rays time total frame time frame time subdivisions determined according motion dynam ics required scene time intervals labeled integer codes ray assigned jittered time within interval corresponding ray code objects moved positions time ray traced ub cee extended n eoe light l max source distributing shadow rays finite sized light source earth penumbra umbra penumbra regions created solar eclipse surface earth section ray tracing methods scene entitled rendered distributed ray tracing illustrating motion blur penumbra effects courtesy pixar pixar rights reserved scene additional rays used highly blurred objects reduce calculations use bounding boxes spheres initial ray intersection tests move bounding object according motion requirements test intersection ray intersect bounding object need process individual surfaces within bourding volume figure 78 shows scene displayed motion blur image rendered using distributed ray tracing pixels rays per pixel addition motion blurred reflections shadows displayed penumbra areas resulting extended light sources around room illumi nating pool table additional examples objects rendered distributed ray tracing meth ods given figs 79 80 illustrates focusing refrac tion antialiasing effects distributed ray tracing brushed aluminum wheel showing reflectance shadow effects generated distributed ray tracing techniques courtesy stephen h westin program computer graphics cornell university room scene rendered distributed ray tracing methods courtesy jokn snyder jed lengyel devendra kalra al barr computer graphics lab california institute technology copyright caltech ascene showing focusing antialiasing illumination effects possible combination ray tracing radiosity methods realistic physical models light illumination used generate refraction effects including caustic shadow glass courtesy peter shirley department computer science indiana university accurately mode diffuse reflections surface considering ra diant energy transfers surfaces subject conservation energy laws method describing diffuse reflections generally referred ra diosity model basic radiosity model method need consider radiant energy interactions surfaces scene determining differential amount radiant energy db leaving surface point scene summing energy con tributions surfaces obtain amount energy transfer sur faces reference db visible radiant energy emanating surface point direction given angles within differential solid angle dw per unit time per unit surface area thus db units joules sec ond meter watts meter intensity luminance diffuse radiation direction ra diant energy per unit time per unit projected area per unit solid angle units watts meter steradians db _ dw cos 68 visible radiant energy emitted surface point direction within solid angle dw direction energy transfer unit surface element projected area perpendicular direction energy transfer equal tocos assuming surface ideal diffuse reflector set intensity con stant viewing directions thus db dw proportional projected sur face area obtain total rate energy radiation surface point need sum radiation directions want tal energy emanating hemisphere centered surface point b 48 69 perfect diffuse reflector constant express radiant energy b b cos deo 70 also differential element solid angle dw expressed appendix dw sinpdd total radiant energy surface point sum contributions directions hemisphere centered surface point section radiosity lighting model chapter illumination models surface rendering methods surface k enclosure surfaces radiosity model 2a wz b cosdsinddgde 71 model light reflections various surfaces formed set ting enclosure surfaces surface enclosure ei ther reflector emitter light source combination reflector emitter designate radiosity parameter b total rate energy leaving surface k per unit area incident energy parameter h sum energy contributions surfaces enclosure arriving surface k per unit time per unit area hy bf 72 parameter fj form factor surfaces j k form factor f fractional amount radiant energy surface j reaches surface k scene n surfaces enclosure radiant energy surface kis described radiosity equation b ey ply n 73 e bf jel surface k light source f otherwise e rate energy emitted surface k per unit area watts meter parameter p reflectivity factor surface k percent incident light reflected directions flectivity factor related diffuse reflection coefficient used empirical il lumination models plane convex surfaces see self incidence takes place form factor f surfaces obtain illumination effects various surfaces enclosure need solve simultaneous radiosity equations n surfaces given array values f p fi must solve pf ebe bf ee k 23 74 jtk pfy prfi2 af b e tpif pe mn py pld 95 pin pf fae b e convert intensity values dividing radiosity values b color scenes calculate individual rgb components radios ity bz big byp color components p e solve eq 74 need determine values form factors f considering energy transfer surface j surface k rate radiant energy falling small surface element da area element da 4b da u cosd dwida 76 solid angle dw written terms projection area element da perpendicular direction db _ 4a _ cosdda dw r 77 surface k surface j rate energy transfer db surface element area da surface element da section radiosity lighting model chapter ihumination models surface rendering methods express eq 76 db da cos cos dy da da mu r2 78 form factor two surfaces percent energy emanating area da incident da _ energy incident da e ar44 total energy leaving da 79 cos dj cos aa da b da also b mi r cos cos dy da da day 80 fraction emitted energy area da incident entire surface k cos cos dy faa da aay ay wc ar 81 area surface k define form factor two surfaces area average previous expression cos cos fs b coshr da suet j sur 82 integrals 82 evaluated using numerical integration techniques stipu lating following conditions sp fx k conservation energy af afi uniform light reflection f j assuming plane convex surface patches surface scene subdivided many small polygons smaller polygon areas realistic display appears speed calculation form factors using hemicube approximate hemisphere replaces spherical surface set linear plane surfaces form factors evaluated solve simultaneous lin ear equations 74 using say gaussian elimination lu decomposition meth ods appendix alternatively start approximate values b solve set linear equations iteratively using gauss seidel method iteration calculate estimate radiosity surface patch k using previously obtained radiosity values radiosity equation n b ey p bifn yl display scene step improved surface rendering viewed iteration little change calculated radiosity val ues progressive refinement radiosity method although radiosity method produces highly realistic surface rendings tremendous storage requirements considerable processing time needed calculate form factors using progressive refinement restruc ture iterative radiosity algorithm speed calculations reduce storage requirements iteration radiosity equation radiosity contribution two surface patches calculated b due b pp bf 83 reciprocally b due pbify j 84 rewrite b due b bagh 85 relationship basis progressive refinement approach ra diosity calculations using single surface patch k calculate form fac tors f shoot light patch surfaces environment thus need compute store one hemicube associated form factors time discard values choose another patch next iteration step display approximation rendering scene initially set b e surface patches select patch highest radiosity value brightest light emitter calcu late next approximation radiosity patches process repeated step light sources chosen first order highest ra diant energy patches selected based amount light ceived light sources steps simple progressive refinement ap froach given following algorithm section radiosity lighting mcdel chapter illumination models surface rendering methods nave chartres cathedral rendered progressive refinement radiosity model john wallace john lin using hewlett packard starbase radiosity ray tracing software radiosity form factors computed tay tracing methods courtesy eric haines 3d eye inc hewlett packard co patch k set hemicube calculate form factors f patch drad bf ac 4b 4b arad b b srad ab step surface patch highest value ab selected shooting patch since radiosity measure radiant energy per unit area choose initial values ab b e surface patches progres sive refinement algorithm approximates actual propagation light scene displaying rendered surfaces step produces sequence views proceeds dark scene fully illuminated one first step surfaces illuminated light sources nonemitting patches visible chosen emitter produce useful initial views scene set ambient light level patches illumina tion stage iteration reduce ambient light according amount radiant energy shot scene shows scene rendered progressive refinement ra diosity model radiosity renderings scenes various lighting conditions illustrated figs 88 90 ray tracing methods often combined radiosity model produce highly realistic diffuse specular surface shadings section radiosity lighting model image constructivist museum rendered progressive refinement radiosity method courtesy shenchang eric chen stuart feldman julie dorsey program computer grapitics cornell university cornell university program computer graphics simulation stair tower engineering theory center building cormell university rendered progressive refinement radiosity method courtesy keith howie ben trumbore program computer graphics cornell university cornell university program computer graphics fa b simulation two lighting schemes parisian garret metropolitan opera production la boheme day view b night view courtesy julie dorsey mark shepard program computer graphics cornell university cornell university program computer graphics spherical environment map oxyects meee co scene spherical enclosing universe ee containitg environment map environment pping alternate procedure tor modeling global reflections 1s define array tensity values describes environment around single object set objects instead intercbject rav tracing radiosity calculations pick global specular dittuse illumination effects simply map environment array onto a2 obleect relationship viewing direction procedure ferred environment mapping also called reflection mapping although transparency effects cond also modeled environment map environ ment mapping sometimes referred pocr person ray tracing method since fast approximation accurate global illumination rendering techniques discussed previous two sections environment map defined surface enclosing universe information environment map includes intensity values light sources sky backy ound objects shows enclosing universe sphere cube cylinder often used enclosing universe render surtace object project pixel areas onto surface reflect projected pixel area onto environment map pick surface shading attributes pixel object cransparent also refract projected pial area environment map environment map ping process reflection projected pixel area illustrated pixel intensity determined averaging intensity values within inter sected region environment map p surface pixel projection onto enviranment map _ figure 92 projecung pixel area surface picection reflecting area refers ce point environtient map far discussed rendering techniques displaying smooth surfaces typically polygons splines however objects smooth even surfaces need surface texture model accurately objects brick walls gravel roads shag carpets addition surfaces contain patterns must taken account rendering procedures surface vase could contain painted design water glass might family crest en graved surface tennis court contains markings alleys service areas base line four lane highway dividing lines mark ings oil spills tire skids illustrates objects displayed various surface detail modeling surface detail polygons simple method adding surface detail model structure patterns polygon facets large scale detail polygon modeling give good sults examples large scale detail squares checkerboard di viding lines highway tile patterns linoleum floor floral designs smooth low pile rug panels door lettering side panel truck also could model irregular surface small randomly oriented poly gon facets provided facets small scenes illustrating computer graphics generation surface detail deborah r fi premyslaw prusinkiewicz johannes battjes b deborah r fowler hans metnhardt przemysiaw prusinkiewicz university calgary c courtesy softimage inc section adding surface detail chapter niumination models aud surface rendering methods texture object image space space space array u v surface ix pixel coordinates parameters coordinates texture surface viewing transformation projection transformation coordinate reference systems texture space object space image space surface pattern polygons generally overlaid larger surface polygon processed parent surface parent polygon processed visible surface algorithms illumination parameters surface detail polygons take precedence parent polygon intricate fine surface detail modeled polygan methods noi practical example would difficult accurately model surface structure raisin polygon facets texture mapping common method adding surface detail map texture patterns onto surfaces objects texture pattern may either defined rectangular array procedure modifies surface intensity values approach referred texture mapping pattern mapping usually texture pattern defined rectangular grid intensity values texture space referenced coordinate values shown fig 94 surface positions scene referenced wv object space coordi nates pixel positions projection plane referenced xy cartesian coordinates texture mapping accomplished one two ways either map texture pattern object surfaces projection plane map pixel arcas onto object surfaces texture space mapping texture pattern pixel coordinates sometimes called texture scanning map ping pixel coordinates texture space referred pixel order scanning inverse scanning imuiye order scanning simplify calculations mapping texture space object space often specified parametric linear functions w fist bt e 48a v fgt bf c object image space mapping accomplished concatenation viewing projection transformations disadvantage mapping texture space pixel space thal selected texture patch usually match pixel boundaries thus requiring calculation fractional area pixel coverage therefore mapping pixel space texture space fig 95 commonly used texture mapping method avoids pixel subdivision calculations allows antialiasing filtering procedures eas projected pixel area ww thee ae phat oe pixel surface area rectangular pattern array texture mapping projecting pixel areas texture space extended pixel area extended area pixel includes centers adjacent pixels ily applied effective antialiasing procedure project slightly larger pixel area includes centers neighboring pixels shown applying pyramid function weight intensity values texture pattern mapping image space texture space require calculation inverse viewing projection transformation mj inverse texture map transformation m7 following example illustrate approach mapping defined pattern onto cylindrical surface example texture mapping illustrate steps texture mapping consider transfer pattern shown cylindrical surface surface parameters chapter lucunation madels surface render ng methods z ns os uv ao x e c o75 fa b mapping texture pattern defined unit square cylindrical surface b parametric representation surface cartesian reference frame frcosh rsini te map arrav pattern surface following linear transforma tion maps pattern origin lower left corner surface u s7 v next select viewing position perform inverse viewing transforma tion pixel coordinates cartesian reference cylindrical surface cartesian coordinates mapped surface parameters trans formation w tan gy x v z projected pixel positians mapped texture space inverse trans formation 2u il intensity values pattern array covered projected pixel area averaged obtain pixel intersity procedural texturing methods another method adding surface texture use procedural definitions color variations applied objects scene approach avoids transfarmation calculations invelved transferring two dimensional texture patterns object surfaces values assigned throughout region three dimensional space object color variatiors referred salid textures values fexture scene surface characteristics generated using solid texture methods courtesy peter shirley computer science department indiana university space transferred object surfaces using procedural methods since usu ally impossible store texture values points throughout region space procedural methods used set texture values two dimen sional surfaces solid texturing allows cross sectional views three dimensional abjects bricks rendered texturing outside sur faces examples procedural texturing wood grains marble patterns created using harmonic functions sine curves defined three dimensional space random variations wood marble texturing attained su perimposing noise function harmonic variations shows scene displayed using solid textures obtain wood grain surface pat terns scene rendered using procedural descriptions terials stone masonry polished gold banana leaves scene rendered vg shaders modeled renderman using polygonal facets gem faces quadric surfaces bicubic patches addition surface texturing procedural methods used create steamy jungle atmosphere forest canopy dappled lighting effect courtesy valis group reprinted graphics gems il edited david kirk copyright academic press inc section adding surface detail chapter nlumination models surface rendering methods bump mapping although texture mapping used add fine surface detail good method modeling surface roughness appears objects anges strawberries raisins illumination detail texture pattern usually correspond illumination direction scene better method creating surface bumpiness apply perturbation function surface normal use perturbed normal illumination model cal culations techniques called bump mapping p u v represents position parametric surface obtain surface normal point calculation n p x p 87 p p partial derivatives p respect parameters u v obtain perturbed normal modify surface position vector adding small perturbation function called bump function p u v plu v b u v n 88 adds bumps surface direction unit surface normal n n nj perturbed surface normal obtained n pxxp 89 calculate partial derivative respect w perturbed position vector p le bn 90 p bn bn assuming bump function small neglect last term write p p bn 91 similarly p p n 92 perturbed surface normal n p xp bp x n b n x p b n x n n x n 50 n n p xn b n x pl 93 final step normalize n use ijlumination model calculations surface roughness characteristics rendered bump mapping courtesy peter shirley computer science department indiana university b softimage inc stained glass knight motion picture young sherlock holmes combination bump mapping environment mapping texture mapping used render armor surface courtesy industrial light magic copyright paramount pictures amblin several ways specify bump function b u v actually define analytic expression bump values usually ob tained table lookups bump table values b obtained quickly linear interpolation incremental calculations partial derivatives b b approximated finite differences bump table set random patterns regular grid patterns character shapes random pat terns useful modeling irregular surfaces raisin repeat ing pattern could used model surface orange example tialiase subdivide pixel areas average computed subpixel intensities shows examples surfaces rendered bump mapping example combined surface rendering methods given armor stained glass knight film yourg sherlock holmes rendered combination bump mapping environment mapping texture map ping environment map surroundings combined bump map produce background illumination reflections surface roughness ad ditional color surface illumination bumps spots dirt ard stains seams rivets added produce overall effect shown frame mapping technique extension bump mapping frame mapping perturb surface normal n local coordinate system attached section adding surface detail chapter nluminatian models surtat e rendering methods figure h 1o2 local coordinate system surface point n local coordinates defined surface tangent vector binor mal veclor b tn frame mapping used model anisotropic surfaces onent along grain surtace apply directional perturbations addition bump perturbations ir che direction n way model wood grain patterns cross thread patterns cloth streaks marble similar materi als bump directional perturbations obtained table lookups summary general object 1s illuminated radiant energy light emitting soutces reflective surfaces objects scene light sources modeled es point sources distributed extended sources ob jects either opaque transparent lighting effects described terms diffuse specular components reflections refractions empirical puint light source iumination model used de scribe diffuse reflections lambert cosine law describe specular flections mhony model general background ambient lighting modeled tixed intensity level coefficient ot reflection sur face basic model approximate transparency effects combining surface intensities using transparency coefficient accurate geometric modeling light paths transparent materials obtained calculating refraction angles using snell law color incorporated mode assigning triple rgb values te intensities surface reflection coefficients also extend basic model incorporate distributed light sources studio lighting effects intensity attenuation intensity values calculated illumination model must mapped intensity levels available display system use loganthmic intensity scale used provide set intensity ievels equal perceived brightness addition gamma correction applied intensity values correct nonlinearity diaplay devices bilevel monitors use halftone pat terns dithering techniques simulate range intensity values halftone approximations also used increase number ef intensity options systems capable displaying two irtensities per pixel dered dither error diffision dot diffusion methods used simulate range intensities number points plotted scene equal number pixels display device surface rendering accomplished applying basic illumination model objects scence apply illumination model using either con stant intensity shading gouraud shading phong shading constant shading accurate polyhedrons curved surface polygon meshes references viewing light source positions far objects scene gouraud shading approximates light reflections curved surfaces calculating inten sity values polygon vertices interpolating intensity values across polygon facets accurate slower surface rendering procedure phong shading interpolates average narmal vectors polygon ver tices polygon facets surface intensities calculated using terpolated normal vectors fast phong shading used speed calcu lations using taylor series approximations ray tracing provides accurate n ethod obtaining global specular flection transmission effects pixel rays traced scene bouncing object object accumulating intensity contributions ray tracing tree constructed pixel intensity values combined ter minal nodes tree back root object intersection calculations ray tracing reduced space subdivision methods test ray object tersections within subregions total space distributed distribution ray tracing traces multiple rays per pixel distributes rays randomly various ray parameters direction time provides accurate method modeling surface gloss translucency finite camera apertures dis tributed light sources shadow effects motion blur radiosity methods provide accurate modeling diffuse reflection effects calculating radiant energy transfer various surface patches scene progressive refinement used speed radiosity calculations considering energy transfer one surface patch time highly photorealis tic scenes generated using combination ray tracing radiosity fast method approximating global illumination effects environment mapping environment array used store background intensity informa tion scene array mapped objects scene based specified viewing direction surface detail added objects using polygon facets texture map ping bump mapping frame mapping small polygon facets overlaid larger surfaces provide various kinds designs alternatively texture pat terns defined two dimensional array mapped object surfaces bump mapping means modeling surface irregularities applying bump function perturb surface normals frame mapping extension bump mapping allows horizontal surface variations well vertical variations references general discussion energy propagation transfer equations rendering processes perception light color given glassner algorithms various surface rendering techniques presented glassner arvo kirk discussion ordered dither error diffusion dot diffusion see knuth additional information ray tracing methods tound quek hearn glassner shirley koh hearn radiosity methods dis cussed goral et al cohen greenberg cohen et al wallace elmquist haines chen et al dorsey sillion greenberg et al sillion et al schoeneman et al lischinski tampieri greenberg chapter t4 murination models surface rendering methods exercises 10 11 12 13 14 15 16 17 18 19 20 write routine imelement eq basic illumination mode using single point light source constant surface shading faces specified polyhe dron object description given set polygon tables including sur face normals polygon faces additional input parameters include ambient intensity light source intensity sudace reflection coefficients coordinate information specified directly viewrng reference frame modify routine n exercise render polygon surface mesh using gouraud shading modify routine exercise render polygon surface mesh using phong shading write routine implement eq basic illumination model using single point light source gouraud surface shading tales specified polygon mesh object des ription given set polygon tables including sur face normals polygon faces additional input includes values ambient intensity light source intensity surface reflection cvefficients spec ular reflection parameter coordinate information specified directly viewing reference frame modify routine xercise render polygon surfaces using phong shad ing modify routine exercise include linear intensity attenuation func tion modify routine exercise render pulygon surfaces using phong shad ing linear intens ty attenuation function modify routine ixercise impiement eq 13 specified num ber polyhedrans light sources scene modify routine xercise implement eq 14 specified num ber polyhedrons light sources scene modify routine exercise implement fq 15 specified num ber polyhedrons light sources iy scene modify routine exercise implernent eqs 15 aid 19 specified number ight sources polyhedrons e ther opaque transparent scene discuss differenies might expect lo see appearance specula retlec tions modeled n h compared specular reflections modeled v rr verify 2a din fip 18 vectors coplanar general 2a discuss diterent visible surface detection hous cambined intensity model displaying set pelyhedrons opaque sucaces discuss var ous visinle suface detection mmetyods mod tied ta process transparent ofyects ary visible surtace detection methods tho cannut fandle transparent surlaces set algorithms based one ot wisibie surtace detection methods wil identify shadow areas na scene illuminated distant port source many intensity levels displayed halftane approximations using npixel grids pixel displayed mm citterent intensities many different color combinattons generated sing halttone approxi ttons twa level rgb system pixel grd write routine disp av given set surrace intensily varatians using halftone ap proximations pixel grids two intensity levels 1s per pixel write ouline generale ordered dither matrices using recurrence relation eq 34 21 22 23 24 25 26 27 28 29 30 31 32 33 write procedure display given array intensity values using ordered dither method write procedure implement error diffusion algorithm given n array intensity values write program implement basic ray tracing algorithm scene containing single sphere hovering checkerboard ground square scene illu minated single point light source viewing position write program implement basic ray tracing algorithm scene containing specified arrangement spheres polygon surfaces illuminated given set point light sources write program implement basic ray tracing algorithm using space subdivi sion methods specified arrangement spheres polygon surfaces inumi nated given set point light sources write program implement following features distributed ray tracing pixel sampling jittered rays per pixel distributed reflection directions distributed tefraction directions extended light sources set algorithm modeling motion blur moving object using distrib uted ray tracing implement basic radiosity algorithm rendering inside surfaces cube one inside face cube light source devise algorithm implementing progressive refinement radiosity method write routine transform environment map surface sphere write program implement texture mapping tor spherical surfaces b polyhedrons given spherical surface write bump mapping procedure generate bumpy surface orange write bump mapping routine produce surface normal variations speci fied bump function exercises chapter color models color applications ob4 ur discussions color point concentrated mecha nisms generating color displays combinations red green blue light mode helpful understanding color represented video monitor several color models useful well graphics ap plications models used describe color output printers plot ters models provide intuitive color parameter interface user color model method explaining properties behavior color within particular context single color model explain pects color make use different models help describe different perceived characteristics color properties light perceive light different colors narrow frequency band within electromagnetic spectrum frequency bands within spectrum called radio waves microwaves infrared waves x rays shows approximate frequency ranges electromag netic bands frequency value within visible band corresponds distinct color low frequency end red color x hertz highest frequency see violet color x hertz spectral colors range reds orange yellow low frequency end greens blues violet high end z 29 z z g e gs e x frequency 108 1081978 thertz electromagnetic spectrum chapter colo models color applications time variations one electric frequency component plane polarized electromagnetic wave since light electromagnetic wave describe various colors terms either frequency f wavelength wave illustrate oscillations present monochromatic electromagnetic wave po larized electric oscillations one plane wavelength fre quency monochromatic wave inversely proportional proportionality constant speed light c c frequency constant materials speed light wavelength material dependent ina vacuum c x cm sec light wavelengths small length units designating spectral colors usually either angstroms 1a cm nanometers nm cm equivalent term nanometer millimicron light red end spectrum wave length approximately nanometers nm wavelength violet light end spectrum nm since wavelength units somewhat convenient deal frequency units spectral colors typically specified terms wavelength light source sun light bulb emits frequencies within visible range produce white light white light incident upon ob ject frequencies reflected absorbed object combination frequencies present reflected light determines per ceive color object low frequencies predominant reflected light object described red case say perceived light dominant frequency dominant wavelength red end spectrum dominant frequency also called hue simply color light properties besides frequency needed describe various char acteristics light view source light eves respond color dominant frequency two basic sensations one call brightness perceived intensity light intensity radiant energy emitted per unit time per unit solid angle per unit projected area source radiant energy related juminance source second energy frequency energy distribution white light source red violet perceived characteristic purity saturation light purity describes washed pure color light appears pastels pale colors described less pure three characteristics dominant frequency brightness purity commonly used describe different properties perceive source light term chromaticity used refer collectively two properties describing color characteristics purity dominant fre quency energy emitted white light source distribution visible frequencies shown frequency component within range red violet contributes less equally total energy color source described white dominant frequency present energy distribution source takes form would describe light color corresponding dominant frequency energy density dominant light component labeled ep figure contributions frequencies produce white light energy density ey calculate brightness source area curve gives total energy density emitted purity de pends difference ep ey larger energy ep dom inant frequency compared white light component ey pure light purity percent fy purity percent ey ep view light formed combination two sources see resultant light characteristics determined original sources two different color light sources suitably chosen intensities used produce range colors two color sources combine pro energy e ew red viol frequency ee roret dominant energy distribution light source frequency dominant frequency near red end frequency range section properties light chapter color models color applications color matching rgb amounts ainm amounts rgb primaries needed display spectral colors duce white light referred complementary colors examples complementary color pairs red cyan green magenta blue yellow judicious choice two starting colors form wide range colors typically color models used describe com binations light terms dominant frequency hue use three colors obtain reasonably wide range colors called color gamut model two three colors used produce colors color model referred primary colors finite set real primary colors combined produce possible visible colors nevertheless three primaries sufficient purposes colors color gamut specified set primaries still described extended methods certain color produced combining three primaries mix one two primaries color obtain match combination remaining primaries extended sense set primary colors considered describe colors shows amounts red green blue needed produce spectral color curves plotted called color matching functions obtained aver aging judgments large number observers colors vicinity nm matched subtracting amount red light combi nation blue green lights means color around nm de scribed combining color amount red light produce blue green combination specified diagram thus rgb color monitor display colors neighborhood s00 standard primaries chromatic ty diagram since finite set color light sources combined display possible colors three standard primaries defined international com mission illumination referred cie commission internationale de eclairage three standard primaries imaginary colors defined mathematically positive color matching functions specity color matching cie amounts amounts cie primaries needed display spectral colors amount primary needed describe spectral color provides international standard definition colors cie primaries eliminate negative value color matching problems associated selecting set real primaries xyz color model set cie primaries generally referred xyz x z color model x z represent vectors three dimensional additive color space color c expressed c xx yy zz x z designate amounts standard primaries needed match c discussing color properties convenient normalize amounts eq luminance x z normalized amounts thus calculated x z yayen yo xeyez xs ezz x z thus color represented x amounts since normalized luminance parameters x called chromaticity values depend hue purity also specify colors x values obtain amounts x z therefore complete description color typically given three values x remaining cie amounts calculated x mae z z x using chromaticity coordinates x represent colors two dimensional diagram cie chromaticity diagram plot normalized amounts x colors visible spectrum obtain tongue shaped curve shown curve called cie chromaticity diagram points along curve pure colors section standard primaries chromaticity diagram chapter color models color applications spectral colors yellow red cie chromaticity diagram spectra 2 4 06 x color positions along curve labeled wavelength units nm electromagnetic spectrum labeled according wavelength nanometers red end violet end spectrum line joining red violet spectral points called purple line part spectrum interior points represent possible visible color combinations point c diagram corre sponds white light position actually point plotted white light source known illuminant c used standard approximation average daylight luminance values available chromaticity diagram normalization colors different luminance chromaticity map point chromaticity diagram useful following comparing color gamuts different sets primaries identifying complementary colors determining dominant wavelength purity given color color gamuts represented chromaticity diagram straight line segments polygons al colors along line joining points c c fig obtained mixing appropriate amounts colors c c greater proportion c used resultant color closer c c color gamut three points c3 c c triangle vertices three color positions three primaries generate colors side bounding edges triangle thus chromaticity diagram helps us understand set three primaries additively combined generate colors since triangle within diagram encompass colors color gamuts video monitors hard copy devices conveniently com pared chromaticity diagram since color gamut two points straight line complementary col ors must represented chromaticity diagram two points situated opposite sides c connected straight ine mix proper amounts two colors c c obtain white light also use interpretation color gamut two primaries de termine dominant wavelength color color point c draw straight line trom c c intersect spectral curve point x x color gamuts defined representing complementary determining dominant chromaticity diagram colors chromaticity wavelength purity two color three color diagram chromaticity diagram system primaries c color c represented combination white light c spectral color c thus dominant wavelength c c method de termining dominant wavelength work color points cand purple line drawing line c point c takes us point c purple line visible spectrum point c referred nonspectral color dominant wavelength taken compliment c lies spectral curve point c nonspectral colors purple magenta range spectral distributions subtractive dominant wavelengths generated subtracting spectral dominant wavelength c white light color point c determine purity relative distance c c along straight line joining c c denotes distance c c distance c c calculate pu rity ratio color c figure percent pure since situated one fourth total distance c c position c color point would percent pure artist creates color painting mixing color pigments white blacx pigments form various shades tints tones scene starting pigment pure color pure hue artist adds black pigment produce different shades color black pigment darker shade similarly different tints color obtained adding white pig ment original color making lighter white added tones color produced adding black white pigments many color concepts intuitive describing color set three numbers give relative proportions primary colors generally much easier think making coler lighter adding white making color darker adding black therefore graphics packages providing chapter color models color applications color palettes user often employ two color models one model pro vides intuitive color interface user others describe color com ponents output devices based tristimulus theory vision eyes perceive color stim ulation three visual pigments cones retina visual pigments peak sensitivity wavelengths nm red nm green nm blue comparing intensities light source perceive color light theory vision basis displaying color output video monitor using three color primaries red green blue referred rgb color model represent model unit cube defined r g b axes shown origin represents black vertex coordi nates white vertices cube axes represent primary col ors remaining vertices represent complementary color primary colors xyz color system rgb color scheme additive model intensities primary colors added produce colors color point within bounds cube represented triple r g b values r g b assigned range thus color c expressed rgb components c rr gg bb magenta vertex obtained adding red blue produce triple white sum red green blue vertices shades gray represented along main diagonal cube origin black white vertex point along diagonal equal contribu tion primary color gray shade halfway black grayscale green yeltow ens cyan white black a4 j red r oo ee blus magenta rgb color model defining gs colors additive process within unit cube ial ib two views rgb color cube along grayscale diagonal white black b along grayscale diagonal black white table rgb x chromacity coordinates ntsc standard cie model approx color monitor values r 670 330 735 265 628 346 g 210 710 274 747 268 588 b 140 080 167 009 150 070 02 0 06 x rgb color gamut white represented color graduations along front top planes rgb cube illustrated chromaticity coordinates ntsc standard rgb phosphor listed table also listed rgb chromaticity coordinates cie rgb color model approximate values used phosphors color monitors shows color gamut ntsc standard rgb rrimaries section rgb color model chapter color models color applications whereas rgb monitor requires separate signals red green blue components image television monitor uses single composite signal national television system committee ntsc color model forming com posite video signal yiq model based concepts cie xyz model yiq color model parameter xyz model lu minance brightness information contained parameter chro maticity information hue purity incorporated j q parame ters combination red green blue intensities chosen parameter yield standard luminosity curve since contains luminance information black white television monitors use signal largest bandwidth ntsc video signal mhz assigned information parameter contains orange cyan hue information provides flesh tone shading occupies bandwidth approximately mhz para meter q carries green magenta hue information bandwidth mhz rgb signal converted television signal using ntsc en coder converts rgb values yiq values modulates superim poses j q information signal conversion rgb values yiq values accomplished transformation 299 587 144 r 275 g q 212 528 311 _b transformation based ntsc standard rgb phosphor whose chro tmaticity coordinates given preceding section larger proportions red green assigned parameter indicate relative importance hues determining brightness compared blue ntsc video signal converted rgb signal using ntsc decoder separates video signal yiq components con verts rgb values convert yiq space rgb space inverse matrix transformation eq r 000 956 620 g b 000 108 705 q color model defined primary colors cyan magenta yellow cmy useful describing color output hard copy devices unlike video monitors produce color pattern combining light screen phosphors hard copy devices plotters produce color picture coating paper color pigments see colors reflected light subtractive process noted cyan formed adding green blue light therefore white light reflected cyan colored ink reflected light must red component red light absorbed subtracted ink similarly magenta ink subtracts green component incident light yellow subtracts blue component unit cube representation cmy model illustrated cmy model point represents black components incident light subtracted origin represents white light equal amounts primary colors produce grays along main diagonal cube combination cyan magenta ink produces blue light red green components incident light absorbed color combinations obtained similar subtractive process printing process often used cmy mode generates color point collection four ink dots somewhat rgb monitor uses col lection three phosphor dots one dot used primary colors cyan magenta yellow one dot black black dot included cause combination cyan magenta yellow inks typically produce dark gray instead black plotters produce different color combinations spraying ink three primary colors allowing mix dry express conversion rgb representation cmy repre sentation matrix transformation cc k mi b white represented rgb system unit column vector sim ilarly convert cmy color represeniation rgb representation matrix transformation c 1m ia black represented cmy system unit column vector instead set color primaries hsv model uses color descriptions intuitive appeal user give color specification user selects spectral color amounts white black added ob tain different shades tints tones color parameters model aue h saturation value v section hsv color model g rayseate magenta blue red nie black cyan white c yellow green cmy color model defining colors subtractive process inside unit cube chapter green color models color applications cyan yellow blue red r magenta rgb color cube color hexagon b rgb color cube viewed along diagonal white black color cube outline hexagon b three dimensional representation hsv model derived rgb cube imagine viewing cube along diagonal white vertex origin black see outline cube hexagon shape shown boundary hexagon represents various hues used top hsv jhexcone hexcone saturation measured along horizontal axis value along vertical axis center hexcone hue represented angle vertical axis ranging red vertices hexagon separated intervals yellow green cyan opposite red h complementary colors apart v value yellow wal cyan white v h hue angle vad biack sisaturation hsv hexcone v tints pure hue white v shades black cross section hsv hexcone showing regions shades tints tones saturation varies represented madel ratio purity selected hue maximum purity selected hue said one quarter pure value 25 gray scale value v varies apex hexcone top apex represents black top hexcone colors maximum intensity v pure hues white point v intuitive model users starting selection fora pure hue specifies hue angle h sets v describe color want terms adding either white black pure hue adding black decreases setting v held constant get dark blue v could set h similarly white added hue selected parameter decreased keeping v constant light blue could designated v h adding black white decrease v interface model typically presents hsv parameter choices color palette color concepts associated terms shades tints tones repre sented cross sectional plane hsv hexcone adding black pure hue decreases v side hexcone thus various shades represented values v adding white pure tone pro duces different tints across top plane hexcone parameter values v various tones specified adding black white producing color points within triangular cross sectional area hexcone human eye distinguish different hues dif ferent tints saturation levels number shades value set tings detected depending hue selected shades dis cernible yellow colors different shades seen blue end spectrum means distinguish x x 720 different colors graphics applications hues saturation lev els value settings sufficient range parameters hsv color model 384 colors would available user system would need bits color storage per pixel color lookup tables could used duce storage requirements per pixel increase number available colors section hsv color mode chapter color models color applications hsv color parameters made available user graphics package parameters transformed rgb settings needed color monitor determine operations needed transformation first consider hsv hexcone derived rgb cube diagonal cube trom black origin white corresponds v axis hexcone also subcube rgb cube corresponds hexagonal cross sectional area hexcone cross section sides hexagon radial lines v axis vertex value v set rgb values v equal maximum value set hsv point corresponding set rgb values lies hexagonal cross section value v parameter determined relative distance point v axis parameter h determined calculating relative position point within sextant hexagon algorithm mapping set rgb values corre sponding hsv values given following procedure include math h input h v range outputs r g bk range void hsvilorgb float h float float v float r int float aa bb cc ft float yg float b grayscale tr se tg bey else th h h ios floor nh f h aa v 5s bb sv co v ss switch case r v g cc b aa break case tr bb g vi b ad break case r aa g v th cc break case r aa g bb h v break case r cc g aa b v break case r v g aa b bb break obtain transformation hsv parameters rgb parameters determining inverse equations rgbtohsv procedure verse operations carried sextant hexcone resulting transformation equations summarized following algorithm kinclude math h define min b b define max b b define no_hue input r g b range outputs h v range ioe void rgbtohsyv float r float g float b floac h float float v float max max r max g b min min r min g b float delta max min yvo max max delta max else h no_hue else r max h g b delta else g max th b x delta else b max h x g delta h h th h hls color model another model based intuitive color parameters hls system used tektronix model double cone representation shown three color parameters model called hue h lightness l saturation hue meaning hsv model specifies angle vertical axis locates chosen hue model h corresponds blue remaining colors specified around perimeter cone order hsv model magenta red cyan lo cated h complementary colors apart double cone vertical axis model called lightness l l black white l gray scale along l axis pure hues lie l plane saturation parameter specifies relative purity color para meter varies pure hues l decreases hues said less pure gray scale hsv model hls system allows user think terms making selected hue darker lighter hue selected hue angle h desired shade tint tone obtained adjusting l colors made lighter increasing l made darker decreasing l decreased colors move toward gray section hls color model chapter color models color applications l lightness ded yeliow blue h hue angle l black saturation hls double cone graphics package provide color capabilities way aids us making color selections various combinations colors selected using sliders color wheels system also designed aid selection har monizing colors addition designer package follow basic color rules designing color displays presented user one method obtaining set coordinating colors generate set subspace color model colors selected regular intervals along straight line within rgb cmy cube example expect obtain set well matched colors randomly selected hues expected produce harsh clashing color combinations another consideration selection color combinations different colors perceived different depths occurs eyes focus colors according frequency blues particular tend recede displaying blue pattern next red pattern cause eye fatigue continually need refocus attention switched one area problem reduced separat ing colors using colors one half tess color hexagon hsv model technique display contains either blues greens reds yellows gencral rule use smaller number colors produces pleasing display large number colors tints shades blend better pure hues background gray complement one fore ground colors usually best summary chapter discussed basic properties light concept color model visible light characterized narrow frequency distribu tion within electromagnetic spectrum light sources described terms dominant frequency hue luminance brightness purity sai uration complementary color sources combine produce white light one method defining color model specify set two primary colors combined produce various colors common color models defined three primary colors rgb cmy madels video monitor displays use rgb model hardcopy devices produce color put using cmy model color models based specification lumi nance purity values include q hsv hls color models intuitive color models hsv hls models allow colors specified selecting value hue amounts white black added selected hue since model specified finite set color parameters capable describing possible colors set three hypothetical colors called cie primaries adopted standard defining color combinations set cie primaries commonly referred xyz color model plot ting normalized values x standards produces cie chromaticity diagram gives representation color terms hue purity use diagram compare color gamuts different color models identify complementary colors determine dominant frequency purity given color important consideration generation color display selec tion harmonious color combinations following simple rules coordinating colors usually selected within small subspace color model also avoid displaying adjacent colors differ widely ir dominant frequency limit displays small number color combinations formed tints shades rather pure hues references comprehensive discussion science color given wyszecki stiles color models color display techniques discussed durrett hall travis algorithms various color applications presented n glassner arvo kirk additional infoymation human visual sys tem perception light color see glassnet references chapter color models color applications exercises 10 11 12 derive expressions converting rgb color parameters hsv values derive expressions converting hsv color values rgb values write interactive procedure allows selection hsv color parameters irom displayed menu hsv values converted rgb values storage frame buffer derive expressions converting rgb color values hls color parameters derive expressions converting hls color values rgb values write program allows interactive selection hls values color menu converts values ta corresponding rgb values write program produce set colors linearly interpolated tween two specified positions rgb space write interactive routine selecting color values within specified sub space rgb space write program produce set cofors linearly interpolated tween two specified positions hsv space write program produce set colors linearly interpolated tween two specified positions hls space display two rgb color grids side side video monitor fill one grid set randomly selected rgb colors fill grid set colors selected small rgb subspace experiment different random selections different rgb subspaces compare two color grids display two color grids exercise 11 using color selections either hsv hls calor space chapter computer animation ome typical applications computer generated animation entertain ment motion pictures cartoons advertising scientific engineering studies training education although tend think animation implying object motions term computer animation generally refers time sequence visual changes scene addition changing object posi tion translations rotations computer generated animation could dis play time variations object size color transparency surface texture adver tising animations often transition one object shape another example transforming motor oi automobile engine computer animations also generated changing camera parameters position orienta tion focal length produce computer animations changing lighting effects parameters procedures associated illumination rendering many applications computer animation require realistic displays ac curate representation shape thunderstorm natural phenomena described numerical model important evaluating reliability model also simulators training aircraft pilots heavy equipment oper ators must produce reasonably accurate representations environment en tertainment advertising applications hand sometimes interested visual effects thus scenes may displayed exaggerated shapes unrealistic motions transformations many entertain ment advertising applications require accurate representations computer generated scenes scientific engineering studies real ism goal example physical quantities often displayed pseudo colors abstract shapes change tume help researcher un derstand nature physical process general animation sequence designed following steps storyboard layout object definitions key frame specifications generation frames standard approach animated cartoons applied animation ap plications well although many special applications fol low sequence real time computer animations produced flight simulators instance display motion sequences response settings aircraft con trols visualization applications generated solutions numer ical models frame frame animation frame scene separately generated stored later frames recorded film consecutively displayed real time playback mode storyboard outline action defines motion sequence set basic events take place depending type animation produced storyboard could consist set rough sketches could list basic ideas motion object definition given participant action objects defined terms basic shapes polygons splines addition sociated movements object specified along shape key frame detailed drawing scene certain time anima tion sequence within key frame object positioned according time frame key frames chosen extreme positions ac tion others spaced time interval key frames great key frames specified intricate motions simple slowly varing motions betweens intermediate frames key frames num ber betweens needed determined media used display animation film requires frames per second graphics terminals freshed rate frames per second typically time intervals motion set three five betweens pair key frames depending speed specified motion key frames duplicated minute film sequence duplication would need frames five betweens pair key frames would need key frames motion complicated could space key frames little farther apart several tasks may required depending appli cation include motion verification editing production synchro nization soundtrack many functions needed produce general ani mations computer generated figures show examples computer generated frames animation sequences one frame award winning computer animated short film luxe jr film designed using key frame animation system cartoon animation techniques provide lifelike actions lamps final images rendered multiple light sources procedural texturing techniques courtesy pixar pixar section design animation sequences one frame short film tin toy first computer animated film win oscar designed using key frame animation system film also required extensive facial expression modeling final images rendered using procedural shading self shadowing techniques motion blur texture mapping courtesy pixar pixar general computer animation functions steps development animation sequence well suited com puter solution include object manipulations rendering camera mo tions generation betweens animation packages wave front example provide special functions designing animation processing individual objects one function available animation packages provided store man age object database object shapes associated parameters stored updated database object functions include motion genera tion object rendering motions generated according speci fied constraints using two dimensional three dimensional transformations standard functions applied identify visible surfaces apply rendering algorithms another typical function simulates camera movements standard motions zooming panning tilting finally given specification key frames betweens automatically generated raster systems generate real time animation limited applications using raster operations seen section simple method trans lation xy plane transfer rectangluar block pixel values one location another two dimensional rotations multiples also simple perform although rotate rectangular blocks pixels arbitrary angles using antialiasing procedures rotate block pixels need de termine percent area coverage pixels overlap rotated block sequences raster operations executed produce real time ani mation either two dimensional three dimensional objects long strict animation motions projection plane viewing visi ble surface algorithms need invoked also animate objects along two dimensional motion paths using color table transformations predefine object successive positions along motion path set successive blocks pixel values color table real time raster color table animation entries set pixels first position object values set pixels object positions background color animation accomplished changing color table values object successively positions along animation path preceding position set background intensity design control animation sequences handled set animation routines general purpose language c lisp pascal fortran often used program animation functions several specialized animation languages developed animation functions include graphics editor key frame generator generator standard graphics routines graphics editor allows us design modify object shapes using spline surfaces constructive solid geometry methods representation schemes typical task animation specification scene description includes positioning objects light sources defining photometric parameters light source intensities surface illumination properties setting camera parameters position orientation lens characteristics another stan dard function action specification involves layout motion paths objects camera need usual graphics routines viewing perspective transformations geometric transformations generate cbject move ments function accelerations kinematic path specifications visible sur face identification surface rendering operations key frame systems specialized animation languages designed simply generate betweens user specified key frames usually ob ject scene defined set rigid bodies connected joints limited number degrees freedom example single arm robot six degrees freedom called arm sweep shoulder swivel elbow extension pitch yaw roll extend number de grees freedom robot arm nine allowing three dimensional trans lations base also allow base rotations robot arm total degrees freedom human body comparison degrees freedom parameterized systems allow object motion characteristics specified part object definitions adjustable parameters control object characteristics degrees freedom motion limitations allowable shape changes section computer animation languages chapter computer animation la translational rotational degrees freedom base robot arm elbow kon renin shoutder swivel yaw rn roll pitch degrees freedom stationary single arm robot scripting systems allow object specifications animation sequences defined user input serip script library various objects motions constructed generate set betweens specification two key frames motion paths given kinematic description set spline curves motions physically tased specifying forces acting objects animated complex scenes separate frames individual components objects called cefs celluloid transparencies acronym cartoon anima tion given animation paths interpolate positions individual objects two times complex object transformations shapes objects may change time examples clothes facial features magnified detail evolving shapes exploding disintegrating objects transforming one object object surfaces described polygon meshes number edges per polygon change one frame next thus total num ber line segments different different frames morphing transformation object shapes one form another called morphing shortened torm metamorphosis morphing methods applied motion transition involving change shape given two key frames object transformation first adjust object specification one frames number polygon edges number vertices two frames preprocessing step il lustrated straight line segment key frame k transformed two line segments key frame k since key frame k extra vertex add vertex vertices key frame k balance number vertices edges two key frames using linear interpolation generate betweens transition added vertex key frame k vertex along straight line path shown example triangle linearly expanding quadrilateral given figures 10 show examples morphing television advertising v key key frame k frame k edge vertex positions key frame k evolves two connected edges key frame k linear interpolation transforming line segment key frame two connected line segments key frame k key frame k linear interpolation transforming triangle quadrilateral state general preprocessing rules equalizing key frames terms either number edges number vertices added key frame suppose equalize edge count parameters l l denote number line segments two consecutive frames define lina max ly lea linn min ly ly n las mod n ine mun transformation stp oil engine block courtesy salicon graphres inc b eed tot td transtormation moving automobile running tiger courtesy exxon company usa arid pactfic data images preprocessing accomplished dividing n edges keyframe n sections dividing remaining lines keyframe n sections example l l would divide lines keyframe sections remaining lines keyframe left intact equalize vertex count use parameters v v de note number vertices two consecutive frames case define vinax max vye ver vinin min v v nis vinax mod vann venax n int min preprocessing using vertex count performed adding n points n line sections keyframerun adding n points remaining edges keyframegin triangle quadrilateral example v v n n would add one point one edge keyframe points would added remaining lines keyframe simulating accelerations curve fitting techniques often used specify animation paths key frames given vertex positions key frames fit positions linear nonlinear paths illustrates nonlinear fit key frame positions determines trajectories betweens simulate accel erations adjust time spacing betweens constant speed zero acceleration use equal interval time spacing betweens suppose want n betweens key frames times time interval key frames divided n subintervals yielding spacing ho al nel calculate time fb f jdt jf 4h determine values coordinate positions color physical para meters nonzero accelerations used produce realistic displays speed changes particularly beginning end motion sequence model start slow portions animation path spline section key frame systems fitting key frame vertex positions nonlinear splines trignometric functions parabolic cubic time functions applied acceleration modeling trignometric functions commonly used animation packages model increasing speed positive acceleration want time spacing frames increase greater changes position occur object moves faster obtain increasing interval size function cos6 o0 w betweens time jth would calculated cos ft j tby ty asf ss af time difference two key frames gives plot trigonometric acceleration function spacing model decreasing speed deceleration sin range time position defined jw tbe j ty atsin j n j j j ty positions motion constant speed le trigonometric acceleration function corresponding spacing n ja eq producing increased coordinate changes object moves time interval plot function decreasing size time intervals shown five betweens often motions contain speed ups slow downs model combination increasing decreasing speed first increasing time spacing decrease spacing function accomplish time changes sind t8 tb 2345 v z trigonometric deceleration function corresponding spacing n jr eq producing decreased coordinate changes object moves time interval bs trigonometric accelerate decelerate function corresponding spacing n eq cos time jth calculated 1bp arf coetintn ny j af denoting time difference two key frames time intervals moving object first increase time intervals decrease shown fig 15 processing betweens simplified initially modeling skeleton wireframe objects allows interactive adjustment motion sequences animation sequence completely defined objects fully ren dered several ways motions objects specified ani mation system define motions explicit terms use abstract general approaches direct motion specification straightforward method defining motion sequence direct specifi cation motion parameters explicitly give rotation angles translation vectors geometric transformation matrices applied transform coordinate positions alternatively could use approximating mf po og ro og roe oy ay ra oi ow ay vi e rene u rel eros u ys g vi 4 yy x approximating motion bouncing ball damped sine function eq 10 equation specify certain kinds motions approximate path bouncing ball instance damped rectified sine curve yax isin ox le 10 initial amplitude w angular frequence phase angle k damping constant methods used simple user pro grammed animation sequences cgoal directed systems opposite extreme specify motions take place gen eral terms abstractly describe actions systems referred goal directed determine specific motion parameters given goals animation example could specify want object walk run particular destination could state want object pick specified object input directives inter preted terms component motions accomplish selected task human motions instance defined hierarchical structure sub motions torso limbs forth kinematics dynamics also construct animation sequences using kinematic dynamic descrip tions kinematic description specify animation giving motion parameters position velocity acceleration without reference forces cause motion constant velocity zero acceleration designate motions rigid bodies scene giv ng initial position velocity vector chapter computer animation object example velocity specified km sec vector gives direction straight line motion path speed magnitude velocity km sec also specify accelerations rate change velocity generate speed ups slow downs curved motion paths kinematic specification motion also given simply describing motion path often done using spline curves alternate approach use inverse kinematics specify ini tial final positions objects specified times motion parameters computed system example assuming zero accelerations de termine constant velocity accomplish movement object fom initial position final position method often used com plex objects giving positions orientations end node object hand foot system determines motion parameters nodes accomplish desired motion dynamic descriptions hand require specification forces produce velocities accelerations descriptions object behav ior irfluence forces generally referred physically based modeling chapter examples forces affecting object motion include electro magnetic gravitational friction mechanical forces object motions obtained force equations describing physical laws newton laws motion gravitational friction processes euler navier stokes equations describing fluid flow maxwell equations electromagnetic forces example general form newton second law particle mass m1 f au 11 f force vector v velocity vector mass constant solve equation f acceleration vector otherwise mass function time relativistic motions motions space vehicles consume measurable amounts fuel per unit time also use inverse dy namics obtain forces given initial final positions objects type motion applications physically based modeling include complex rigid body sys tems nonrigid systems cloth plastic materials typically numeri cal methods used obtain motion parameters incrementally dy namical equations using initial conditions boundary values summary computer animation sequence set specifying storyboard object definitions key frames storyboard outline action key frames define details object motions selected positions animation key frames established sequence tweens generated construct smooth motion one key frame next computer animation involve motion specifications objects scene well motion paths camera moves scene com puter animation systems include key frame systems parameterized systems scripting systems motion two dimensions use raster anima tion techniques discussed chapter applications key frames used detine steps morph ing sequence changes one object shape another meth ods include generation variable time intervals simulate accelerations decelerations motion motion specifications given terms translation rotation para meters motions described equations kinematic dy namic parameters kinematic motion descriptions specify positions velocities accelerations dynamic motion descriptions given terms forces acting objects scene references additional information computer animation systems techniques see magnenat thalmann thalmann barzel watt wait algorithms animation applications presented glassner arvo kirk gas cuel ngo marks van de panne fiume snyder et al morphing techniques discussed beier neely hughes kent carlson parent sederberg greenwood discussion animation techniques phigs given gaskins exercises design storyboard layout accompanving key trames animation sin gle polyhedron write program generate betweens key frames specified exercise using linear interpolation expand animation sequence exercise include two moving ob jects write program generate betweens jor key frames exercise using linear erpolation write morphing program transform sphere specilied polyhedron sel animation specification invalving accelerations implement eq sel animation specification involving accelerations decelerations implement spacing calculations given eqs set animation specification implementing acceleration deceleration calcu latians eq write program simulate linear two dimensional motion filled circle inside given rectangular area circle given initial velocity circle rebound walls angle reflection equal angle incidence 10 convert program exercise ball paddle game replacing one side rectangle short line segment moved back forth intercept circle path game circle escapes interior rectangle initial input parameters include circle position direction speed game score include number times circle intercepted pad dle 11 expand program exercise simulate three dimensional motion sphere moving inside parallelepiped interactive viewing parameters set view motion different directions 12 write program implement simulation bouncing ball using eq 10 13 write program implement motion bouncing bail using downward exercises chapter computer animation 14 15 zravitational force ground plane friction force initially ball pro jected space given velocity vector write program implement two player pillbox game game imple mented flat plane fixed pillbox positions random terrain features pillbox placements generated start game write program implement dynamic motion specifications specify scene two objects initial motion parameters specified forces generate animation solution force equations example objects could earth moon sun attractive gravitational forces propor tional mass inversely proportional distance squared appendix mathematics computer graphics omputer graphics algorithms make use many mathematica concepts techniques provide brief reference topics ana lytic geometry linear algebra vector analysis tensor analysis complex numbers numerical analysis areas referred graphics algorithms discussed throughout book coordinate reference frames graphics packages typically require coordinate parameters specified respect cartesian reference frames many applications non cartesian coordinate systems useful spherical cylindrical symmetries often exploited simplify expressions involving object descriptions manipu lations unless specialized graphics system available however must first convert non cartesian descriptions cartesian coordinates section first review standard cartesian coordinate systems consider common non cartesian systems two dimensional cartesian reference frames figure shows two possible orientations cartesian screen reference sys tem standard coordinate orientation shown fig coordi nate origin lower left corner screen commonly used reference figure screen cartesian reference systems coordinate origin lower left screen corner b coordinate origin upper left corner figure polar coardinate reference frame formed concentric circles radial lines figure relationship polar cartesian coordinates frame systems particularly personal computers orient cartesian refer ence frame fig b origin upper left corner addition possible graphics packages select position center screen coordinate origin polar coordinates xy plane frequently used non cartesian system polar coordinate reference frame fig coordinate position specified radial distance r coordinate origin angular displacement horizontal posi tive angular displacements counterclockwise negative angular displace ments clockwise angle measured degrees one complete counterclockwise revolution origin relation carte sian polar coordinates shown fig considering right triangle fig using definition trigonometric functions transform polar coordinates cartesian coordinates expressions x rcos rsind inverse transfarmation cartesian polar coordinates r tan x conics besides circles used specify coordinate positions example using concentric ellipses instead circles give coordinate positions elliptical coordinates similarly types symmetries ex ploited hyperbolic parabolic plane coordinates section coordinate reference frames figure right triangle hypotenuse r sides x appendix figure angle subtended circular arc length radius r angular values specified degrees given dimen sionless units radians figure shows two intersecting lines plane circle centered intersection point p value cf angle radians given ia length circular arc subtending r radius cir cle total angular distance around point p length circle perimeter 2a divided r radians three dimensianal cartesian reference frames figure shows conventional orientation coordinate axes three dimensional cartesian reference system called right handed sys tem right hand thumb points positive z direction imagine grasping z axis fingers curling positive x axis positive axis illustrated fig b computer graph ics packages require object descriptions manipulations specified right handed cartesian coordinates discussions throughout book cluding appendix assume cartesian reference frames right handed another possible arrangement cartesian axes left handed system shown fig system left hand thumb points positive z direction imagine grasping z axis fingers left hand curl positive x axis positive axis orientation axes sometimes convenient describing depth objects relative display screen screen locations described xy plane left handed system coordinate origin lower left screen comer positive z values indi cate positions behind screen fig larger values along posi tive z axis interpreted farther viewer three dimensional curvilinear coordinate systems non cartesian reference frame referred curvilinear coordinate sys tem choice coordinate system particular graphics application de pends number factors symmetry ease computation visu axis axis ate ed see zaxis x axis axis x axis figure b coordinate representation point p position x z right handed cartesian reference system b figure left handed cartesian coordinate system superimposed surface af video monitor figure general curvilinear coordinate reference frame alization advantages figure shows general curvilinear coordinate reference frame formed three coordinate surfaces surface one coordi nate held constant instance x x surface defined x held constant coordinate axes reference frame intersection curves coordi nate surfaces coordinate surfaces intersect right angles thogonal curvilinear coordinate system nonorthogonal reference frames useful specialized spaces visualizations motions governed laws general relativity general used less frequently graphics applications orthogonal systems cylindrical coordinate specification spatial position shown fig relation cartesian reference frame surface constant pis vertical zz axis ply z axis figure x axis cylindrical coordinates p z section coordinate reference frames appendix figure spherical coordinates r cylinder surface constant vertical plane containing z axis surface constant z horizontal plane parallel cartesian xy plane transform cylindrical coordinate specification cartesian reference frame calculations x pcos psin z z figure shows spherical coordinate specification spatial position reference cartesian reference frame spherical coordinates sometimes ferred polar coordinates space surface constant r sphere sur face constant vertical plane containing z axis surface cylindrical coordinates surface constant cone apex coordinate origin cone xy plane cone xy plane transfrom spherical coordinate specification cartesian reference frame calculations x rcos sing rsin sing z rcosd solid angle define solid angle analogy two dimensional angle tween two intersecting lines eq instead circle consider sphere center position p solid angle w within cone shaped region apex p defined w area spherical surface intersected cone fig r radius sphere also analogy two dimensional polar coordinates dimension less unit solid angles called steradian total solid angle point total area spherical surface divided r steradians figure solid angle w subtended spherical surface patch area radius r points vectors fundamental difference concept point vector point position specified coordinate values reference frame distance origin depends choice refer ence frame figure illustrates coordinate specification two reference frames frame point coordinates given values ordered pair x frame b point coordinates distance ori gin frame b vector hand defined difference two point positions thus two dimensional vector fig v p p x v v cartesian components cartesian elements v v projec tions v onto x axes given two point positions obtain vector components way coordinate reference frame describe vector directed line segment two fundamental properties magnitude direction two dimensional vector fig calculate vector magnitude using pythagorean theorem frame b oo x frame figure position point p respect two different cartesian reference frames section points vectors appendix figure direction angles figure gravitational force vector f velocity vector v ys figure vector v ay plane cartesian reference frame lvl v v2 direction two dimensional vector given terms angu lar displacement x axis tan x vector properties magnitude direction matter position vector within single coordinate system vector magnitude independent coordinate representation course change coor dinate representation values vector components change three dimensiunal cartesian space calculate vector magnitude lvl vvi v2 vector direction given direction angles b vector makes coordinate axes fig direction angles posi tive angles vector makes positive coordinate axes calculate angles vv lv v l cosb ti cosy vl 1d cosa values cosa cos8 cosy called direction cosines vector actu ally need specify two direction cosines give direction v since cos cos b cos vectors used represent quantities properties magnitude direction two common examples force velocity fig force thought push pull certain amount ina par figure two vectors added geometrically positioning two vectors end end b drawing resultant vector start first vector tip second vector ticular direction velocity vector specifies fast speed object moving certain direction vector addition scalar multiplication definition sum two vectors obtained adding corresponding com ponents vit va way van vi vag vis vin 13 vector addition illustrated geometrically fig obtain vector sum placing start position one vector tip vector draw ing summation vector fig addition vectors scalars undefined since scalar always one numerical value vector mt numerical components n dimen sional space scalar multiplication three dimensional vector defined av av av av example scalar parameter value component v doubled also multiply two vectors two possible ways multiplication carried either obtain another vector obtain scalar quantity scalar product two vectors vector multiplication producing scalar defined v vi vil valcos os 15 angle two vectors fig product called scalar product dot product two vectors also referred inner product particularly discussing scalar products tensor analysis equa tion valid coordinate representation interpreted product parallel components two vectors section points vectors wane figure dot product two vectors obtained multiplying parallel components appendix addition coordinate independent form scalar product express product specific coordinate representations cartesian reference frame scalar product calculated vi v2 visvag viyvoy viva dot product vector simply another statement pythagorean theorem also scalar product two vectors zero two vectors perpendicular orthogonal dot products commutative v v2 vv operation produces scalar dot products distributive respect vector addition v v2 v3 vy v2 vy v3 vector product two vectors multiplication two vectors produce another vector defined v xv ulvv v sing o50 sa 19 u unit vector magnitude perpendicular v v fig direction u determined right hand rule grasp axis perpendicular plane v v fingers right hand curl v v right thumb points direction u product called vector product cross product two vectors equa tion valid coordinate representation cross product two vec tors vector perpendicular plane two vectors magnitude equal area parallelogram formed two vectors also express cross product terms vector components specific reference frame cartesian coordinate system calculate com ponents cross product vy x va viyvaz virvoye vievax visvoe virvay viyw2 20 let u u u represent unit vectors magnitude along x z axes write cross product terms cartesian components using de terminant notation vix figure cross product two vectors vector direction perpendicular two orginal vectors magnitude equal area shaded parallelogram u uu vixv vi vy vx vy va cross product two parallel vectors zero therefore cross product vector zero also cross product commutative anticommutative v x v v x v cross product associative v xx vy x va v xv x vy cross product distributive respect vector addition vy x v2 va cv x v2 v1 v3 basis vectors metric tensor specify coordinate axes reference frame set vectors one axis fig coordinate axis vector gives direction axis point along axis vectors form linearly independent set vectors axis vectors written linear combinations also vector space written linear combi nation axis vectors set axis vectors called basis set base vectors space general space referred vector space basis contains minimum number vectors represent vector space linear combination base vectors orthonormal basis often vectors basis normalized vector magnitude case set unit vectors called normal basis also cartesian reference frames commonly used coordinate systems coordinate axes mutually perpendicular set base vectors referred orthogonal basis addition base vectors unit vectors orthonormal basis satisfies following conditions uu allk u u k commonly used reference frames orthogonal nonorthogonal coor dinate reference frames useful applications including relativity ory visualization certain data sets two dimensional cartesian system orthonormal basis section basis vectors metric tensor figure curvilinear coordinate axis vectors appendix u uy orthonormal basis three dimensional cartesian reference frame u uy metric tensor tensors generalizations notion vector specifically tensor quantity number components depending tensor rank dimension space satisfy certain transformation properties con verted one coordinate representation another orthogonal systems transformation properties straightforward formally vector tensor rank one scalar tensor rank zero another way view classi fication note components vector specified one sub script scalar always single value hence subscripts ten sor rank two thus two subscripts three dimensional space tensor rank two nine components three values subscript general curvilinear coordinate system elements coeffi cients metric tensor space defined sa uys thus metric tensor rank two symmetric metric tensors several useful properties elements metric tensor used de termine distance two points space transformation equa tions conversion another space components various differential vector operators gradient divergence curl within space orthogonal space x j k cartesian coordinate system assuming unit base vectors ifj k otherwise 50 unit base vectors polar coordinates expressed terms cartesian base vectors u u cos uysing u rsin u rcos substituting expressions eq obtain elements metric tensor written matrix form flo blo cylindrical coordinate reference frame base vectors u u cos u sind uy u psin u pcos u matrix representation metric tensor cylindrical coordinates g p write base vectors spherical coordinates u u cos sing u sin sing u cosd u u rsinosing uyrcos sind ug urcos cosd uyrsin cos u rsind matrix representation metric tensor spherical coordinates b fsin oo ff matrices matrix rectangular array quantities numbers functions numerical expressions called elements matrix examples matrices x 60 01 00 ee x _ 00 eh le 3h a2 ay identify matrices according number rows number columns examples matrices left right order number rows number columns second example matrix called square matrix general write n matrix ay ay sae ay aq ay amr ann represent elements matrix first subscript ele ment gives row number second subscript gives column number matrix single row single column represents vector thus last two matrix examples respectively row vector column vec tor general matrix viewed collection row vectors col lection column vectors various operations expressed matrix form standard mathe matical convention represent vector column matrix following convention write matrix representation three dimensional vector section matrices appendix cartesian coordinates vy v vv use matrix representation points vectors must keep mind distinction often convenient consider point vector start position coordinate origin within single coor dinate reference frame points properties vectors main invariant switching one coordinate system another also general apply vector operations vector addition dot product cross product points sealar multiplication matrix addition multiply matrix scalar value multiply element scalar example 3a matrix addition defined matrices number rows number columns two n matrices sum obtained adding corresponding elements example 15 val 35 61 matrix multiplication product two matrices defined generalization vector dot prod uct multiply n matrix p q matrix b form matrix product ab providing number columns equal number rows b ie p obtain product matrix forming sums products elements row vectors corresponding ele ments column vectors b thus following product c ab obtain q matrix c whose elements calculated mn cy abe kel following example matrix postmultiplied trix produce product matrix qo i1 alk l 3 4 38 14 22 vector multiplication matrix notation produces result dot product providing first vector expressed row vector second vector expressed column vector vector product results matrix single element matrix multiply vectors reverse order obtain matrix 12 j223 10 12 previous two vector products illustrate matrix multiplication general commutative abba matrix multiplication distributive respect matrix addition b c ab ac matrix transpose transpose matrix obtained interchanging rows columns example abcjff c matrix product transpose ab btat determinant matrix square matrix combine matrix elements produce single number called determinant determinants defined recursively matrix second order determinant defined fu 999 ay707 ay section matrices appendix calculate higher order determinants terms lower order determi nants calculate determinants order greater select col umn k ann n matrix compute determinant deta ay detay pl deta n n determinant submatrix obtained deleting jth row kth column alternatively select row j calculate determinant n deta ay detay kel calculating determinants large matrices n say done efficiently using numerical methods one way compute determinant de compose matrix two factors lu elements matrix l diagonal zero elements matrix u diagonal zero compute product diagonals l u obtain deta multiplying two products together method based following property determinants det ab deta det b another method calculating determinants based gaussian elimination procedures section matrix inverse square matrices obtain inverse matrix determi nant matrix nonzero lf inverse exists matrix said non singular matrix otherwise matrix called singular matrix prac tical applications matrix represents physical operation expect inverse exist inverse ann n square matrix denoted aa i1 identiy matrix diagonal elements value diagonal elements zero elements inverse matrix calculated elements aas det a4 a5q aq element jth row kth column n n submatrix obtained deleting kth row jth column matrix numerical methods used evaluate determinant elements inverse matrix large values n complex numbers definition complex number z ordered pair real numbers z x x called real part z called imaginary part z real imaginary parts complex number designated x z im geometrically complex number represented complex plane fig te complex numbers arise solutions equations e r 2r real number solutions thus complex numbers complex arithmetic set extensions real numbers provide solutions equations addition subtraction scalar multiplication complex numbers carried using rules two dimensional vectors multiplication complex numbers defined xp ye yo oyt2 wie hy2 xy definition complex numbers gives result real number multiplication imaginary parts zero rg xyx2 thus write real number complex form x x similarly pure imaginary number real part equal complex number called imaginary unit denoted imaginary axis figure position point z complex reataxis plane section complex numbers appendix electrical engineers often use symbol j imaginary unit symbol used represent electrical current rule complex multi plication therefore real number v using mule complex multiplication write pure imaginary number form iy also addition nile write complex number sum z oy therefore another representation complex number zextiy usual form used practical applications another concept associated complex number complex conjugate zox modulus absolute value complex number defined jzl gives length vector representing complex number e distance origin complex plane point z real imaginary parts division two complex numbers obtained _ x yi yo xb yf yy2 x2y1 ae 2ay2 wd b particularly useful representation complex numbers express tea imaginary parts terms polar coordinates fig z r cos isin imaginary axis figure polar coordinate position reslxaxis complex number z also write polar form z res 62 base natural logarithms e 718281828 cos isin euler formula complex multiplications divisions easily ob tained byhq reat nth reots complex number calculated vi vilcos zar isin aryl k n a64 n roots lie circle radius center origin complex plane form vertices regular polygon n sides quaternions complex number concepts extended higher dimensions quaternions numbers one real part three imaginary parts written g st iatjb ke coefficients b c imaginary terms rea numbers pa rameter real number called scalar part parameters j k defined properties p pp r ij ji k properties follows jka kj ki ik j 67 section quaternions appendix scalar multiplication defined analogy corresponding opera tions vectors complex numbers four components quaternion multiplied scalar value similarly quaternion addition defined gz ss sp fa ay f b key cy multiplication two quaternions carried using operations eqs ordered pair notation quaternion also formed analogy complex number notation q v v vector b c notauon quaternion addition expressed g2 v vy quaternion multiplication expressed terms vector dot cross products s15 vy v2 1v_ sv vx vo extension complex operations magnitude squared quater nion defined using vector dot product iqit sttvey inverse quaternion qi tare qq q q nonparametric represen tations write object descriptions directly terms coordinates ref erence frame use respresentation called nonparametric example represent surface either following cartesian functions fix z z fix first form gives implicil expression surface second form gives explicit representation x independent variables z dependent variable similarly represent three dimensional curved line nonparamet ric form intersection two surface functions could represent curve pair functions flx z g x coordinate x selected independent variable values depen dent variables z determined eqs step values x one line endpoint endpoint nonparametric representations useful describing objects within given reference frame disadvantages used graphics algorithms want smooth plot must change independent variable whenever first derivative slope either f x g x becomes greater means must continually check values derivatives may become infinite points also eqs provide awkward format representing multiple valued functions instance implicit equation circle centered origin xy plane yor p explicit expression multivalued function svaa x general convenient representation object descriptions graphics algorithms terms parametric equations parametric representations euclidean curves one dimensional objects positions along path three dimensional curve described single parameter u express three cartesian coordinates terms parameter yu point curve represented following vector point function relative particular cartesian reference frame pq x u u u often coordinate equations set parameter u defined unit interval example circle xy plane center coordinate origin could defined parametric form x u rcos u rsin zlu usl 77 parametric forms also possible describing circles circular arcs curved plane euclidean surfaces two dimensional objects po sitions surface described two parameters u v coordinate position surface represented parametric vector function p x x u v yu v z u v section parametric representations appendix figure section spherical surface described lines constant u lines constant v eqs cartesian coordinate values x z expressed functions parameters u v curves often possible arrange parametric descriptions parameters u v defined range from0 spherical surface center coordinate origin example de scribed equations x u v rsin au cos 10 u v r sin ans sin u rcos mu r radius sphere parameter u describes lines constant lati tude surface parameter v describes lines constant longitude keeping one parameters fixed varying subinterval range could plot latitude longitude lines spher ical section fig numerical methods computer graphics algorithms often necessary solve sets linear equa tions nonlinear equations integral equations functional forms also visualize discrete set data points may useful display continuous curve surface function approximates points data set sec tion briefly summarize common algorithms solving various numer ical problems solving sets linear equations variables x k write system n linear equations ax app f ayyxy ay xy aygk ay x yy xy aygxz aan xy b values parameters b known set equations expressed matrix form ax b n square matrix whose elements coefficients aj x column matrix x values b column matrix b values solution set simultaneous linear equation expressed matrix form x b depends inverse coefficient matrix thus system equations solved nonsingular matrix deter minant nonzero one method solving set equations cramer rule det k deta matrix kth column replaced elements b method 1s adequate problems variables three four variables method extremely inetficient due large number multiplications needed evaluate determinant evaluation single n n determinant requires n multiplications solve system equations efficiently using variations gaussian elimination basic ideas gaussian elimination illustrated following set two simultaneous equations x 2x 3x 4x solve set equations multiply first equation add two equations elimunate x term yielding equation 2x solution x value substituted either original equations obtain solution x efficient algo tithms devised carry elimination back substitution steps gaussian elimination sometimes susceptable high roundoff errors may possible obtain accurate solution cases may able obtain solution using gauss seidel method start initial guess values variables x repeatedly calculate successive ap proximations difference successive values small iteration calculate approximate values variables _ yax ay3 minkn x ay oy ky bx oak nx xp el rearrange matrix diagonal element magnitude greater sum magnitudes elements acrass row gauss seidel method guaranteed converge solution finding roots nonlinear equations root function f x value x satisfies equation f x one popular methods finding roots nonlinear equations new ton raphson algorithm algorithm iterative procedure approximates function f x straight line step iteration shown fig start initial guess x value root calcu section numerical methods tangent line figure approximating curve initial value xq straight line tangent curve point late next approximation root x determining tangent line xp crosses x axis xg slope first derivative curve af _ feo dx xxq xy thus next approximation root x xp xo oo fo f repeat procedure calculated approximation difference successive approximations small enough newton raphson algorithm converges root converge faster root finding method may always converge example method fails derivative f x point iteration also depending oscillations curve successive approximation may diverge position root newton raphson algorithm ap plied function complex variable f z sets simultaneous nonlin ear functions real complex another method slower guaranteed converge bisection method need first determine x interval contains root apply binary search procedure close root first look midpoint interval determine whether root lower upper half terval procedure repeated successive subinterval differ ence successive midpoint positions smaller preset value speedup attained interpolating successive x positions instead halv ing subinterval false position method evaluating integrals integration summation process function single variable x inte gral f x area curve illustrated fig integral fix numerically approximated following summation food feooda b k f x approximation f x interval ax example approximate curve constant value subinterval add areas resulting rectangles fig smaller subdivisions interval fram b better approximation point actually section numerical methods figure integral f x equal ta amount area function x axis interval froma b f x j xg xy vas x figure approximating integral sum areas small rectangles intervals get small values successive rectangular areas get lost roundoff error polynomial approximations function subinterval generally give better results rectangle approach using linear approximation obtain subareas trapezoids approximation methad ferred trapezoid rule lf use quadratic polynomial parabola ap proximate function subinterval method called simpson rule integral approximation b ax n n faddx aa fb fly fx oddk evenk interval bis divided n equal width intervals b ax n n multiple xo xy xo ax k n functions high frequency oscillations fig approxima tion methods previously discussed may give accurate results also multiple integrals involving several integration variables difficult solve simp fix figure _ _ function high frequency b x oscillations son rule approximation methods cases apply monte carlo integration techniques term monte carlo applied method uses random numbers solve deterministic problems apply monte carlo method evaluate integral function one shown fig generating n random positions rectangular area contains f x interval b fig approximation integral calculated b fade ho sou parameter noun count number random points tween f x x axis random position x rectangular region computed first generating two random numbers r carrying calculations vinx yin x r b ymin 72h similar methods applied multiple integrals random numbers r r uniformly distributed interval obtain random numbers randam number function high level language statistical package use following algorithm called linear congruential generator aiy e modm k ik ef parameters c ig integers ig starting value called seed parameter chosen large possible particular machine values c chosen make string random numbers long possible value repeated example machine bit integer representations set toy yonex olxyl b figure rectangular area enclosing yeni function f x interval b fitting curves data sets section waa numerical methods standard method fitting function linear nonlinear set data points least squares algorithm two dimensional set data points yy yd k first select functional form f x could straight line function polynomial function curve shape determine differences deviations f x values x compute sum deviations squared e sly fool k parameters function f x determined minimizing expression e example linear function fx ag yx parameters ap assigned values minimize e determine val ues solving two simultaneous linear equations result minimization requirements e minimum partial de rivative respect partial derivative respect 0e de ay 0a similar calculations carried functions polynomial fi a9 x agx x need solve set n linear equations determine valves parameters also apply least squares fitting functions several variables f xy xz x linear nonlinear variables bibliography akeley k jermoluk high performance polygon rendering proceedings siggraph computer graphics pp 246 akeley k realityengine graphics proceed ings siggraph computer graphics proceedings pp 116 amanatides j ray tracing cones pro ceedings siggraph computer graphics pp 135 amburn p e grant whitted managing geometric complexity enhanced procedural mod els proceedings siggraph computer graph ics pp 196 yo k usami kurihara simple method extracting natural beauty hair proceedings siggraph computer graphics pp 120 apple computer inc inside macintosh volume addison wesley reading apple computer inc human interface guidelines apple desktop interface addison wesley reading arvo j kirk fast ray tracing ray clas sification proceedings siggraph computer graphics pp 64 arvo j kikk particle transport image synthesis proceedings siggraph computer graphics pp 66 arvo j ed graphics gems h academic press inc san diego ca atherton p r scan line hidden surface moval procedure constructive solid geometry proceedings siggraph computer graphics pp 82 bararr analytical methods dynamic simu lation non penetrating rigid bodies proceedings siggraph computer graphics pp 232 bararr witkin dynamic simulation non penetrating flexible bodies proceedings siggraph computer graphics pp 308 barkans c high speed high quality tialised vector generation proceedings sig graph computer graphics pp 326 barnsley f jacquin f malassent et al harnessing chaos image synthesis proceed ings siggraph computer graphics pp 1490 barnsey fractals everywhere second edition academic press inc san diego ca barr h superquadrics angle preserving transformations eee computer graphics applica tions pp 23 barr h ray tracing deformed surfaces proceedings siggraph computer graphics pp 296 barsky b j c beatty local control bias tension beta splines acm transactions graphics pp 134 barsky b discription evaluation vari ous models eee computer graphics applica tions pp 52 barzel r h barr modeling system based dynamic constraints proceedings sig graph computer graphics pp barze r physically based modeling computer graphics academic press inc san diego ca baum r mann k p smrth ft al making radiosity usable autamatic preprocessing mesh ing techniques generation accurate radiosity solutions proceedings siggraph computer graphics pp 61 becker c w barrett r olsen jr interactive measurement three dimensional ob jects using depth buffer linear probe acm transactions graphics pp 207 becker b g n l max smooth transitions bump rendering algorithms proceedings siggraph computer graphics proceedings pp 190 brier neely feature based image meta morphosis proceedings siggraph com puter graphics pp 42 bergman l h fucus e grant et al image rendering adaptive refinement proceedings siggraph computer graphics pp 38 bergman l j richardson c richardson et al view eploratory molecular visualization system user definable interaction sequences proceedings siggraph computer graphics pro ceedings pp 126 bezier p numerical control mathematics appli cations translated r forrest f pankhurst john wiley sons london bier e mackay stewart et al snap dragging proceedings siggraph computer graphics pp 248 bier e c stone k pier et al toolglass magic lenses see interface pro ceedings siggraph computer graphics proceed ings pp 80 bishop g wiemer fast phong shading proceedings siggraph computer graphics pp 106 blake j w phigs phigs plus academic press london bleser tae plus styleguide user interface de scription nasa goddard space flight center green belt md bunn j f anp fe newelt texture reflec tion computer generated images cacm 10 pp 547 blinn j f models light reflection com puter synthesized pictures computer graphics pp 198 blinn j f e newell clipping using ho mogeneous coordinates computer graphics pp 251 blinn j f simulation wrinkled surfaces computer graphics pp 292 blinn j f generalization algebraic surface drawing acm transactions graphics pp 256 blinn j f light reflection functions simula tion clouds dusty surfaces proceedings siggraph computer graphics pp 29 blinn j f trip graphics pipeline homogeneous perspective transform eee com puter graphics applications pp 80 bloomenthal j modeling mighty maple proceedings siggraph computer graphics pp 312 bono p r j l encarnacao e r hopcoop et al gks first graphics standard eee com puter graphics applications pp 23 booth k p bryden w b cowan et al parameters human visual performance vestigation benefits antialiasing ieee com puter graphics applications pp 41 bresenham j e algorithm computer control digital plotter ibm systems journal pp 30 bresenham j e linear algorithm incremen tal digital display circular arcs cacm pp 106 brooks f p jr walkthrough dynamic graph ics system simulating virtual buildings interactive 3d brooks f p jr grasping reality tlu sion interactive graphics serving science chi pp 11 brooks j p frederick quh young j j batter et al project grope haptic display scientific visualization proceedings siggraph com puter graphics pp 185 brown h r sedgewick system al gorithm animation proceedings siggraph computer graphics pp 186 brown j r cunningham programming user interface john wiley sons new york bruderlin w calvert goal directed dynamic animation human walking proceed ings siggraph computer graphics pp 242 brunet p navazo solid representation operation using extended octrees acm transactions graphics pp 197 bryson c levit virtual wind tunnel ieee computer graphics applications pp 34 burt p j e h adelson multiresolution spline application image mosaics acm transactions graphics pp 236 buxton w r lamb sherman et al wards comprehensive user interface management system proceedings siggraph computer graphics pp 42 buxton w r hill p rowley issues techniques touch sensitive tablet input pro ceedings siggraph computer graphics pp 224 calvert bruderlin dill et al desktop animation multiple human figures ieee computer graphics applications pp 26 cambell g f defanti frederiksen et al two bit pixel full color encoding proceedings siggraph computer graphics pp 224 camps lt iil fussell adaptive mesh generation global diffuse illumination proceedings siggraph computer graphics pp 164 carp k j mackinlay g g robertson information visualizer information work space chi pp 188 carignan yang n thalmann al dressing animated synthetic actors complex deformable clothes proceedings siggraph computer graphics pp 104 carlbom chakravarty vanderschel hierarchical data structure representing spatial decomposition objects ieee compuler graphics applications pp 31 carpenter l buffer antialiased hid den surface method proceedings siggraph computer graphics pp 108 carroll j c carrithers training wheels user interface cacm pp 806 casale e l stanton overview analytic solid modeling ieee computer graphics applications pp 56 catmull fe computer display curved sur faces proceedings ieee conference com puter graphics pattern recognition data structures also freeman pp 315 catmull e analytic visible surface algo rithm independent pixe processing proceed ings siggraph computer graphics pp 115 chazelle b j incerpi triangulation atl shape complexity acm transactions graphics pp 152 cuen j mountfurd sellen study interactive 3d rotation using 2d control devices proceedings siggraph computer graphics pp 130 cuen e h e rushmeier g miller et al progressive multi pass method global ilumina tion proceedings siggraph computer graphics pp 174 chin n feiner near real time shadow generation using bsp trees proceedings sig graph computer graphics pp 106 chuang r g entis shaded computer animation step step eee computer graphics applications pp 25 chung j c et al exploring virtual worlds head mounted visual displays proceedings spie meeting non holographic true dimensional display technologies january pp 20 clark j h geometry engine vlsi georm etry system graphics proceedings sig graph computer graphics pp 133 couen f p greenberg hemi cube radiosity solution complex environ ments proceedings siggraph computer graphics pp 40 cohen f e chen j r wallace et al progressive refinement approach fast radiosity image generation proceedings siggraph computer graphics pp 84 cohen f j r wallac radtosity realis inc image synthesis academic press boston cook r l k e torrancr reflectance model computer graphics acm transactions graphics pp 24 cook r l porter l carpenter distrib uted ray tracing proceedings siggraph computer graphics pp 145 cook r l shade trees proceedings af sig graph computer graphics pp 231 cook r l stochastic sampling computer graphics acm transactions graphics pp 72 coon r l l carpenter aso eb carmutt reyes image rendering architecture proceedings siggraph computer graphics pp 102 coouuillart p jancene animated free form deformation interactive animation tech nique proceedings siggraph computer graphics pp 26 crow f c ahasing problem computer synthesizec shaded images cacm pp 805 crow f c shadow algorithms computer graphics proceedings siggraph computer graphics pp 248 crow f c lise grayscale improved raster display vectors characters proceed ings siggraph computer graphics pp crow fc comparison antialiasing tech niques eee computer graphics applications pp 49 crow f c flexible image generation en vironment proceedings siggraph com puter graphics pp 18 cruz neira c j sandin defanti surround screen projection based virtual reality design implementatior cave proceed ings siggraph computer graphics proceedings pp 142 cunningham n k craighill w fong et al ed computer grapincs using object oriented pro gramming john wiley sons new york cutler e gilly reiuty ed tue x win dow system nutshell second edition reilly assoc inc sebastopol ca cyrus j beck generalized two three dimensional clipping computers graph ics pp 28 day implementation algorithm find convex hull set three dimensional points acm transactions graphics pp 132 de reerve p c edelin j francon et al plant models faithful botanical structure develop ment proceedings siggraph computer graphics pp 158 deering high resolution virtual reality proceedings siggrapel computer graphics pp 202 deering f r nelson leo system cost effective 3d shaded graphics proceedings ot siggraph computer graphics proceedings pp 108 demko l hodges b naylor construction fractal objects iterated function systems proceedings siggraph computer graphics pp 278 derr w w e howarp flat panel dis plays scientific american pp 97 derose geometric continuity shape para meters geometric constructions catmull rom splines acm transactions graphics pp 41 dicival equipment corp digital equipment cor poration xui style guide maynard dirre j swensen adaptive subdivi sion algorithm parallel architecture realistic image synthesis proceedings siggraph computer graphics pp 158 doskin l gurpas j hershberger et al efficiert algorithm finding csg representation simple polygon proceedings siggraph computer graphics pp 40 doctor l j j g torberg display tech niques octree encoded objects ieee computer graphics applications pp 38 dorsey j fx sillion p greenberg design simulation opera lighting projec tion effects proceedings siggraph cont puter graphics pp 50 dresin r l carpenter p hanrahan volume rendering proceedings siggraph computer graphics pp 74 durr compositing 3d rendered images proceedings siggraph computer graphics pp 44 durerett h j ed color computer academic press boston duvanenko v improved line segment clipping dr dobb journal july dyer whitman vectorized scan line z buffer rendering algorithm ieee computer graph ics applications pp 45 dyer dataflow toolkit visualization ieee computer graphics applications pp 69 earnshaw r ed fundamental algorithms computer graphics springer verlag berlin edfisbrunner h algorithms computational geometry springer verlag berlin edelsbrunner h e p mucke simulation simplicity technique cope degenerate cases geometric algorithms acm transactions graph ics pp 104 elber g e cohen hidden curve removal free form surfaces proceedings siggraph computer graphics pp 104 enderle g k kansy g pfaff computer graphics programming gks graphics standard springer verlag berlin farin g curves surfaces computer aided geo metric design academic press boston farouk r j k hinps hierarchy geo metric forms ieee computer graphics applications pp 78 feder j fractals plenum press new york feiner nacy van dam experi mental system creating presenting interactive graphical documents acm transactions graphics pp 77 ferwerda j p greenberg psy chophysical approach assessing quality tialiased images ieee computer graphics applica tons pp 95 fishkin k p b barsky family new algorithms soft filling proceedings sig graph computer graphics pp 244 fume e l mathematical structure raster graphics academic press boston fotey j v l wallace p chan human factors computer graphics interaction tech niques ieee computer graphics applications 11 pp 48 fotey j interfaces advanced computing scientific american pp 135 fotey j van dam k feiner et al com puter graphics principles practice addison wesley reading fournier fussel l carpenter com puter rendering stochastic models cacm pp 384 fournier montuno triangulating simple polygons equivalent problems acm transactions graphics pp 174 fournier w reeves simple model ocean waves proceedings siggraph com puter graphics pp 84 fournier fussell power frame buffer acm transactions graphics pp 128 fournier e fiume constant time filtering space variant kernels proceedings sig graph computer graphics pp 238 fow er r h meinhardt p prusinkiewicz modeling seashells proceedings siggraph computer graphics pp 387 fox walite computer animation primer mcgraw hill new york francis g k topological picturebook springer verlag new york franklin w r kankanhalli parallel object space hidden surface removal proceedings siggraph computer graphics pp 94 freeman h eb tutorial selected readings teractive computer graphics ieee computer society press silver springs md frenkel k volume rendering cacm pp 435 frieder g gordon r reynold back front display voxel based objects eee com puter graphics applications pp 60 friedhoff r w benzon second com puter revolution visualization harry n abrams inc new york fucus h pizer e r heinz h bloomber l tsai c strickland design lmage editing space filling three dimensional display based standard raster graphics system proceed ings spie august pp 127 fucus h poutton j eyles et pixel planes heterogeneous multiprocessor graphics system using processor enhanced memories proceedings siggraph computer graphics pp 88 fujimoto ano k iwata jag free images raster displays eee computer graphics applica _ hons pp 34 funkhouser c h sequin adaptive dis play algorithms interactive frame rates vi sualizatior complex virtual environments pro ceedings siggraph computer graphics proceedings pp 254 galyean j f huches sculpting teractive volumetric modeling technique proceed ings siggraph computer graphics pp 274 gardner g visual simulation clouds proceedings siggraph computer graphics pp 304 gascuel p implicit formulation pre cise contact modeling flexible solids pro ceedings siggraph computer graphics pp 320 gaskins phigs programming manual reilly associates sebastopo ca gharachorloo n gupta r f sproull et al characterization ten rasterization algorithms proceedings siggraph computer graphics pp 368 girard interactive design 3d computer animated legged animal motion eee computer graphics applications pp 51 glassner space subdivision fast ray tracing eff compuier graphics applications pp 22 glassner adaptive precision texture mapping proceedings siggraph computer grapltics pp 306 glassner spacetime ray tracing anima tion ieee computer graphics applications pp 70 glassner ed introduction ray tracing academic press san diego ca glassner ed graphics gems academic press san diego ca glassner geometric substitution tutor jal ieee computer graphics applications pp 36 glassner principles digital image synthesis morgan kaufmann inc new york gleicher witkin lens camera control proceedings siggraph computer graphics pp 349 goldsmith j j salmon automatic creation object hierarchies ray tracing ieee computer graphics applications pp 20 gonzalez r c p wint2 digital image process ing addison wesley reading goop j whitesice r wixxon j janes building user derived interface cacm 10 pp 1042 goopman r spence effect system response time interactive computer aided prob lem solving proceedings siggraph com puter graphics pp 104 gora c k e torrance p greenberg et al modeling interaction light dif fuse surfaces proceedings siggraph com puter graphics pp 222 goxvon chen fron back display bsp trees jeee computer graphics applications pp 85 gorter j p schroder mf cohen et al wavelet radiosity proceedings siggraph camputer graphics proceedings pp 230 green university alberta user interface management system proceedings siggraph camputer graphics pp 214 greene n kass g miller hierarchical z buffer visibility proceedings siggraph computer graphics proceedings pp 238 hareeru p k akelly accumulation buffer hardware support high quality render ing proceedings siggraph computer graph ics pp 318 hahn j k realistic animation rigid bodies proceedings siggraph computer graphics pp 308 hall r p greenberg testbed alistic image synthesis 1efe computer graphics applications pp 20 hatt r hiemmation ami color computer gener ated imagery springer verlag new york hanrahan p creating volume models edge vertex graphs proceedings siggraph computer graphics pp 84 hanrahan p j lawson language shading lighting calculations proceedings siggraph computer graphics pp 298 hart j c j sandin l h kauffman ray tracing deterministic 3d fractals proceedings siggraph computer graphics pp 296 hart j c defanti efficient antialiased rendering linear fractals proceedings siggraph computer graphics pp 100 x p heynen r l phillips et al fast accurate light reflection model proceedings siggraph computer graphics pp 254 hearn p baker scientific visualization introduction eurographics technical report se ries tutorial lecture heckbert p color image quantization frame buffer display proceedings siggraph com puter graphics pp 307 heckbert p p hanrahan beam tracing polygonal objects proceedings siggraph computer graphics pp 127 hopcoop fr duce j r gallop et al introduction graphical kernel system gks acadc mic press london hopcoon fr duce primer phigs john wiley sons chichester england hope h derose mcdonald et al mesh optimization proceedings siggraph com puter graphics proceedings pp 26 howarp l j w hewrrt r j hubbold et ac practical introduction phigs phigs plus addi son wesley wokingham england hugues j f scheduled fourier volume morph ing proceedings siggraph computer graph ics pp 46 hurrric h nanas b spline surfaces tool computer painting ieee computer graphics applications pp 47 tkebo high speed techniques color graphics terminal fee computer graphics appli cations pp 58 immel fe cohen p greenberg radiosity method non diffuse environments proceedings siggraph computer graphics pp 142 isaacs p f cohen controlling dv namic simulation kinematic constraints behavior functions inverse dynamics proceedings siggraph computer graphics pp 224 jarvis j fc n jupice w h ninke sur vey techniques image display continuous tone pictures bilevel displays computer graphic image processing pp 40 johnson clinical varifocal mirror display system university uf utah proceedings spie august pp 148 kanrya j new techniques ray tracing pro cedurally defined objects acm transactions graph ies pp 181 kaliya j rendering equation proceed ings siggraph computer graphics pp 150 kayrva j l kay rendering fur three dimensional textures proceedings sig graph computer graphics pp 280 kappet r ellipse drawing algorithm faster displays fundamental algorithms com puter graphics springer verlag berlin pp 280 karasick lieber l r nackman effi cient delaunay triangulation using rational arith metic acm transactions graphics pp 91 kass condor constraint based dataflow proceedings siggraph computer graphics pp 330 kasson j w plourfe analysis se jected computer interchange color spaces acm transactions graphics pp 405 kaurman efficient algorithms 3d scan conversion parametric curves surfaces vol umes proceedings siggraph computer graphics pp 179 kawaguchl morpholog cal study form nature proceedings siggraph computer graphics pp 232 kay l anp j kana ray tracing complex scenes proceedings siggraph computer graphics pp 278 kay c j r levine grapltics file formats windcrest mcgraw hill new york kasey c matin ann g nielson terrain simulation using model af stream erosion proceedings siggraph computer graphics pp 264 ken j r woe carlson r e parent shape transformation polyhedral objects proceedings siggraph computer graphics pp 54 kirk j arvo unbiased sampling tech niques image synthesis proceedings sig graph computer graphics pp 156 kirk ed graphics gems hl academic press san diego ca knutu e digital halftones dot diffusion acm transactions graphics pp 273 kocuanek h u ano r h bartets interpolat ing splines local tension continuity bias control proceedings siggraph contputer graphics pp 41 kon e k hearn fast generation sur face structuring methods terrain natural phenomena proceedings eurographs com puter graphics forum pp c 180 korien j u n badler techniques gen erating goal directed motion articulated struc tures ieee computer graphics applications pp 81 koren j u n badler temporal antialias ing computer generated animation proceed ings siggraph computer graphics pp 388 lasseter j principles traditional animation applied 3d computer animation proceedings siggraph computer graphics pp 44 laur p hanrahan hierarchical splatting progressive refinement algorithm volume ren dering proceedings siggraph computer graphics pp 288 laurel b art human computer interface de sign addision wesley reading lee e r redner p uselton statisi cally optimized sampling distributed ray tracing proceedings siggraph computer graphics pp 68 levinthal porter chap simd graphics processor proceedings siggraph computer graphics pp 82 lzvoy display surfaces volume data ieee computer graphics applications pp 37 levoy hybrid ray tracer rendering polygon volume data ieee computer craphics applications pp 40 lewss j p algorithms solid noise synthesis proceedings siggraph computer graphics pp 270 lian 4nnd b barsky analysis al gorithm polygon clipping cacm 11 pp 877 liang b barsky new concept anc method line clipping acm transactions graph ics pp 22 lien l shantz v pratt adaptive ward differencing rendering curves surfaces proceedings siggraph computer graphics pp 118 lindley c practical ray tracing c john wiley sons new york lischinski f tampieri p greenberg combining hierarchical radiosity discontinuity meshing proceedings siggraph computer graphics pp 208 latwinowicz p c inkwell animation system proceedings siggraph computer graphics pp 122 lodding k n iconic interfacing ieee computer graphics applications pp 20 loxe tan h seah et al rendering fireworks displays eee computer graphics appli cations pp 43 loomis j h poizner u bellugi et al computer graphic modeling american sign language pro ceedings siggraph computer graphics pp 114 lorenson w e h cline marching cubes high resolution 3d surface construction algorithm proceedings siggraph camputer graphics pp 169 macckinlay j k card g g robertson rapid controlled movement virtual 3d workspace siggraph pp 176 mackinlay g g robertson k carp perspective wall detail context smoothly tegrated chi pp 179 magnenat thalmann n thalmann com puter animation theory practice springer verlag tokyo magnenat thalmann n thalmann image synthesis springer verlag tokyo magnenat thalmann n thalmann complex models animating synthetic actors ieee computer graphics applications pp 45 mandelbrot b b fractals form chance di mension freeman press san francisco mandelbrot b b fractal geometry nature freeman press new york mantyta introduction solid modeling computer science press rockville md max n l lerner two half motion blur algorithm proceedings siggraph computer graphics pp 94 max n l atmospheric illumination shad ows proceedings siggraph computer graphics pp 124 max n l cone spheres proceedings sig graph computer graphics pp 62 metaxas terzopoulos dynamic defor mation solid primitives constraints pro ceedings siggraph computer graphics pp 312 mever g w h e rushmeier f cohen et al experimental evaluation computer graphics imagery acm transactions graphics pp 50 mever g w p greenberg color defective vision computer graphics displays ieee com puter graphics applications pp 40 meyers skinner k sloan surfaces contours acm transactions graphics pp 258 miller g p motion dynamics snakes worms proceedings siggraph com puter graphics pp 178 miller j v e breen w e lorenson et al geometrically deformed models method ex tracting closed geometric models volume data proceedings siggraph computer graphics pp 226 mitchell p spectrally optimal sampling distribution ray tracing proceedings sic graph computer graphics pp 165 mrtchell p p hanrahan mlumination curved reflectors proceedings siggraph computer graphics pp 291 mrvata k method generating stone wall patterns proceedings siggraph computer graphics pp 394 molnakr j eyles j poulton pixelflow high speed rendering using image composition proceedings siggraph computer graphics pp 240 moon f c chaotic fractal dynamics john wiley sons new york moore j wilhelms collision detection ad response computer animation proceed ings siggraph computer graphics pp 298 mortenson e geometric modeling john wiley sons new york murai volumetric shape description range data using blobby model proceedings sig graph computer graphics pp 235 muscrave f k c e kolb r mace synthesis rendering eroded fractal terrains proceedings siggraph computer graphics pp 50 myers b w buxton creating high inter active graphical user interfaces demonstra tion proceedings siggraph computer graphics pp 258 naylor b j amanatides w thibault merg ing bsp trees yields polyhedral set operations pro ceedings siggraph computer graphics pp 124 newman w h system interactive graphi cal programming sjcc thompson books washington c pp 54 newman w h r f sproull principles inter active computer graphics mcgraw hill new york j j marks spacetime constraints visited proceedings siggraph computer graphics pp 350 nicholl lee r nicholl efficient new algorithm 2d line clipping de velopment analysis proceedings sig graph computer graphics pp 262 nielson g b shriver l rosenblum ed visualization scientific computing eee computer ciety press los alamitos ca nietson g scattered data modeling ieee computer graphics applications pp 70 nishimura h object modeling distribution function method image generation journal electronics comm conf j68 pp 725 nisa e naakamae continuous tone representation three dimensional objects ilumi nated sky light proceedings siggraph computer graphics pp 132 niseaa siral k tadamura et al display earth taking account atmospheric scattering proceedings siggraph computer graphics proceedings pp 182 norton generation display geometric fractals proceedings siggraph computer graphics pp 67 nsf invitational workshop research directions virtual environments computer graphics pp 177 oxase h h imaoka tomiha et al three dimensional apparel cad system proceedings siggraph computer graphics pp 110 opengl architecture review board opengl pro gramming guide addision wesley reading oppenheimer p e real time design anima tion fractal plants trees proceedings sig graph computer graphics pp 64 osf motir osf motif style guide open software foundation prentice hall englewood cliffs nj painter j k sloan antialiased ray tracing adaptive progressive refinement proceedings siggraph computer graphics pp 288 pano line drawing algorithms parallel machines ieee computer graphics applications pp 59 pavirois algorithms graphics image pro cessing computer science press rockville md pavurpis curve fitting conic splines acm transactions graphics pp 31 pacey r modeling waves surf pro ceedings siggraph computer graphics pp 74 perrgen h p h richter beauty frac tals springer verlag berlin perrrcen h saupe ed science frac tal images springer verlag berlin pentland j williams good vibrations modal dynamics graphics animation pro ceedings siggraph computer graphics pp 222 peruin k ann e horrerr hypertexture proceedings siggraph computer graphics pp 262 puiturs r l query language network data base graphical entities proceedings siggraph computer graphics pp 185 phong b iltumination computer generated images cacm pp 317 pinepa j parallel algorithm polygon ras terization proceedings siggraph computer graphics pp 20 prreway l v j watkinson bresen ham algorithm gray scale cacm 11 pp 626 piatt j c h barr constraint methods flexible models proceedings siggraph computer graphics pp 288 porter duff compositing digital im ages proceedings siggraph computer graphics pp 259 potmesil chakravarty synthetic image generation lens aperture camera model acm transactions graphics pp 108 pormesil il chakravarty modeling mo tion blur computer generated images proceed ings siggraph computer graphics pp 399 potmesil e horfert frames soft ware tools modeling rendering animation 3d scenes proceedings siggraph computer graphics pp 93 potmesil e hoffert pixel chine parallel image computer proceedings siggraph computer graphics pp 78 pratt w k digital image processing john wiley sons new york preparata f p m_ shamos computational geometry springer verlag new york press w h teukolsky w vetterling et al numerical recipes c cambridge university press cambridge england prusinkiewicz p hammel e mjolsness animation plant development proceedings siggraph computer graphics proceedings pp 360 pruyn p w p greenberg exploring 3d computer graphics cockpit avionics ieee cam puter graphics applications pp 35 quek l h anp hearn efficient space subdi vision methods ray tracing algorithms univer sity lllinois department computer science report uiucdcs r ralbert h j k hodgins animation dy namic legged locomotion proceedings sig graph computer graphics pp 358 reeves w particle systems technique modeling class fuzzy objects acm transactions graphics pp 108 reeves w particle systems technique modeling class fuzzy objects proceedings siggraph computer graphics pp 376 reeves w r blau approximate prob abilistic algorithms shading rendering struc tured particle systems proceedings siggraph computer graphics pp 321 reeves w h salesin r l cook ren dering antialiased shadows depth maps pro ceedings siggraph compuier graphics pp 291 requicha g j r rossignac solid mod eling beyond ieee computer graphics applica tions pp 44 reynowps c w computer animation scripts actors proceedings siggraph com puter graphics pp 296 reynolds c w flocks herds schools distributed behavioral model proceedings sig graph computer graphics pp 34 riesenfeld r f homogeneous coordinates projective planes computer graphics ieee com puter graphics applications pp 55 robertson p k visualizing color gamuts user interface effective use perceptual color spaces data displays eee computer graphics applications pp 64 robertson g g j mackinlay k carb cone trees animated 3d visualizations hierarchi cal information chi pp 194 rocerrs f r earnshaw ed techniques computer graphics springer verlag new york rocers f j adams mathematical elements computer graphics mcgraw hill new york rosenthal h et al detailed semantics graphics input devices proceedings sig graph computer graphics pp 38 rusine specifying gestures example proceedings siggraph computer graphics pp 337 rushmeier h k torrance zonal method calculating light intensities presence participating medium proceedings sig graph computer graphics pp 302 rushmeier h e k e torrance extending radiosity method include specularly reflecting translucent materials acm transactions graph ics pp 27 sabella p rendering algorithm far visualizing 3d scalar fields proceedings siggraph computer graphics pp 58 sasin contouring state art fundamental algorithms computer graphics r earnshaw ed springer verlag berlin pp 482 sa rsin r barzel adjustable tools object oriented interaction metaphor acm transac tions graphics pp 107 samet h r e wesber sorting collection polygons using quadtrees acm transactions graph fes pp 222 samet h tamminen bintrees csg trees time proceedings siggraph computer graphics pp 130 samet h r e webber hierarchical data structures algorithms computer graphics part ieee computer graphics applications pp 75 samer h r e wesber hierarchical data structures algorithms computer graphics part ieee computer graphics applications pp 68 scheifler r w j gettys x window sys tem acm transactions graphics pp 109 schoeneman c j dorsey b smits et al global wumination proceedings siggraph com puter graphics proceedings pp 146 schroder p p hanrahan form fac tor two polygons proceedings sig graph computer graphics proceedings pp 164 schwarrttz w w b cowan j c beatty experimental comparison rgb yiq lab hsv opponent color models acm transactions graphics pp 158 sederberg w e greenwood physically based approached shape bending proceed ings siggraph computer graphics pp 34 sederberg w p gao g wang et al 2d shape blending intrinsic solution vertex path prob lem proceedings siggraph computer graphics proceedings pp 18 segal using tolerances guarantee valid polyhedral modeling results proceedings sig graph computer graphics pp 114 segal c koropiin r van widenfelt et al fast shadows lighting effects using texture map ping proceedings siggraph computer graphics pp 252 sequin c h e k smyei parameterized ray tracing proceedings siggraph computer graphics pp 314 sherr electronic displays john wiley sons new york shilling w strasser exact algorithm hardware architecture improved buffer proceedings siggraph computer graphics proceedings pp 92 shirley p ray tracing method illumination calculation diffuse specular scenes graphics inter face pp 212 shneiderman b designing user interface addi son wesley reading shoemake k animating rotation quater nion curves proceedings siggraph com puter graphics pp 254 sibert j l w hurley w bleser ob ject oriented user interface management system proceedings siggraph computer graphics pp 268 sillion f x c puech general two pass method integrating specular diffuse reflection proceedings siggraph computer graphics pp 344 sillion f x j r arvo h westin et al global ilumination solution general reflectance distributions proceedings siggraph com puter graphics pp 196 sms k particle anmation rendering using data parallel computation proceedings sig graph computer graphics pp 413 sims k artificial evolution computer graph ics proceedings siggraph computer graph ics pp 328 singh b j c beatty k booth et al graph ics editor benesh movement notation proceed ings siggraph computer graphics pp 62 situ r color gamut transform pairs com puter graphics pp 19 smirn r tint fill computer graphics pp 283 smith r plants fractals formal lan guages proceedings siggraph computer graphics pp 10 smith r b experiences altemate reality kat example tension literalism magic ieee computer graphics applications pp 50 smitn r planar pass texture mapping warping proceedings siggraph computer graphics pp 272 sits b e j r arvo h salesin im portance driven radiosity algorithm proceedings siggraph computer graphics pp 282 snyder j j kajiva generative model ing symbolic system geometric modeling proceedings siggraph computer graphics pp 378 snyder j r woopwury k fleischer et al interval method multi point collisions time dependent curved surfaces proceedings siggraph computer graphics pp 334 sproull r f e sutherland clipping di vider afips falt joint computer conference stam j anne fume turbulent wind fields gaseous phenomena proceedings siggraph computer graphics proceedings pp 376 stetiner p greenberg computer graphics visualization acoustic simulation pro ceedings siggraph computer graphics pp 206 strassmann hairy brushes proceedings siggraph computer graphics pp 232 strauss p r carey object oriented 3d graphics toolkit proceedings siggraph computer graphics pp 349 sune h c k g rogers w j kusitz crit ical evaluation pex ieee computer graphics ap plications pp 75 sutherland e sketchpad man machine graphical communication system aftps spring joint computer conference pp 346 sutherland e r f sproull r schumacker characterization ten hidden surface al gorithms acm computing surveys pp 55 sutherland e g w hopogman reentrant polygon clipping cacm pp 42 swezey r w e g davis case study human factors guidelines computer graphics ieee computer graphics applications pp 30 takala j hahn sound rendering pro ceedings siggraph computer graphics pp 220 tannas j lawrence e ed flat panel displays ana crts van nostrand reinhold company new york teller p hanrahan global visibility al gorithms umination computations proceed ings siggraph computer graphics proceedings pp 246 terzopoulos j platt h barr et al elasti cally deformable models proceedings sig graph computer graphics pp 214 thalmann ep scientific visualization graph ics simulation john wiley sons chichester england tuibault w c b f naylor set operations polyhedra using binary space partitioning trees proceedings siggraph computer graphics pp 162 torberg j g parallel processor architecture graphics arithmetic operations proceedings siggraph computer graphics pp 204 torrance k e ann e sparrow theory specular reflection roughened surfaces optical society america pp 1114 travis effective color displays academic press london ture e r visual display quantitative infor mation graphics press cheshire cn turre e r envisioning information graphics press cheshire cn turkowskl k antialiasing use ot coordinate transformations acm transactions graphics pp 234 upson c keeler vbuffer visible vol ume rendering proceedings siggraph computer graphics pp 64 upson c faulhaber jr kamins et al application visualization system computational en vironment scientific visualization ieee computer graphics applications pp 42 upstitt renderman companion addison wesley reading van de panne e fiume sensor actuator networks proceedings siggraph computer graphics proceedings pp 342 van wik j j spot noise texture synthesis data visualization proceedings siggraph computer graphics pp 318 veenstra j n ahuja line drawings octree represented objects acm transactions graphics pp 75 velho l j gomes digital halftoning space filling curves proceedings sig graph computer graphics pp 90 von herzen b h barr h r zatz geo metric collisions time dependent parametric sur faces proceedings siggraph computer graphics pp 48 wallace v l semantics graphic input devices proceedings siggraph computer graphics pp 65 wallace j r k elmquist e haines ray tracing algorithm progressive radiosity proceedings siggraph computer graphics pp 324 waanger l r j ferwerda p greenberg perceiving spatial relationships computer gener ated images ieee compuler graphics applications pp 58 wart c color sequences univariate maps theory experiments principles ieee computer graphics applications pp 49 warn r lighting controls synthetic im ages im proceedings siggraph computer graphics pp 21 warnock j k wyatt device indepen dent graphics imaging model use raster de vices proceedings siggraph computer graphics pp 319 watt fundamentals three dimensional com puter graphics addison wesley wokingham england wat light water interaction using backward beam tracing proceedings siggraph cont puter graphics pp 386 watt wart advanced animation ren dering techniques addison wesley wokingham eng land wechorst h g hoorer ant p greenberg improved computational methods ray tracing acm transactions graphics pp 69 weil j synthesis cloth objects pro ceedings siggraph computer graphics pp 54 weiler k p atherton hidden surface moval using polygon area sorting proceedings siggraph computer graphics pp 222 weiler k polygon comparison using graph representation proceedings siggraph computer graphics pp 18 westin h j r arvo k e torrance pre dict ng reflectance functions complex surfaces proceedings siggraph computer graphics pp 264 westover l footprint evaluation volume rendering proceedings siggraph com puter graphics pp 376 whitted improved ilumination model shaded display cacm pp 349 whitted weimer software testbed development 3d raster graphics systems acm transactions graphics pp 58 wuirtep antialiased line drawing using brush extrusion proceedings siggraph camputer graphics pp 156 wilhelms j toward automatic motion control ieee computer graphics applications pp 22 wilhelms j v gelder coherent projec tion approach direct volume rendering pro ceedings siggraph computer graphics pp 284 wilhelms j van gelder octrees faster isosurface generation acm transactions graphics pp 227 williams l performance driven facial anima tion proceedings siggraph computer graphics pp 242 williams p l visibility ordering meshed polyhe dra acm transactions graphics pp 126 witkin w wetcn fast animation control nonrigid structures proceedings sig graph computer graphics pp 252 witkin kass reaction diffusion tex tures proceedings siggraph computer graphies pp 308 wolfram mathematica addison wesley read ing woo p poulin fournier survey shadow algorithms ieee computer graphics ap plications pp 32 wricut w e parallelization bresenham line circle algorithms eee computer graphics ap plications pp 67 wu x efficient antialiasing technique proceedings siggraph computer graphics pp 152 wyszeckl g w stites color science john wiley sons new york ww g b wyvill c mcpheeters solid texturing soft objects ieee computer graphics applications 12 pp 26 yagger l c upson r myers combining physical visual simulation creation planet jupiter film proceedings sig graph computer graphics pp 94 yagel r cohen kaufman discrete ray tracing ieee computer graphics applications pp 28 yamaguchs k l kunn fujimura octree related data structures algorithms ieee com puter graphics applications pp 59 youn x window system programming applications xt osf motif ediiion prentice hail englewood cliffs nj zeleznick r c b conner wloka et al object oriented framework integration interactive animation techniques proceedings siggraph computer graphics pp 112 zevtzsr motor control techniques figure animation ieee computer graphics applications pp 60 zhang r e webber space diffusion improved parallel halftoning technique using space filling curves proceedings siggraph com puter graphics proceedings pp 312 subject index absolute coordinates buffer algorithm 76 acoustic digitizer 67 active edge list active matrix lcd adaptive sampling 40 adaptive spatial subdivision bsp tree ray tracing 38 additive color model affine transformation aliasing alignment text ambient light see aise mlumination models ambient reflection coefficient american national standards institute ansi angle direction vector incidence phase refraction rotation specular reflechon angstrom animation accelerations 94 action spevifications applications 18 24 cels color table direct motion specification 95 double buffering dynamics 96 frame frame functions goal directed betweens inverse dynamics mverse kinematics key frame key frame systein kinernatics 95 kochanek bartels splines 27 languages morphing 91 motion specification 96 object definitions parametrized system physically based modeling 95 taster methods 87 real time scene description scripting system storyboard ansi amencan national standards institute antialiasing area boundaries 78 area sampling 539 filtering 75 lines 76 nyquist sampling interval pitteway watkinson 78 pret phasing pixel weighting masks prefiltering postfiltering ray tracing 43 stochastic sampling 43 supersampling 74 40 surface boundaries 43 texture mapping 56 application icon applications ser graphics applications approximation spline area clipping 44 area filling ser afso fill area antialiasing 78 boundary fill algorithm 30 bundled attributes curved boundaries 30 flood fill algorithm functions hatch nonzero winding number rule 26 odd even rule scan line algonthm 27 soft fill 63 tint fill unbundled attributes area sampling aspect ratio aspect source flag area subdivision visibility algorithm 85 artificial reality see virtual reality attentuation function attribute area fill 03 bundled 69 brush 52 character 68 70 color 57 curve 54 grayscale individual inquiry functions intensity level see alse color intensity levels line color 50 69 hne type 46 69 line width 49 69 marker 68 parameter pen 52 structure 54 system list table text 68 70 unbundled axis reflection rotation 20 shear axis vector rotatian 15 axis vectors basis axonometric projection b back face detection 72 back plane clipping background ambient light bar chart 12 38 barn doors light control baseline character base vector ser also basis basis coordinate vectors normal orthogonal orthonormal basis functions see also blending functions basis matrix spline beam penetration crt 43 see also cathode ray tube bernstein polynomials beta parameter beta spline 47 bevel join b zier blending functions 28 bspline conversions closed curve cubic curve curves 33 design techniques 31 matrix properties 30 surfaces 34 bias parameter spline 346 binary space partitioning tree see also bsp tree binding language bisection root finding bitbie bit block transfer bit map see also frame buffer bitrap font 33 blending functions b zier 28 bspline subject index blending hinctions cont cardinal hermite block transfer blobby object body character nonrigid rigid boolean operations area fill raster transformations boundary conditions splme 19 boundary fill algorithms connected region 4xonnected region 30 boundary representation bounding box rectangle volume box covering box filter 75 box dimension b rep boundary representation bresenham algorithm circle line 92 brightness light brownian mation brush pen attributes 52 bsp ray tracing tree visibility algorithm 82 b spline b zier conversions blending functions cox deboor recursion formulas cubic 41 curves 44 knot vector local control matnx nonuniform 44 nanuniform rational nurb open 44 periodic 41 properties 36 quadratic 39 44 rational surfaces 45 tension parameter uniform 44 buffer ser also frame buffer bump function see aiso frame mapping bump mapping 59 bundled attributes bundle table business visualization ser also data visualizahon butt line cap button box cc cabinet projection cad 11 calligraphic vector display camera viewing 36 camera lens effects capline character cardinal spline 25 cardiowd 40 cartesian coordinates 601 cathode ray tube 40 ser also video monitors delta delta shadow mask electrostatic beam deflection 39 focusing high definition inline shadow maak magnetic beam deflection persistence phosphor 39 refresh rate 41 resohution 40 rgb shadow mask 44 catmull rom spline cavalier projection cell array center projection central structure store css cgi computer graphics interface cgm computer graphics metafile character attributes 68 haseline body bottom line capline color descender fonts functions 168 generation 34 grid 56 33 height italic kern outline fonts 56 133 text precision 167 topline typeface 33 vector width 65 characteristic polygon chart bar 12 38 pie 12 40 time line 37 choice input device chromaticity diagram 71 values cie international commission umination circle equation cartesian nonparametric parametric polar circle generating algorithms 102 bresenham midpoint 102 mid point function midpoint decision parameters circle symumetry cohen sutherland line algorithm 30 curves yrus beck line algorithm exterior hardware implementation 64 homageneous coordinates 63 liang barsky line algorithm 32 liang barsky polygon algorithm nichol lee nichal line algorithm 35 nonrectangular window normalized coordinates 61 parallel methods parametric 32 planes 50 63 points polygons 43 region codes straight line segments 37 61 sutherland hodgman polygon algorithm three dimensional 53 two dimensional 45 view volumes 50 63 weiler atherton polygon algorithm 43 window world coordinates cmy color model 75 codes ray tracing coefficient ambient reflection diffuse reflectian matrix specular reflechon transparency cohen sutherland line clipping algorithm 30 coherence 24 color chromatiaty chromaticity diagram 71 chromaticity values coding complementary cube 73 ser also color models dominant frequency dominant wavelength 70 fill 63 gamut 71 hue illuminat c illumination models intuitive concepts 72 lightness hls parameter line 52 69 lookup table 56 marker matching functions model monitor 45 see aise video monitor nonspectral perception 67 primaries pure purity purple line rgb 57 saturation selection considerations 81 shades spectrum electromagnetic standard cie primanes 69 table 56 text tints 577 tones tristimulus vision theory value hsv parameter color model additive cmy 75 hls 80 hsb see hsv model hsv 77 hsv rgb conversion 79 rgb 73 rgb cmy conversion xyz yiq color table animation 87 column vector command icon commission internationale de eclairage cie complementary colors complex number absolute value conjugate euler formula imaginary part length modulus modulus ordered pair representation polar representation 17 pure imaginary real part roots complex plane composite monitor 45 composition matrix computed tomography ct computer aided design cad 11 computer aided surgery computer art 18 computer graphics interface cgd computer graphics metafile cgm concatenation matrix 13 concave polygon splitting 37 cone filter cone receptors cone tracing see aiso ray tracing conic curves 12 49 conjugate complex constant intensity shading 23 constraints 89 constructive solid geometry csg mass calculations octree methods 62 ray casting methods 59 volume calculations 59 continuity conditions spline geometric 19 parametric 18 continuity parameter continuous tone images see also halftone contour intensity border contour plots applications surface lines 90 three dimensional isosurfaces two dimensional isolines 97 contraction tensor control graph control icon control operations centro point spline contra polygon contro surface terrain 77 convex hull 3lo coordinate axis rotations 13 coordinate ams vectors basis coordinate extents coordinate point coordinates absolute current positon homogeneous relative screen coordinate syste cartesian 601 curvilinear cylindrical device left handed local master modeling 29 normalized device normalized projection orthogonal polar right handed screen 76 spherical three dimensional transformation 20 29 two dimensional 602 viewing 20 36 world copy function cox deboor recursion formulas cramer rule cross hatch fil cross product vector crt 40 see also cathode ray tube csg see also constructive solid geometry ct computed tomography scan cubic spline beta m6 bezier 33 b spline interpolation 27 current event record current position curve attnibutes 54 beta spline b czier spline b spline 35 cardinal spline 24 cardioid 40 catmull rom spline circle comic ction 12 49 ellipse fractal 66 see also fractal curves generalized function hermite spline hyperbola koch fractal kochanek bartels spline limagon 40 natural sphire subject index overhauser spline parabola parallel algorithms 13 parametric representations piecewise construction 16 polynomial spiral 40 spline 20 see also spline curve superquadyic 13 symumetry considerations 98 curved surface ellipsoid parametric representations 20 quadric 12 rendenng see surface rendering sphere spline see also spline surface superquadric 13 torus 12 visibility 990 see also visible surface detection curvilnear coordinates cutaway views cylindrical coordinates cyrus beck line clipping algorithm damping constant dashed line 46 data glove 93 see also virtual reality data tablet see ciso digauzer data visualization applicatrons 31 contour plots 97 field lines glyphs isolines 97 isosurfaces taultivanate fields pseudo colur methods scalar fields 99 streamlines tensor fields vector fields 401 volume rendering dda line algorithm 88 deflection coils see also cathode ray tube delta delta shadow mask crt density functian blobby object depth butter algonthm 75 depth cueing 300 depth sorhng algorithm 81 descender character detectability filter 85 determinant 14 device codes 82 device coordinates differental scaling diffuse reflection 500 diffuse retraction digitizer m4 accuracy acoust 67 apphcatons 15 electromagnetic 66 locator device resolution sonic stroke device three dimensional valuator device subyec index dimenstn finlidean fractal 3h4 fractional direvied ime segment vector direchon angles pirechon cosines direct view storage tube dvst display coprocessor controller devices 52 ner processors file list 84 processor 5a sn provessany unl sn program sn pastancr paint line 80 ray tracing path phstribured light soure distributed ray trasieg 43 distribution rav tracing ditheang dot dimnision method error diffusion method 22 matrin noise 20 ordered dither method random dominant frequency dormnant wavelength 76 dot product dot matrix printer dot ciffasion algorithm double buttering dragging drawing methods dvs1 dynamtns 96 ser afso animation aise video monitors display ldge bst stahlet 22 77 ede vector conaected region elashe material nonrigid object flectomagnetic spectrum hlectror beam see also cathode ray tube convergence electrostatic deflectun focusing intensity magnete deflection spat size 40 flectron yun sev ae c athode ray tube electrostatic printer elevtrothermal printer hlement structure element pointer hlevacion view hhpse carlesian equation focus pomt oiidpeint algorithm 10 parametric representation properties symmetry emapsord emussive displays emitter energy cloth modeling function energy distnbution light urce energy propagation radios environment array environment mapping error diffusion algorithm 22 euler formula see alse complex numbers even odd polygon filling rule event input mode queue explicat representation exploded view exterior chipping f false pos tion root hnding far plane chpping fast phong shadimg 77 feedback 76 field hhnes fill algorithms see area filling area attributes 63 see alse area filling color hatch patterns 62 soft 63 styles tint filter box cone 175 function gaussian 75 structure 54 65 workstation pick detectabilic 85 fixed posrhon scaling 193 flaps light control flat pane display emissive gascuischarge light eruthing diode fiz 47 liquid crystal lcd nonemissive passive matny plasma 46 thin film electrolunuinescent flat shading flight simulators 24 flood fill algorithm flood gun focus point ellipse font see alse typeface bitmap 33 cache outline 133 proportionally spaced force constant form factors radiosity 4e forward differences connected region 24 fractal affine constructions 78 box covering methods brownian motion 78 characteristics 63 classification dimension 67 generation procedures 64 generalor geometne constructions 71 geametry ininator invariant set random mcpoint displacement methods self inverse self inversion methods 87 self similar seif similarity z self squaring self squaring methods similarity dimension subdivision methods 78 topological covering methods 66 fractal curve brownian rrotion dimension fractional brownian motion 75 geometric constriclians 68 invariant 87 inversion constrution methods 87 julia set koch mandelbrot set boundary 84 midpoint displacement 75 peano self affine self inverse 87 self similar 71 self squanng snowflake 68 fractai sohd fractal surface brownian dimension four dimensiona 85 geometric constructions 71 midpoint dispiacement 78 self similar 71 self squaring 85 surface rendering terrain 78 fractional brownian motion 78 frachonal dimension frame animation frame buffer bit block transfers copy function loading intensity values 95 lookup table 56 raster transformations 11 read function resalution write function frame mapping fresne reflection laws frequency spectrum electromagnetic front plane ichpping full color system frustum functions 78 sec also function index gamma correction 15 gamut color 71 gas discharge displays gaussian bump gaussian density function 15 gaussian elinunahon gaussian filter 75 gauss seidel method generator fractal geometric continuity spline 19 geometric models cgeometric object properties 17 geometric production rules 89 geometric table geometric transformations gks graphical kernel system gl graphics library global lighting effects 527 glyph goal directed motion gouraud shading model 25 graftal graphical user interface applications backup error handlirg 75 components 76 feedback 76 help facilities icons interactive techmques 93 menus 273 model user dialogue 73 user model windows graphics applications advertising 18 agriculture animations 18 24 architecture art 18 astronomy business 13 18 cad 11 cartugraphy education 24 engineering entertainment 21 facility planning flight simulators 24 geology graphs charts 13 image processing 33 manufacturing mathematics 17 27 medicine modeling simulations 25 31 physical sciences 31 publishing scientific visualization 31 simulations 10 31 simulators 25 training 24 user interfaces virtual reality 67 graphics controller graphics functions 78 see also function index graphics monitors 52 see also video monitors graphics software packages hasic functions 78 gks gl phigs phigs standards 79 three dimensionai graph plotting 39 ser alsu charts graphics tablet 15 67 see aiso diginzer gravitational acceleration gravity field grayscale grids character 33 interactive constructions 90 h halftone approximations 19 color methods dithering 22 patterns halfway vector hard copy devices 75 hatch fill hausdorff besicovitch dimension head mounted display see also virtual reali hemicube radiosity 49 hermite spline 23 hexcone hsv hidden line elimination hidden surface elimination seealso visible surface detection hierarchical modeling 68 high definition video monitor highlighting depth cueing technique 300 primihves specular reflections 504 structures 54 hls color model 80 homogeneous coordinates hooke law horizontai retrace horner polynomial factoring method hsb color model see hsv madel hsv color model 77 hue hyperbola icon ideal reflector ihuminant c ulumination model ambient light attentuation funcuon basic components 511 color considerations combined diffuse specular diffuse reflection 500 flaps ideal reflector intensity attentuation light sources multiple light sources opacity factor phong refraction 10 shadows snell law specular reflection 504 spotlights lransmission vector transparency 11 warn image order scanning subject index image processing 33 image scanners image space methods visibility detection imaginary number impact printer implicit representation betweens index refraction initiator fractal ink jei printer 73 inner product vector line shadow mask crt input devices button box choice data glove 93 dials digitizer 67 80 graphics tablet initializing 88 joystick 64 80 keyboard 80 light pen locator logical classification mouse 80 pick 80 scanner spaceball string stroke switches three dimensional sonic digitizers touch panel 70 trackball valuator 78 voice systems 71 input functions 87 input modes concurrent use event 87 request 85 sample input priority inquiry functions inside outside test polygon odd even rule polygon nonzero winding number rule 26 spatial plane surface inside polygon face instance see also modeling integral equation solving rectangle approximations simpson rule trapezord rule monte carlo eid 24 intensity attentuation depth cueing 300 interpolation shading gouraud modeling 97 see also illumination models radiosity model 51 intensity level adjusting see antaliasing assigning 13 color lookup tables 56 contours borders frame buffer storage gamma correction 15 ratio rgb video lookup table 513 subject index interactive picture construction techniques 92 interlacing scan lines international comision mlumination c1e interpolation spline inverse geometric transformations 22 inverse dynamics inverse kinematics inverse matrix inverse quatermon inverse scanning 1so international standards organization isohines 97 isometric joystick isometric projection isosurfaces j jaggnes sec also antahasing antialiasing jittering joystick locator device movable 64 pick device pressure sensitive isometric stroke device valuator device julia set k ker keyboard choice device locator device pick device string device valuator device key frame key frame system kinematics 96 see also animation knot vector kochanek rartels spline 27 koch curve l lambertian reflector lambert cosine law language binding laser printer lcd liquid crystal display 48 least squares data fitting led hghi emitting diode 47 left handed coordinates legible typeface length complex number vector l grammar liang barsky clipping polygons two dimensional lines 32 light ambient angle madence chromaticity chromaticity diagram 71 diffuse reflection 500 diffuse refraction frequency band hue ideal reflector index refraction illuminant c itumination model see also humination models intensity level assignment 13 lambert cosine law phong specular model properties 68 purity reflection coefficients 502 refraction angle saturation 579 spectrum specular reflection 504 specular refraction speed transparency coefficient wavelength white light buffer ray tracing light emitting diode led 47 lighting model ser also ihumination model lightness hls parameter light pen light source brightness distributed dominant frequency dominant wavelength energy distribution frequency distribution juminance multiple point limagaon line bundled attributes 69 chart 37 clipping see aise line clipping color 50 contour 97 dashed 46 function 96 parametric representation pen brush options sampling rb a4 slope intercept equation type 46 width 49 linear congruential generator linear equation solving cramer rule gaussian elimination gauss seidel line caps line clipping cohen sutherland 30 cyrus beck liang barsky nich3l lee nichol 35 nonrectangular clip window parallel methods parametric 32 three dimensional line drawing algorithms 95 antialiasing 76 bresenham 92 dda 88 frame buffer loading 95 parallel 94 liquid crystal display lcd 48 local coordinates loxal control spline local transformation matrix locator input device logical input device look point lookup table 56 luminance mach band mandelbrot set 84 marching cubes algorithm see lsosurfaces marker 34 marker attributes 68 mask see also pixel mask mass calaulations csg master coordinates matrix addition basis spline b zier b spline cardinal coefficient column concatenation 13 determinant dither hermite identity inverse multiplication 13 nonsingular reflection vow rotation 12 20 scalar multiplication scaling shear singular 6l4 spline characterization square translation transpose medical applications 33 menu mesh polygon 10 metaball model metafile metric tensor 11 midpoint circle algorithm 102 midpoint displaceiment fractal generation 78 midpoint etlipse algorithm 10 miter join 49 mode input device model modelinig ser also graphics applications object representations ilumunation models basic concepts 64 coordinates 29 display procedures geometni hierarchical 63 inslance local coordinates master coordinates modules packages 64 physically based 95 representations 62 structure hierarchies 68 symbol symbo hierarchies 63 transformations 68 29 modules modulus complex monte carlo methods 24 monitor 52 see also video monitor monitor response curve morphing 91 motion blur 43 motion specification 96 mouse 63 choice device locator device pick device stroke device multivariate data visualization n national television system comunittee ntsc natural spline near plane clipping newton raphson root finding 22 newton second law motion nicholl lee nicholl line clipping 35 noise dither 20 nonemissive displays nonemitter nonlinear equation salving bisection false position newton raphson 22 nonparametric representations 19 nonrigid object nonsingular matrix nonspectra color nonuniform b splines 344 nonuniform differentia scaling nonuniform rational b spline nurb nonzero winding number rule 26 normal normalized device coordinates normalized projection coordinates normalized view volumes see aiso clipping normal vector average polygon mesh curved surface interpolation phong shading plane surface view plane 36 ntsc national television system committee numerical methods bisection method cramer rule false position method gaussian elimination gauss seidel method integral evaluations 24 least squares data fitting linear equations 21 monte carlo methods 24 newton raphson method 22 nonlinear equations 22 root finding 22 simpsaon rule trapezoid rule nurb nonuniform rational b spline nyquist sampling interval oo object nonngid flexible picture component nigid 97 object geometry 17 object representahon beta splines 47 b zier splines 34 boundary b rep b splines 45 bsp trees blobby surfaces 15 csg methods 59 cubic spline interpolation 27 data visualization 403 explicit fractal curves surfaces 87 implicit nonparametnic 19 octrees 62 parametric 20 particle systems 92 physically based modeling 95 polygon 10 quadric surfaces 12 rational splines 49 shape grammars 89 space partitioning methods superquadnics 14 sweep constructions 56 object space methods visibility detection oblique projection 43 50 53 octree csg operatians 62 generation 41 visibility detection 87 volume element voxel odd even polygon filling rule one point perspective projection opacity factor order spline curve continuity 19 ordered dither orthogonal basis orthogonal coordinates orthographic projections orthonormal basis outline fant output primitives cell array circie 102 character 34 conic section 12 ellipse 10 fill area 30 marker 34 point 86 polynomial spline straight line segment 94 text 33 outside polygon face overhauser spline subject tndex p paintbrush programs 16 92 painter algorithm depth sorting panning paratola parallel algorithms area filling 21 curve drawing 13 line drawing 94 paral e projection 99 axonometric cabinet cavalier elevation view isometric 41 obl ique 43 50 53 orthographic 48 plan view principal axes shear transformation view volume 50 parametric continuity spline 18 parametric representations 20 circle curve ellipse ellipsoid 12 sphere spline straight line surface 20 torus 12 parametrized system parity odd even rule particle systerns 92 path text passive matrix lcd pattern fll 61 index reference point 60 tepresentation size tiling pattern mapping pattern recognition peano curve pel pen ard brush attributes penumbra shadow perfect reflector persistence perspective projection frustum one point principal vanishing point reference point shear transtormation 56 three point two point vanishing point view volume 49 pet position emission tomography 33 phase angle phigs sve alsa function index attributes 59 70 input 87 modeling 69 output primitives 96 structures 60 three dimensional transformations 26 three dimensional viewing 66 subyect index phigs cont two dimensional transformations two dimensional viewing 23 workstation phigs phong specuiar reflection model phong shading 27 phospher 39 photorealism physically based modeling 95 pick distance 80 filter 85 idenhtier input device 80 window pickability structure picking picture element pixel piecewise approximation spline 16 pie chart 12 40 pitteway watkins antialiasing 78 pivot point pixbi pixel addressing 16 end mask 51 patterns halftone phasing ray 29 weighting mask pixel order scanning 55 pixmap plane clipping 61 coefficients complex equations far clipping inside outside taces near clipping normal vector pian view plasma pancl display 46 plotters ser alsn ponters heltbed color drum flatbed ink jel 73 laser pen rollfeed 75 pount chpping control spline coordinate plotting 86 sampling unit character size point light source polar coordinates polar form complex number 17 polygon active edge list characteristic control edge vector fill 27 ee also area filling inside lace inside outside tests see also plane mesh 10 normal vector outside face plane equation rendering shading 27 ray intersection 44 sorted edge table splitting 37 surface surface detail tables 22 77 polygon clipping paralle methods parametric methods sutherland hodgeman 42 three dimensional weiler atherton 43 polyline 96 polyline connections polynomial curve position emussion tomography pet 33 positioning methods posthitering see alsu antialiasing posting structures precision text 67 prefiltering see also anttaliasing presentation graphics 13 pressure sensitive jovstich primary colors primitives see aiso output primit ves principal axes principal vanishing peint printers dot matrix electrothermal impact laser nonimpact electrostatic ink jet 73 priority structure view transformation input procedural object representation 92 procedural texture mapping 57 production mules 84 progressive refinement radiosity 50 projecting square line cap projection axonometric cabinet cavalier center frustum isometric 41 oblique 43 50 53 orthographic 48 parallel 43 54 perspective 47 56 plane reference point vector 53 view volume window pseudo color methods pure color purity ight purple line q quadric curves quadric surfaces 12 quadnilateral mesh 19 quadtree quaternion addition fractal constructions 85 inverse magnitude multipheahon ordered pawr rearesentation rotations 20 scalar multpheation scalar part vector part r radiant energy radiance radhosity model 51 energy transport equation form factors hemicube 49 luminance progressive refinement 50 reflectivity factor surface enclosure random dither noise 21 random msdpoint displacement methods 78 random scan monitor 42 color refresh display file randomescan system display file graphics controller rocessing unit random walk raster animation 87 raster ops raster scan monitor 41 bilevel bitmap color 45 frame buffer horizontal retrace interlacing pixel pixmap refresh butter vertical retrace raster scan systera cell encoding display processor run length encoding scan conversion video controller 55 raster trans ormations 11 ratonal spline 49 ray casting constructive solid geometry 59 visible surface detection 88 ray tracing adaptive sarphng 40 adaptive subdivision 38 antialiasing 43 area sampling basic algorithm 31 bundles camera lens effects cell traversal 37 codes cone tracing distributed 43 eve ray see pixel ray equation motion blur 43 pixel primary ray 29 polygon intersection 34 radiosity model reflection ray 31 refraction ray secondary ray shadow ray 30 space subdivision 38 sphere intersection 33 stochastic sampling supersampling 40 tree uniform subdivision read function readable typeface real time animation reference point viewing reflection angle inadence axis coefficients 502 diffuse 500 fresnel laws halfway vector lambertian mapping plane ray specular 504 vector reflection transformation reflectivity reflectivity factor radiosity refraction angle s09 diffuse index ray snell law s09 specular transmission vector 31 transparency coefficient vector 31 refresh buffer see aiso frame buffer refresh crt 45 see also cathode ray tube refresh display file refresh rate crt 41 region codes clipping three dimensional two dimensional relative coordinates rendering see surface rendering requesl input mode 85 resolution display device 40 halftone approximations retrace electron beam reyes rgb chromaticity coordinates rgb color mode 73 rgb monntor see alse video manitor right hand coordinate system right hand rule rigid body transformation 97 rigid motion roots nonlinear equalions complex numbers rotation angie axis 20 axis vector 15 composition inverse matnx representation 93 12 19 pivat point quaternion 20 taster methods three dimensional 20 two dimensional 87 93 x axis 12 axis axis 11 rotationa polygon splitting method round join 149 round line cap row vector rubber band methods run length encoding sample input mode sampling adaptive 40 area line 89 nyquist interval point supersampling 74 40 weighted sans serif typeface saturation light scalar data field visualization 99 scalar input methods 78 scalar product two vectors scaling arbitrary directions 94 composition curved objects differential factors fixed point mverse 22 matnix representation nonuniform differential parameters factors raster methods three dimensicnal 22 two dimensioral 88 94 uniform 88 sean conversion areas 30 characters 33 circles 102 curved boundary areas 30 curved lines 13 ellipses 10 patterned ail points polygons 27 straight lines 94 see also line drawing algorithms structure list traversal scan line scan line interlaang scan line algorithms area fillimg 27 63 visible surface detection 78 subject index scanner scanning image order inverse pixel order 55 texture s54 scientific visualization see aiso data visualization screen coordinates see also coordinate system device scripting system animation secondary ray segment self affine fractals 78 self inverse fractals 87 self similar fractals 71 self squaring fractals 85 serif typeface shades color shading algorithm see surface rendering shading model ser also illumination model shadow mask shadow ray 30 shadows modeling 30 penumbra umbra shape grammars 90 shear axis matrix projection mapping 56 three dimensional two dimensional x direction direction z direction shift vector see also translation similarity dimension simpson rule simulations 10 31 sre aiso graphics applications simulators 25 simultaneous linear equation solving 21 singular matrix sketching 16 92 snell law snowflake fractal 68 soft fill 63 software standards 79 solid angle 45 solid modeling see also surtace curved surtace applications 9 constructive solid geometry 59 sweep constructions 56 solid texture sonic digitizer sorted edge table spaceball spacegraph system space sartitioning methods ray tracing adaptive 38 light buffer ray bundles uniform space partitioning representations specular reflection 504 angle coefficient fresnel laws halfway vector parameter subject index specular reflection cont curve 16 approximation basis functions bias parameter b spline 44 characteristic polygon confinuity conditions 19 continuity parameter controt graph control points conversions 50 convex hull cubic interpolation 27 displaying 55 hermite 23 interpolation knot vector kochanek banels 27 lecal control matrix representation natural nurb overhauser rational 49 tension parameter spline generation horner method forward difference method 53 subdivision methods 55 spline surface b zier 34 b spline 45 splitting concave polygons rotational method vector method spotlights spring constant spring network nonrigid body square mairix stairstep effect steradian 45 stereoscopic glasses headsets views 52 301 virtual reality applications 52 stochastic sampling storyboard streamlines string mput device string precision text stroke input device stroke precision text 67 stroke writing display see alsa video monitors random scan structure attributes 54 basic functions 54 central structure store c55 concepts 52 copying creation 52 delection displaying 3g posting editing element ms element pointer filters 85 hierarchy 68 highlighting filter lists metafile pickability posting subdivision methods adaptive ray tracing 38 bsp tree spline generation 55 unifonm ray tracing subtractive color model cmy 75 superquadric 14 supersampling 74 40 surface blobby 15 curved ser also curved surfaces fractal b5 parametric representation 20 plane quadric 12 spline see also spline surface superquadric 14 weighting surface detail 60 bump mapping 59 environment mapping frame mapping 60 image order scanning inverse scanning pattern mapping pixel order scanning polygon mesh 54 procedural texturing 57 solid texture mapping texture mapping 56 texture scanning s54 surface enclosure radiosity surface normal vector surface rendering 98 antialiasing 43 bump mapping 59 constant intensity shading 23 environment mapping fast phong shading 27 flat shading frame mapping cgouraud shading 25 intensity interpolation mach bands normal vector interpolation phong shading 27 polygon methods 27 polygon surface detail procedural texturing 57 radiosity 50 ray tracing 43 texture mapping 56 surface shading ser surface rendering sutherland hodgeman potygon clipping 42 sweep representations 56 symbol hierarchies 63 instance modeling 64 circle 98 curve drawing algorithms 98 ellipse table poly gon attribute edge 22 77 geometric sorted edge table vertex tablet 67 see also digitizer task planning tension parameter spline tensor contraction data field visualization metric terrain fractal 78 tesselated surface text see also character alignment attributes 67 7u clipping generation 33 path precision 67 texture see also surface rendering mapping 56 procedural methods 57 scanning solid space 57 thin film electroluminescent display three point perspective projection tiling time chart tint color tint fill tone color topline character topological covering 66 touch panel 70 trackball transformation affine basic geometric 200 22 commutative 95 composite 200 25 computational efficiency 97 coordinate system 29 functions 26 geometric instance 63 local 68 matrix representations 90 modeling 68 29 noncommutative t94 parallel projection 99 perspective projection taster methods 11 teflection rotation 87 93 20 scaling 88 94 22 shear three dimersional geometric 22 three dimensional viewing 56 translation 85 two dimensional geometnc 205 two dimensional viewing 22 viewing 22 56 window viewport 22 workstation 22 world viewing coordinate 20 38 translation composition curved object distances inverse matrix representation raster methods three dimensional two dimensional 85 vector transmission vector refraction 31 transparency see also refraction ray tracing coefficient modeling 11 opacity factor vector 31 transpose matrix trapezoid rule traversal state list triangle strip tristimulus vision theory true color system twist angle two point perspective projection typeface 33 see also font legible readable sans serif serif u umbra shadow unbundled attributes uniform b splines 44 uniform scahng 88 uniform spatial subdivision octree 62 ray tracing unit cube clipping vector character user dialogue 73 user help facilities user interface 76 93 see also graphical user interface user model uvn coordinate system 38 uv plane vv valuator input device 78 value hsv parameter vanishing point varifucal mirror vector 12 addition basis column components cross product data field visualization 401 direction angles direction cosines dot inner product knot magnitude length polygon edge product propection 53 quaternion representation reflection rotation 15 row scalar multiplicanon scalar dot product space specular reflection 504 surface norma transmission refraction 31 translauon vector method polygon splitting vector monitor vertex table vertical retrace video controller 35 video lookup tabie video monitor see also cathode ray tube calligraphic color crt 45 composite 45 direct view storage rube dvst emissive flat panel full color gas discharge lcd liquid crystal device 48 led light emitting diode 47 nonemissive plasma panel random scan 42 raster scan 41 tefresh crt 45 tesolution 40 rgb stereoscopic 52 thin film electroluminescent three dimensional true colur vector view look point reference point vector twist angle viewing stereoscopic 52 301 three dimensiona two dimensional 45 viewing coordinates left handed three dimensional 34 two dimensional 20 viewing transformation back far clipping plane clipping 63 front near clipping plane frustum functions 23 hardware implementation subject index inpul prionty normalized projection coordinates normalized view volume 61 pipeline 19 33 three dimensional 33 two dimensional 22 viewport 60 view volume window workstation mapping 22 viewing table view plane 34 normal vector position 35 window viewport chpping 61 function 23 prionty three dumensional see view volume two dimensional __ workstation view reference point view vector view volume unit cube normalized perspective 49 parallel 50 view window virtual reality applications 67 display devices 52 input devices environments 93 visible structure visible line detection see also depth cucing visible surface detection buffer method 76 algorithm classification 71 area subdivision method 85 back face detection 72 bsp tree method 82 comparison algorithms 92 curved surfaces 90 depth bulfer z buffer method 75 depth sorting method 81 function 91 image space methods object space methods octree methods 87 painter algorithm depth sorting ray casting method 88 scan line method 78 surface contour plots 90 wireframe methods vision tristimulus theory visualization applications 31 methods 402 see afso data visualization voice systems 71 volume calculations csg 59 volume element volume rendering voxel ww warn lighting model wavelength light weighted sampling weighting surface subyect index weiler atherton polygon clipping algorithm winding number window functions 23 manager projection rotated 20 three dimensicnal viewing 56 two dimensional viewing user intertace view plane 34 workstation 22 windowing transformation panning rooming 19 window viewport mapping 22 wireframe wireframe visibility algorithms workstation graphics applications 60 identifier phigs pick filter 85 structure filters 85 transformation 22 window 22 viewport world coordinates world viewing coordinate transformation 20 38 white function x x axis rotation 12 x direchon shear x window system xyz color model axis rotation direction shear yiq color model zz axis rotahon 11 z buffer algorithm see aiso depth buffer algorithm z direction shear z mouse 63 zooming function index awattevent b buildtransformahonmatrix buildtransformationmatrix3 cc celtarray changestructureldentifier closestructure composematnx composematrix3 composetransformationmatnx compose transformation matnix3 copy allelementsfromstructure 1d deletcalistructures deletcelement deleteelementrange deletcelementsbetweenlabeis delet cstructure deletestructurenetwork e emptystructure evaluate view mappingmatnx pvaliateviewmappingmatrix3 evaluate vieworientationmatnx evaluate viewonentavonmatrixd execules ructure f dllarea hllarea3 filareaset allcrrcle allcarclearc niellipse hiieipsearc nilrectangle g generalizeddrawming nmutive gerchoice gertlocator getlocator3 getpick gerpixel gestring getstroke 2h getvaluator ininaiizechowe initializelocator initializepick initializestring initializestroke imihalizevaluator inquire l label offsetelementpomte openstructure pp polyline polyline3 polymarker poststructure r request hoice requestlocator 83 requestpick requeststring requeststroke 83 tequestvaluator rotate totatex rotatey rotatez samplechoice samplelocator samplepick samplestring samplestroke samplevaluator scale scale3 setcharacterexpansionfactor setcharacterhcight setcharacterspacing setcharacter upvector setchoicemode setcolourrepresentalion seteditmode setelementpointer setelementpointer atlabel set lighlight ngfilter set hlhsridentifier set ndividual asf setintenorc ourlndex setintenorlndex setinteriorreprescntation setinteriorstvle setinteriorstvielndex setinvisibility filter setlinetype setlinewidthscalefactor setlocaltransformation setlocal transformation setlocatormade 82 setmarkersizescalefactor setmarkerly pe setpatternreferencepoint setpattern representation setpattemsize setpickfultes setpickldentifier setpickmode 82 setpixel setpolyhnec olourindex setpolylinelndex setpolzlinerepresentation setpolymarkercolour ndex setpolymarkerindex setpolymarkerrepresentation setstringmode setstrokemcde settextalignment settextculourlndex settextfont settextindex settextmods 82 settextpath settextprecision function index settextrepresentation setyaluatormode setviewlndex setviewrepresentation setviewrepresentation3 setviewtransformationinpulprionity setworkstation view port setworkstation viewpart3 setworkstation window setworkstationwindow3 text text3 ansformpoint transformpoint3 translate translate3 26 u unpostalistructures unpoststructure